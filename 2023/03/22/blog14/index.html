<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="这题超纲了">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
        
            <link rel="preconnect" href="https://npm.elemecdn.com" crossorigin>
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/03/22/blog14/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="身无彩凤双飞翼,心有灵犀一点通。">
<meta property="og:type" content="article">
<meta property="og:title" content="传输层相关协议">
<meta property="og:url" content="http://example.com/2023/03/22/blog14/index.html">
<meta property="og:site_name">
<meta property="og:description" content="身无彩凤双飞翼,心有灵犀一点通。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/TCP.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%BA%8F%E5%88%97%E5%8F%B7.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/SYN%E6%94%BB%E5%87%BB.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/cookie.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E8%BF%9E%E6%8E%A5.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E6%96%AD%E5%BC%80.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/RRT.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/RTO.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%A4%A7%E4%BA%8E.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/SACK.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/ACK%E4%B8%A2%E5%8C%85.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E7%AA%97%E5%8F%A3.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B9.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B91.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B92.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B93.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E6%8E%A5%E6%94%B6%E6%96%B9.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%9C%BA%E6%99%AF1.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E7%AA%97%E5%8F%A3%E6%8E%A2%E6%B5%8B.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%9C%BA%E6%99%AF2.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E6%85%A2%E5%90%AF%E5%8A%A8.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A01.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/%E7%B2%98%E5%8C%85.jpg">
<meta property="og:image" content="http://example.com/2023/03/22/blog14/UDP.jpg">
<meta property="article:published_time" content="2023-03-22T09:01:46.000Z">
<meta property="article:modified_time" content="2023-06-23T06:47:18.033Z">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/03/22/blog14/TCP.jpg">
    
    
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id="></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', '');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/%E6%B4%BE1.jpg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/%E6%B4%BE1.jpg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/%E6%B4%BE1.jpg">
    <!--- Page Info-->
    
    <title>
        
            传输层相关协议 -
        
        这题超纲了的BLOG
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/assets/fonts.css">
    <!--- Font Part-->
    
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    
    
        <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    
    
        <link href="https://fonts.googleapis.com/css2?family=Farsan&display=swap" rel="stylesheet">
    

    <!--- Inject Part-->
    
        
            
    
            
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":true,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":["铜皮","草根","柳筋","骨气","铸庐","洞府境","观海境","龙门境","金丹境","元婴境","玉璞境","仙人境","飞升境","十四境","十五境"]},"code_block":{"copy":true,"style":"mac","font":{"enable":true,"family":null,"url":"https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":true,"title":"推荐阅读","limit":3,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#005080","secondary":null},"global":{"fonts":{"chinese":{"enable":true,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":true,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":false,"scale":true},"scroll_progress":{"bar":true,"percentage":true},"busuanzi_counter":{"enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"pjax":true,"open_graph":true,"google_analytics":{"enable":true,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/水墨/水墨.jpg","dark":"/images/水墨/水墨1.jpg"},"title":"~欢迎来到“派大星”的博客~","subtitle":{"text":["言念君子,温其如玉","我见青山多妩媚,料青山见我应如是","有些人心如花木,皆向阳而生","遇事不决,可问春风。春风不语,即随本心","人生当苦无妨,良人当归即好"],"hitokoto":{"enable":true,"api":null},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#000000","dark":"#FAFFFE"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":true,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"social_links":{"enable":"enable","links":{"github":"https://github.com/Qx-GG","instagram":null,"zhihu":"https://www.zhihu.com/people/bu-shang-530bu-gai-ming","twitter":null,"email":null,"weixin":"/images/微信.jpg","bilibili":"https://space.bilibili.com/38628118?spm_id_from=333.1007.0.0"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.1.5","navbar":{"auto_hide":false,"color":{"left":"#FAFFFE","right":"#FAFFFE","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-chart-bar"},"Links":{"path":"/links","icon":"fa-regular fa-link"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Github":"https://github.com/Qx-GG","Bilibili":"https://space.bilibili.com/38628118?spm_id_from=333.1007.0.0"}},"WorMhole":{"path":"https://foreverblog.cn/go.html","icon":"fa-regular fa-planet-ringed"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"言念君子,温其如玉","links":{"PYQ":{"path":"/shuoshuo","icon":"fa-regular fa-messages"},"Photo":{"path":"/masonry","icon":"fa-regular fa-photo-film"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}}};
    Global.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    Global.data_config = {"masonry":true};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/fontawesome/regular.min.css">
    
    
    
        <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/fontawesome/duotone.min.css">
    
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="null" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/%E6%B4%BE1.jpg">
                </a>
            
            <a class="logo-title" href="/">
                
                这题超纲了的BLOG
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        归档
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/tags"  >
                                    
                                        
                                            <i class="fa-regular fa-chart-bar"></i>
                                        
                                        标签
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/links"  >
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        链接
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/about">ME
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/Qx-GG">GITHUB
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://space.bilibili.com/38628118?spm_id_from=333.1007.0.0">BILIBILI
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    target="_blank" rel="noopener" href="https://foreverblog.cn/go.html"  >
                                    
                                        
                                            <i class="fa-regular fa-planet-ringed"></i>
                                        
                                        WORMHOLE
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                归档
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/tags"  >
                             
                                
                                    <i class="fa-regular fa-chart-bar"></i>
                                
                                标签
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/links"  >
                             
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                链接
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/about">ME</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://github.com/Qx-GG">GITHUB</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://space.bilibili.com/38628118?spm_id_from=333.1007.0.0">BILIBILI</a>
                            </li>
                        
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        target="_blank" rel="noopener" href="https://foreverblog.cn/go.html"  >
                             
                                
                                    <i class="fa-regular fa-planet-ringed"></i>
                                
                                WORMHOLE
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
                      
                <div class="article-title">
                    <img src="https://Qx-GG.github.io/images/水墨/水墨15.jpg" alt="传输层相关协议" />
                    <h1 class="article-title-cover">传输层相关协议</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/%E6%B4%BE%E5%A4%A7%E6%98%9F.png">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">这题超纲了</span>
                            
                                <span class="author-label">柳筋</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-03-22 17:01:46</span>
        <span class="mobile">2023-03-22 17:01</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-06-23 14:47:18</span>
            <span class="mobile">2023-06-23 14:47</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>15.5k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>53 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=486194136&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天梳理一下传输层的一些知识点,特别是关于<strong>TCP</strong>和<strong>UDP</strong>的,篇幅较长,还请各位看官,<strong>慢慢看</strong></p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层:定义了一些传输数据的协议和端口号,如:</p>
<ol>
<li>TCP(传输控制协议,传输效率低,可靠性强,用于传输可靠性要求高,数据量大的数据)</li>
<li>UDP(用户数据报协议,与TCP特性恰恰相反,用于传输可靠性要求不高,数据量小的数据,例如QQ聊天数据就是通过这种方式传输的)。<br><code>主要是将从下层接受的数据进行分段和传输,达到目的地址后再进行重组。常常把这一层数据叫做段</code><br>我们最主要了解的就是TCP协议和UDP协议,其中TCP协议特别重要!</li>
</ol>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>TCP协议又叫做<strong>传输控制协议</strong>,是一种<strong>可靠</strong>,<strong>面向连接</strong>,<strong>基于字节流</strong>的协议,是在运输层的,正是因为它的可靠,HTTP&#x2F;HTTPS协议都是依靠TCP协议的,也就是说,只要<code>支持HTTP/HTTPS协议的就一定支持TCP协议</code></p>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>可靠 </summary>
              <div class="content">
              <p>无论的网络链路中出现了怎样的链路变化,<strong>TCP</strong>都可以保证一个报文一定能够到达接收端</p>
              </div>
            </details>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>面向连接 </summary>
              <div class="content">
              <p>一定是<strong>一对一</strong>才能连接,不能像<strong>UDP</strong>协议 可以一个主机同时向多个主机发送消息,也就是一对多是无法做到的</p>
              </div>
            </details>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>基于字节流 </summary>
              <div class="content">
              <p>消息是<strong>没有边界</strong>的,所以无论我们消息有多大都可以进行传输<br>并且消息是<strong>有序的</strong>,当<strong>前一个</strong>消息没有收到的时候,即使它先收到了后面的字节已经收到,那么也不能扔给应用层去处理,同时对<strong>重复</strong>的报文会自动丢弃</p>
              </div>
            </details>
<h3 id="TCP协议头部"><a href="#TCP协议头部" class="headerlink" title="TCP协议头部"></a>TCP协议头部</h3><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/TCP.jpg" class title="TCP">
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>TCP头部字段 </summary>
              <div class="content">
              <details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>16位源端口号 </summary>              <div class="content">              <p>发送方的端口号</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>16位目的端口号 </summary>              <div class="content">              <p>接收方的端口号</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>序列号 </summary>              <div class="content">              <p>在建立连接时由计算机生成的<strong>随机数作为其初始值</strong>,通过<strong>SYN包</strong>传给接收端主机,每发送一次数据,就「累加」一次该「数据字节数」的大小<br><code>用来解决网络包乱序问题</code></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>确认应答号 </summary>              <div class="content">              <p>指下一次<strong>期望</strong>收到的数据的序列号,发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收<br><code>用来解决不丢包的问题</code></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>4位首部长度 </summary>              <div class="content">              <p>标识该TCP头部有多少个<strong>32bit字(4字节)</strong><br><code>因为4位最大能标识15,所以TCP头部最长是60字节,选项最多为40字节,固定头部为20字节,所以最长为60字节</code></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>6位保留 </summary>              <div class="content">              <p>占6位,保留为以后使用,目前应置为0</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>6位标志位 </summary>              <div class="content">              <ol><li>紧急URG:此位置1,表明紧急指针字段有效,他告诉系统此报文中有紧急数据,应该尽快传送</li><li>确认ACK:TCP规定,在建立连接后,所有的传达的报文段都必须把ACK置1</li><li>推送PSH:提示接收端应用程序应该立即从TCP接收缓冲区中读走数据,为接收后续数据腾出空间(如果应用程序不将接收到的数据读走,它们就会一直停留在TCP接收缓冲区中),当我们希望一个请求能在发出后立即就收到对方的响应的时候,就可以将发送报文的PSH置1,这样,接收方在接收到该报文后,不需要等到TCP缓存满了才交付给上层进行处理,而是直接交付到上层</li><li>复位RST:用于复位相应的TCP连接,表示要求对方重新建立连接</li><li>同步SYN:表示请求建立一个连接,置1表示这是一个<strong>连接请求或者连接接收报文</strong></li><li>终止FIN:表示通知对方本端要关闭连接了</li></ol>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>16位窗口大小 </summary>              <div class="content">              <p>是<strong>TCP流量控制的一个手段</strong><br>这里说的窗口,指的是接收通告窗口(Receiver Window,RWND)<br>它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据,这样对方就可以控制发送数据的速度</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>16位检验和 </summary>              <div class="content">              <p>由发送端填充,接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意,这个校验不仅包括TCP头部,也包括数据部分<br><code>这也是TCP可靠传输的一个重要保障</code></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>16位紧急指针 </summary>              <div class="content">              <p>仅在URG&#x3D;1的时候有意义,它指出本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据),即指出了紧急数据的末尾在报文中的位置<br><code>注意:即使窗口位0时也可以发送紧急数据</code></p>              </div>            </details>
              </div>
            </details>

<h3 id="为什么需要TCP协议"><a href="#为什么需要TCP协议" class="headerlink" title="为什么需要TCP协议"></a>为什么需要TCP协议</h3><p>因为<strong>IP层(网络层)<strong>是</strong>不可靠</strong>的,它不能保证<strong>网络包的交付、网络包的按序交付、网络包中的数据完整性</strong>,那么就只能依靠上层来保证了,而TCP就因此而设计出来,所以TCP是一个可靠的协议,它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的</strong></p>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>什么是TCP连接 </summary>
              <div class="content">
              <p><code>用于保证可靠性和流量控制维护的某些状态信息,这些信息的组合,包括Socket、序列号和窗口大小称为连接</code><br>所以我们可以知道,建立一个<strong>TCP连接</strong>是需要客户端与服务器端达成上述三个信息的共识</p><ol><li>Socket:由IP地址和端口号组成</li><li>序列号:用来解决乱序问题</li><li>窗口大小:用于流量控制</li></ol>
              </div>
            </details>
<details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>TCP四元组 </summary>
              <div class="content">
              <ol><li>源端口</li><li>目的端口</li><li>源IP地址</li><li>目的IP地址<br><code>TCP四元组可以唯一确定一个连接</code><br>源地址和目的地址的字段(32位)是在IP头部中,作用是通过<strong>IP协议</strong>发送报文给对方主机<br>源端口和目的端口的字段(16位)是在TCP头部中,作用是告诉<strong>TCP协议</strong>应该把报文发给哪个进程</li></ol><p>所以一个服务器一个端口可以理论上可以监听<code>2^32(客户端IP地址)×2^16(客户端端口)</code>的连接,当然了,这是理论上,而且是IPV4的情况下,原因:</p><ol><li>首先主要是文件描述符限制,<strong>Socket</strong>都是文件,所以首先要通过<strong>ulimit</strong>配置文件描述符的数目</li><li>另一个是内存限制,每个<strong>TCP连接</strong>都要占用一定内存,操作系统是有限的</li></ol>
              </div>
            </details>

<p><strong>TCP</strong>是面向连接的协议,所以使用TCP前必须先建立连接,而建立连接是通过<strong>三次握手而进行的</strong></p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" class title="TCP三次握手">
<p>一开始服务端和客户端都是关闭的(CLOSE状态),<strong>三次握手只能由客户端发起,服务端没办法主动发起连接</strong>,服务端需要<strong>先进入LISTEN状态</strong>,在SOcket中可以利用listen()去主动监听某个端口</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>三次握手详解 </summary>
              <div class="content">
              <ol><li>第一次握手:由客户端率先发起,客户端发送一个<strong>请求连接报文</strong>给客户端<br>该请求报文中,需要将<strong>SYN标志位置为1</strong>,代表请求连接,Seq Num是该报文的序号,我们假设为X,是计算机随机生成的,客户端发送完请求连接报文后,进入<strong>SYN_SENT状态</strong><br><code>这一次握手的请求报文不能包含数据</code></li><li>第二次握手:服务接收到客户端的<strong>请求连接报文</strong>后,会进行第二次握手,此次握手由服务端发送<strong>确认报文</strong><br>该确认报文中,需要将<strong>SYN标志位置为1</strong>,代表连接请求,<strong>ACK位置为1</strong>,表示服务端收到了客户端的请求连接,<strong>确认应答号Ack Num</strong>&#x3D;X+1,代表希望下次收到数据包的序列号,同时这个报文也会随机生产一个序列号,我们假设为Y,服务端接收到请求报文后,就会从<strong>LISTEN状态</strong>转变为<strong>SYN_RCVD状态</strong>,一直持续到第三次握手结束<br><code>这一次的确认报文也不会携带任何数据</code></li><li>第三次握手:客户端接收到服务端发过来的确认报文后,会进入<strong>ESTABLISHED状态</strong>,然后也会发送一个确认报文给服务端<br>确认报文中,需要将<strong>ACK置为1</strong>,这里就不需要将<strong>SYN置为1</strong>了,同时,<strong>Ack Num&#x3D;Y+1</strong><br>服务端接收到客户端发送的确认报文后,状态也从<strong>SYN_RCVD</strong>转变成<strong>ESTABLISHED</strong><br><code>这次握手,客户端可以在报文后面附带其他数据,如果有的话</code></li><li>到此为止,服务端就可以与客户端进行通信啦!</li></ol>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么是三次握手?不能是二次或者四次嘛? </summary>
              <div class="content">
              <p>首先我们知道了什么是TCP连接,那么我们就得知道<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接</strong></p><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>原因一:避免历史连接 </summary>              <div class="content">              <p>首先我们需要知道,网络是错综复杂的,我们没法保证报文的每次传输都能成功被接受到,那么就会出现一个问题,如图<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5.jpg" class title="历史连接"></p><ol><li>假设此时网络拥堵</li><li>当我们先发送了一个序列号为90的请求报文,因为网络拥堵,导致客户端迟迟没有接受到服务端的请求报文,那么此时客户端就会认为请求报文丢失,就会重新发送一个序列号为100的请求报文(这里的序列号都是我们假设的)</li><li>此时序列号为90的<strong>旧请求报文</strong>就会比序列号为100的<strong>新请求报文</strong>先到达服务端,此时服务端就会接收到<strong>旧请求报文</strong>,然后就会返回一个确认序号为<strong>90+1</strong>的确认报文</li><li>客户端接收到服务端发送的确认报文后,由于客户端最后发送的是序列号为100的<strong>新请求报文</strong>,所以客户端希望收到的是确认序列号为<strong>100+1</strong>的确认报文,当客户端收到服务端发来的确认序列号为<strong>90+1</strong>的确认报文后,就会发现这是一个历史连接(序列号过期或超时),那么客户端就会发送<strong>RST置为1</strong>的报文,表示终止这次连接</li></ol><p><code>如果是两次握手,就不能判断当前连接是否是历史连接(因为如果是两次握手,那么第二次握手后会直接进入发送数据状态),三次握手则可以在客户端(发送方)准备发送第三次报文时,客户端因有足够的上下文来判断当前连接是否是历史连接</code><br>所以,TCP三次握手建立连接的最主要原因就是<strong>防止历史连接初始化了连接</strong></p>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>原因二:同步双方初始序列号 </summary>              <div class="content">              <p>TCP 协议的通信双方,都必须维护一个<strong>序列号</strong>,序列号是可靠传输的一个关键因素,它的作用:</p><ol><li>接收方可以去除重复的数据</li><li>接收方可以根据数据包的序列号<strong>按序接收</strong></li><li>可以标识发送出去的数据包中,哪些是已经被对方收到的<br>序列号在<strong>TCP连接</strong>中占据着非常重要的作用,所以当客户端发送携带<strong>初始序列号</strong>的<strong>SYN报文</strong>的时候,需要服务端回一个<strong>ACK应答报文</strong>,表示客户端的<strong>SYN报文</strong>已被服务端成功接收,那当服务端发送<strong>初始序列号</strong>给客户端的时候,依然也要得到客户端的应答回应,这样一来一回,才能<strong>确保双方的初始序列号能被可靠的同步</strong><br><code>这样看来,是需要四次握手(双方发送初始序列号后都需要得到对方的确认)才可以成功连接的,但是我们可以将第二次握手和第三次握手合成一次握手,所以只需要四次握手</code></li></ol><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%BA%8F%E5%88%97%E5%8F%B7.jpg" class title="序列号">两次握手只保证了一方的初始序列号能被对方成功接收,没办法保证双方的初始序列号都能被确认接收              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>原因三:避免资源浪费 </summary>              <div class="content">              <p>如果只有<strong>两次握手</strong>,当客户端的<strong>SYN请求</strong>连接在网络中阻塞,客户端没有接收到<strong>ACK报文</strong>,就会重新发送 <strong>SYN</strong><br><code>由于没有第三次握手,服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号,所以每收到一个 SYN 就只能先主动建立一个连接</code><br>这样就会出现这样一种情况:如果客户端的SYN阻塞了,重复发送多次SYN报文,那么服务器在收到请求后就会<strong>建立多个冗余的无效链接,造成不必要的资源浪费</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" class title="两次握手"></p>              </div>            </details>
              </div>
            </details>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>TCP三次握手中报文丢失会如何处理? </summary>
              <div class="content">
              <details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>第一次握手报文丢失 </summary>              <div class="content">              <p>当第一次握手的报文丢失时,客户端会一直没办法收到服务端的确认请求报文,那么此时客户端就会认为请求报文丢失,那么就会重新组织一个请求报文并发送,同样的,当第一次握手报文阻塞的时候,也会如此<br>具体重传几次,要看<code>tcp_syn_retries</code>内核参数,一般默认是5次<br><code>要注意的是,重传的请求连接报文的seq序列号字段还是之前的seq,不会重新生成</code><br>客户端发送完请求报文后会有一个定时器,定时器结束后没收到确认报文就会认为请求报文丢失了捏,定时器时间大多为3秒,6秒,12秒,这也算TCP协议保证可靠的原因之一:超时重传机制</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>第二次握手报文丢失 </summary>              <div class="content">              <p>第二次握手报文丢失的话,客户端也没办法收到服务端传来的确认报文,那么客户端也<strong>还是会认为是自己的请求报文丢失</strong>,所以就像第一次握手报文丢失一样,会进行重传连接请求<br>但是因为服务端发送的不光是<strong>确认报文</strong>,要知道,这个报文里面<strong>SYN</strong>也置为1了,所以这个报文也表示要建立连接的请求报文,所以当第二次握手报文走丢后,服务端等不到自己请求的回应,所以<strong>也会重传报文</strong></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>第三次握手报文丢失 </summary>              <div class="content">              <p>当客户端接收到第二次握手报文后,客户端就会进入<strong>ESTABLISHED</strong>状态,服务器迟迟得不到ACK报文,但是<strong>ACK报文丢失,ACK报文是不会有重传的(当 ACK 丢失了,就由对方重传对应的报文)</strong><br>所以当到达服务器的超时重传时间后,服务器会认为是第二次握手报文丢失,所以会超时重传第二次报文,当达到最大超时重传次数还没得到ACK报文,服务器就会断开连接</p>              </div>            </details><p><code>每次超时重传的时间是上一次超时重传时间的两倍</code></p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>是不是只要三次握手成功后,客户端就能和服务端成功连接并通信呢? </summary>
              <div class="content">
              <p>并不是这样的,在我们服务端接收到最后一次握手报文的时候,还需要进行一系列的判断来确认是否可以与客户端进行连接<br>在此之前,我们先需要知道,在进行TCP三次握手的时候,Linux会为其维护两个队列:<strong>全连接队列(accept队列)<strong>和</strong>半连接队列(syn队列)</strong></p><div class="tabs" id="tab-first-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#first-tabs-1">半连接队列</a></li><li class="tab"><a class="#first-tabs-2">全连接队列</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-tabs-1"><p>在客户端发起第一次连接的时候,服务端会将其加入<strong>半连接队列</strong>,并且响应客户端的SYN+ACK报文<br><strong>半连接队列</strong>有着最大长度的限制,当超出限制的时候,内核就会丢弃这个连接,并且返回<strong>RST包</strong></p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -natp | grep SYN_RECV | wc -l      //查看半连接队列长度</span><br></pre></td></tr></table></figure></div><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>syn攻击 </summary>              <div class="content">              <p>因为<strong>半连接队列</strong>只要没有收到对应的第三次握手,那么该连接就不会从<strong>半连接队列</strong>中取出,如果有大量的连接没被取出,<strong>半连接队列</strong>很容易达到最大长度<br>假设攻击者短时间伪造不同 IP 地址的 SYN 报文,服务端每接收到一个 SYN 报文,就进入SYN_RCVD 状态,但服务端发送出去的 ACK + SYN 报文,无法得到未知 IP 主机的 ACK 应答,久而久之就会占满服务端的 SYN 接收队列(未连接队列),使得服务器不能为正常用户服务<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/SYN%E6%94%BB%E5%87%BB.jpg" class title="SYN"></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>解决办法 </summary>              <div class="content">              <p>方法一:通过修改 Linux 内核参数,控制<strong>队列大小</strong>和<strong>当队列满时应做什么处理</strong></p><ol><li>当网卡接收数据包的速度大于内核处理的速度时,会有一个队列保存这些数据包<br> 控制该队列的最大值如下参数:net.core.netdev_max_backlog</li><li>SYN_RCVD 状态连接的最大个数:net.ipv4.tcp_max_syn_backlog</li><li>超出处理能时的处理<ol><li>net.ipv4.tcp_abort_on_overflow&#x3D;0:如果全连接队列满了,那么服务端丢弃ack报文</li><li>net.ipv4.tcp_abort_on_overflow&#x3D;1:如果全连接队列满了,那么服务端会向客户端发送RST报文,终止这个握手连接</li></ol></li></ol><p>方法二:启动cookie<br>当应用程序处理速度过慢的时候,会导致<strong>全连接队列</strong>达到最大值,当遭受SYN攻击的时候会导致<strong>半连接队列</strong>达到最大值,此时可以用过设置<code>net.ipv4.tcp_syncookies = 1</code>的方法来开启cookie,开启cookie的流程如图:<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/cookie.jpg" class title="cookie"></p><ol><li>当<strong>SYN 队列</strong>满之后,后续服务器收到 SYN 包,不进入<strong>SYN 队列</strong></li><li>计算出一个<strong>cookie</strong>值,再以<strong>SYN + ACK</strong>中的<strong>序列号</strong>返回客户端,服务端接收到客户端的应答报文,服务器会检查这个<strong>ACK包</strong>的合法性。如果合法,直接放入到<strong>Accept 队列</strong></li><li>最后应用通过调用<strong>accpet()<strong>socket接口,从</strong>Accept 队列</strong>取出的连接</li></ol><p>方法三:减少第二次握手报文重传次数<br>因为我们在收到syn攻击时,服务端会重传syn+ack报文到最大次数,才会断开连接。针对syn攻击的场景,我们可以减少ack+syn报文的重传次数,使处于syn_recv状态的它们更快断开连接<br><code>修改重传次数:/proc/sys/net/ipv4/tcp_synack_retries</code></p>              </div>            </details></div><div class="tab-pane" id="first-tabs-2"><p>等到客户端返回对第二次握手的确认报文时,服务端将该连接从<strong>半连接队列</strong>中取出,并新建一个新的连接,加入到<strong>全连接队列</strong>中,等待进程调用accept()函数的时候,将该连接从**全连接队列取出</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss      //判断全连接队列的情况</span><br></pre></td></tr></table></figure></div></div></div></div><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E8%BF%9E%E6%8E%A5.jpg" class title="连接"><p>所以一个连接进行三次握手后服务端也不一定能和客户端进行网络通信<br>当<strong>全连接队列</strong>已满的时候,若服务端成功接收到第三次握手的ack报文,判断<code>tcp_abort_on_overflow</code>的值</p><ol><li>若tcp_abort_on_overflow&#x3D;0,服务端就会扔掉客户端发送的ack报文,之后一段时间服务端会重新发送第二次握手的报文,如果客户端连接一直排队不上等待超时则会报超时异常</li><li>若tcp_abort_on_overflow&#x3D;1,服务端会发送一个<strong>reset包</strong>给客户端,表示废除这个握手过程和这个连接
              </li></ol></div>
            </details>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -napt   //Linux下查看TCP状态</span><br></pre></td></tr></table></figure></div>

<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当客户端和服务端发送完消息后,需要断开连接,当然有时候会根据HTTP头部来判断是否需要断开连接还是继续保持连接(HTTP那篇文章有讲哦)</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" class title="四次挥手">
<p><code>注意,四次挥手和三次握手不一样的是,四次挥手无论是服务端还是客户端都可以主动发起,而三次握手只能由客户端主动发起!!!</code></p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>四次挥手详解 </summary>
              <div class="content">
              <p><code>这里我们假设由客户端主动发起断开连接请求</code></p><ol><li>第一次握手,客户端组织一个<strong>断开连接请求报文</strong>,发给服务端,然后客户端进入<strong>FIN_WAIT_1状态</strong>,一直到接收到第二次挥手报文为止<br>该请求报文中,需要将<strong>FIN置为1</strong>,假设该报文的序号seq为X<br><code>此时挥手的报文是可以附带数据的,所以可能该报文的确认序号不为0,ACK位也不一定为0</code></li><li>第二次握手,服务端接收到<strong>断开连接请求</strong>报文,组织一个确认报文发给客户端,然后进入<strong>CLOSED_WAIT状态</strong><br>该确认报文中,<strong>ACK置为1</strong>,确认序列号为<strong>X+1</strong>,假设该报文的序号seq为Y<br><code>因为第一次挥手的报文也可能会携带一些请求数据要求,所以该报文也可能会携带回应数据</code><br><code>注意,该确认报文中FIN位并不为1,至于为什么后面会说</code></li><li>客户端接收到服务端发来的确认报文后,进入<strong>FIN_WAIT_2状态</strong></li><li>第三次握手,<code>当服务端将剩余的数据发送完毕后</code>,会发送一个<strong>请求断开连接报文</strong>,然后进入<strong>LAST_ACK状态</strong><br>该报文位<strong>请求断开连接报文</strong>,该报文中,<strong>FIN位置为1</strong>,<strong>ACK为0</strong>,序列号假设位Z</li><li>第四次挥手,客户端接收到服务端发送的<strong>请求断开连接报文</strong>,会发送回去一个确认报文,并进入<strong>TIME_WAIT状态</strong>,并等待<strong>2MSL时间后</strong>,进入<strong>CLOSE</strong>状态,服务端接收到确认报文后也会进入<strong>CLOSE状态</strong></li></ol>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么是四次挥手而不是三次挥手? </summary>
              <div class="content">
              <p>当我们第二次挥手后,有人会问为什么握手阶段,可以第二次握手可以发送请求连接,而挥手阶段不能发送请求断开连接呢?<br>其实,断开连接请求可以在任意时刻发送,如果我们请求断开连接的时候,还有一些数据没有发送完毕呢?所以我们必须等最后一个请求被响应(也就是说服务器将所有请求处理了),才能关闭服务器<br><strong>所以挥手的第二次和第三次是不可以合成一次的</strong>,而且两次挥手间会有一定的时间间隔<br><code>当然了,如果第一次挥手后,对方没有任何数据需要传递的话,我们是可以认为第二次挥手报文可以和第三次挥手合成一次</code></p>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么要等待2MSL时间才关闭呢? </summary>
              <div class="content">
              <p>我们先来了解一下什么是<strong>MSL</strong><br><strong>MSL</strong>:<strong>Maximum Segment Lifetime</strong>,<strong>报文最大生存时间</strong>,它是任何报文在网络上存在的最长时间,超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的,而 IP 头中有一个<strong>TTL</strong>字段,是<strong>IP数据报</strong>可以经过的<strong>最大路由数</strong>,每经过一个处理他的路由器此值就<strong>减1</strong>,当此值为 0 则数据报将被丢弃,同时发送<strong>ICMP报文</strong>通知源主机<br><strong>MSL</strong>与<strong>TTL</strong>的区别:MSL 的单位是时间,而 TTL 是经过路由跳数。<strong>所以 MSL 应该要大于等于 TTL 消耗为 0 的时间,以确保报文已被自然消亡</strong></p><p>那么为要等2MSL时间呢?<br>这是因为,<strong>第四次挥手报文</strong>可能会丢失,如果被动关闭方没有收到断开连接的<strong>最后的ACK报文(第四次挥手报文)</strong>,就会触发超时重发 Fin 报文,另一方接收到 FIN 后,会重发 ACK 给被动关闭方, 一来一去正好 2 个 MSL<br><code>在Linux下,一个MSL大概为30s,所以2MSL位1min,也就是说Linux停留在TIME_WAIT的时间为固定的60s</code></p>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么要有TIME_WAIT状态?TIME_WAIT状态过短会怎么样? </summary>
              <div class="content">
              <p>主要有两个原因</p><div class="tabs" id="tab-second-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#second-tabs-1">原因一:防止旧连接的数据包</a></li><li class="tab"><a class="#second-tabs-2">原因二:保证连接正确关闭</a></li></ul><div class="tab-content"><div class="tab-pane active" id="second-tabs-1"><p>如图<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE.jpg" class title="历史数据"></p><ol><li>如上图黄色框框服务端在关闭连接之前发送的<strong>SEQ &#x3D; 301</strong>报文,被网络延迟了</li><li>这时有相同端口的<strong>TCP 连接被复用后</strong>,被延迟的<strong>SEQ &#x3D; 301</strong>抵达了客户端(图上画错哩),那么客户端是有可能正常接收这个过期的报文,这就会产生数据错乱等严重的问题</li></ol><p><code>所以,TCP 就设计出了这么一个机制,经过 2MSL 这个时间,足以让两个方向上的数据包都被丢弃,使得原来连接的数据包在网络中都自然消失,再出现的数据包一定都是新建立连接所产生的</code></p></div><div class="tab-pane" id="second-tabs-2"><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E6%96%AD%E5%BC%80.jpg" class title="断开">1. 如上图红色框框客户端四次挥手的最后一个ACK报文如果在网络中被丢失了,此时如果客户端**TIME_WAIT**过短或没有,则就直接进入了**CLOSE**状态了,那么服务端则会一直处在**LAST_ACK**状态<ol start="2"><li>当客户端发起建立连接的<strong>SYN请求</strong>报文后,服务端会发送<strong>RST报文</strong>给客户端,连接建立的过程就会被终止</li></ol></div></div></div>所以当TIME_WAIT为2MSL的时候,就会出现以下两种情况:1. 服务端正常收到四次挥手的最后一个**ACK 报文**,则服务端正常关闭连接<ol start="2"><li>服务端没有收到四次挥手的最后一个<strong>ACK 报文</strong>时,则会重发<strong>FIN关闭连接报文</strong>并等待新的<strong>ACK报文</strong></li></ol>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>TIME_WAIT状态过多的危害 </summary>
              <div class="content">
              <p>如果服务器有处于<strong>TIME_WAIT</strong>状态的<strong>TCP</strong>,则说明是由服务器方主动发起的断开请求<br>TIME_WAIT过多的危害:</p><ol><li>对内存资源占用</li><li>对端口资源的占用,一个TCP连接至少消耗一个本地端口,这个危害就很大了,因为端口资源有限,<code>当服务端TIME_WAIT过多而导致占用了所有的端口资源,则会导致无法创建新的连接</code></li></ol>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>CLOSE_WAIT状态过多的原因以及解决办法 </summary>
              <div class="content">
              <p><strong>CLOSE_WAIT</strong>状态是在TCP四次挥手的时候服务器<strong>收到FIN但是没有发送自己的FIN时出现的</strong><br>服务器出现大量<strong>CLOSE_WAIT</strong>状态的原因有两种</p><div class="tabs" id="tab-third-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#third-tabs-1">原因一</a></li><li class="tab"><a class="#third-tabs-2">原因二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="third-tabs-1"><ol><li>服务器内部业务处理占用了过多时间,都没能处理完业务,或者还有数据需要发送</li><li>服务器的业务逻辑有问题,没有执行close()方法</li></ol></div><div class="tab-pane" id="third-tabs-2"><p>服务器的父进程派生出子进程,子进程继承了socket,收到FIN的时候子进程处理但父进程没有处理该信号,导致socket的引用不为0无法回收<br>这里有必要说一下调用close()关闭连接的一些注意点:</p><ol><li>如果有多个进程共享一个socket,close每被调用一次,<strong>计数-1</strong>,直到所有<strong>计数为0</strong>的时候,也就是所有进程都调用了colse,socket才会被释放</li><li>在多进程中如果一个进程调用了shutdown()后,其他进程就无法进行通信</li></ol></div></div></div><p>解决办法:</p><ol><li>停止应用程序</li><li>修改代码BUG</li></ol>
              </div>
            </details>

<h3 id="TCP如何保证可靠"><a href="#TCP如何保证可靠" class="headerlink" title="TCP如何保证可靠"></a>TCP如何保证可靠</h3><p>我们知道,TCP协议是<strong>可靠</strong>,<strong>面向连接</strong>,<strong>字节流</strong>的协议,最主要的是可靠,面向连接上面已经说了,现在来说一下为什么说TCP是可靠的,TCP又是如何保证可靠的呢?</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>校验和 </summary>
              <div class="content">
              <p>校验和是实现数据在传输过程中出错而实现的一种计算方法<br>计算方法:在数据传输的过程中,将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃,补在后面,最后取反,得到校验和<br><strong>发送方</strong>:在发送数据之前计算检验和,并进行校验和的填充<br><strong>接收放</strong>:收到数据后,对数据以同样的方式进行计算,求出校验和,与发送方的进行比对<br>如果不一致,则说明数据在传输过程中出现错误,那么<strong>数据就不一定能传输成功</strong></p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>确认应答和序列号 </summary>
              <div class="content">
              <p>看了上面的连接过程,我们直到三次握手为什么要三次的原因之一就是需要确认双方的初始序列号,而不光是三握手和挥手阶段,<strong>TCP</strong>传输数据的时候,都需要有确认应答机制来确保请求成功被接受<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94.jpg" class title="确认应答"><br>但是网络情况错综复杂,我们没办法保证每个请求都能被接受到,那么当一个请求没办法被服务端接收到的时候,我们就需要重新发送这个请求,这也是TCP实现可靠的方法之一</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>超时重传和快速重传 </summary>
              <div class="content">
              <p>其实这个概念我们在上面讲TCP三次握手和四次挥手的时候就有提及过,当握手&#x2F;挥手过程中一个报文丢失了就会重新发送一个新的报文</p><div class="tabs" id="tab-forth-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#forth-tabs-1">超时重传</a></li><li class="tab"><a class="#forth-tabs-2">快速重传</a></li><li class="tab"><a class="#forth-tabs-3">SACK和D-SACK</a></li></ul><div class="tab-content"><div class="tab-pane active" id="forth-tabs-1"><p>超时重传有两种情况:</p><ol><li>数据包丢失</li><li>确认应答包丢失<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.jpg" class title="超时重传">在上图我们可以看到,无论是**数据包丢失**或者是**确认应答包**丢失,都是当客户端接收不到想要的确认应答包才进行超时重传的<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>超时重传设置的时间 </summary>           <div class="content">           <p>在此之前,我们来了解一下什么叫<strong>RRT</strong><br><strong>RRT</strong>:又叫做往返时间(Round-Trip Time),从下图可以知道,RRT就是一个包的<strong>往返时间</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/RRT.jpg" class title="RRT"></p><p>我们设置超时重传的时间一般叫做RTO(Retransmission Timeout 超时重传时间),我们的RTO不能设置的太长或者太短<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/RTO.jpg" class title="RTO"></p><ol><li>当我们的<strong>RTO</strong>设置地太长(比RRT还长),当我们发送的包或者确认应答包丢失了,我们等待的时间比正常一个包来往的时间还长,也就是如果这个包丢了,我们要等好久才重发,这明显是不利于网络传输的性能的</li><li>当我们的<strong>RTO</strong>设置地太短(比RRT还短),当我们发的包无论有没有丢失都会重发,因为客户端在<strong>RTO</strong>时间内是没办法收到一个来往需要<strong>RRT</strong>的数据包的,所以就会进行重传,会增加网络拥塞,导致更多的超时,更多的超时导致更多的重发</li></ol><p><code>所以我们需要合理地设置RTO</code><br>从上面可知,我们的RTO需要<strong>略大于RRT</strong>但是<strong>不能过大</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%A4%A7%E4%BA%8E.jpg" class title="大于"><br>当然了,因为网络是波动的,所以每个报文地<strong>RRT</strong>不是固定的,所以我们设置的<strong>RTO</strong>也不是固定的,而是<strong>动态变化</strong>的</p>           </div>         </details></li></ol></div><div class="tab-pane" id="forth-tabs-2"><p>快速重传和超时重传有点不太一样,这是因为超时重传会带来一点微妙的问题,比如:</p><ol><li>当一个报文段丢失时,会等待一定的RTO然后才重传,增加了<strong>端到端</strong>的时延</li><li>当一个报文段丢失时,在其等待超时的过程中,可能会出现这种情况:<br>其后的报文段<strong>已经被接收端接收</strong>但却迟迟<strong>得不到确认</strong>(这是因为TCP采用的是累计确认机制),发送端会认为也丢失了,从而引起不必要的重传,既浪费资源也浪费时间</li></ol><details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>TCP累计确认机制 </summary>              <div class="content">              <p>也就是当接收端接收到比期望序列号大的报文时,便会重复发送最近一次确认的报文段的确认信号,我们称之为<strong>冗余ACK(duplicate ACK)</strong><br>举个例子:</p><ol><li>当我们发送序列号为1的报文时,接收端如果成功接收便会返回确认报文,确认报文中的确认序列号(ack)为2,也就是期待下次收到的序列号</li><li>当客户端发送序列号为2的报文丢失了,然后发送了序列号为3的报文,此时接收方收到了序列号为3的报文,但是由于该报文的序列号不是自己期待收到的序列号为2的报文,于是又会发送一个ack为2的报文<br><code>这就是冗余ACK</code></li></ol>              </div>            </details><p>超时重传是在<strong>RTO时间内没有收到期望的确认应答报文</strong>而触发的机制,而快速重传是<strong>客户端连续收到三个相同确认应答包</strong>(其实是4个,不过第一个是正常的ACK确认报文,后面连续三个都是冗余ACK报文)而触发的机制</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.jpg" class title="快速重传"><p>在上图,发送方发出了 1,2,3,4,5 份数据</p><ol><li>第一份<strong>Seq1</strong>先送到了,于是就<strong>Ack</strong>回<strong>2</strong></li><li>结果<strong>Seq2</strong>因为某些原因没收到,<strong>Seq3</strong>到达了,于是还是<strong>Ack</strong>回<strong>2</strong></li><li>后面的<strong>Seq4</strong>和<strong>Seq5</strong>都到了,但还是<strong>Ack</strong>回<strong>2</strong>,因为<strong>Seq2</strong>还是没有收到</li><li>发送端收到了三个<strong>Ack &#x3D; 2</strong>的确认,知道了<strong>Seq2</strong>还没有收到,就会在定时器过期之前,重传丢失的<strong>Seq2</strong></li><li>最后,接收到收到了<strong>Seq2</strong>,此时因为<strong>Seq3,Seq4,Seq5</strong>都收到了,于是<strong>Ack</strong>回<strong>6</strong></li></ol><p>所以,快速重传的工作方式是当收到三个相同的 ACK 报文时,会在<strong>定时器过期之前</strong>,重传丢失的报文段</p><p>快速重传机制只解决了一个问题,就是超时时间的问题,但是它依然面临着另外一个问题。就是重传的时候,是重传之前的一个,还是重传所有的问题</p><p>比如对于上面的例子,是重传<strong>Seq2</strong>呢?还是重传<strong>Seq2、Seq3、Seq4、Seq5</strong>呢?因为发送端并不清楚这连续的三个 <strong>Ack 2</strong>是谁传回来的</p><p>根据 TCP 不同的实现,以上两种情况都是有可能的<br><code>可见,这是一把双刃剑</code></p></div><div class="tab-pane" id="forth-tabs-3"><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>SACK </summary>              <div class="content">              <p>SACK,又叫做(Selective Acknowledgment 选择性确认),也是一种重传方式<br>这种方式需要在 TCP 头部<strong>选项</strong>字段里加一个<strong>SACK</strong>的东西,它可以将<strong>缓存的地图</strong>发送给发送方,这样发送方就可以知道<strong>哪些数据收到了</strong>,<strong>哪些数据</strong>没收到,知道了这些信息,就可以<strong>只重传丢失的数据</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/SACK.jpg" class title="SACK"><br>当发送方<strong>200~299</strong>的报文丢失后,会收到连续四个<strong>ack为200</strong>的确认应答报文,第一个是正常报文,接下来连续三个是<strong>冗余报文</strong>,其中<strong>SACK都是从300</strong>开始,那么发送发就知道是<strong>200~299</strong>的报文丢失了而导致没被接受到<br><code>如果要支持 SACK,必须双方都要支持。在 Linux 下,可以通过 net.ipv4.tcp_sack 参数打开这个功能(Linux 2.4 后默认打开)</code></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>D-SACK </summary>              <div class="content">              <p><strong>D-SACK</strong>是利用SACK来告诉发送方有<strong>哪些数据被重复接收了</strong><br>例如:</p><ol><li><p>ACK确认应答丢失</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/ACK%E4%B8%A2%E5%8C%85.jpg" class title="ACK丢包"> 1. **接收方**发给**发送方**的两个**ACK确认应答**都丢失了,所以发送方超时后,重传第一个数据包(3000 ~ 3499) 2. 于是**接收方**发现数据是重复收到的,于是回了一个**SACK = 3000~3500**,告诉**发送方**3000~3500的数据早已被接收了,**因为 ACK 都到了 4000 了,已经意味着 4000 之前的所有数据都已收到,所以这个 SACK 就代表着 D-SACK** 3. 这样**发送方**就知道了,数据没有丢,是**接收方**的 ACK 确认报文丢了</li><li><p>网络延时</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F.jpg" class title="网络延迟"> 1. 数据包(1000~1499) 被网络延迟了,导致**发送方**没有收到**ACK1500**的确认报文。 2. 而后面报文到达的三个相同的 ACK 确认报文,就触发了快速重传机制,但是在重传后,被延迟的数据包(1000~1499)又到了**接收方** 3. 所以**接收方**回了一个 SACK=1000~1500,因为 ACK 已经到了 3000,所以这个**SACK 是 D-SACK**,表示收到了重复的包 4. 这样发送方就知道快速重传触发的原因不是发出去的包丢了,也不是因为回应的 ACK 包丢了,而是因为网络延迟了<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>D-SACK的好处 </summary>           <div class="content">           <ol><li><strong>发送方</strong>可以知道是哪部分数据丢失,可以只重传这一部分数据</li><li><strong>发送方</strong>可以知道重传的原因,是因为自己的发送报文丢失还是因为请求报文丢失</li><li>可以知道是不是<strong>发送方</strong>的数据包被网络延迟了</li><li>可以知道网络中是不是把<strong>发送方</strong>的数据包给复制了<br><code>在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能(Linux 2.4 后默认打开)</code></li></ol>           </div>         </details></li></ol>              </div>            </details></div></div></div>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>流量控制 </summary>
              <div class="content">
              <p>我们知道,当<strong>接收方</strong>接收到数据后,需要对数据进行处理,<strong>接收方</strong>处理请求的是需要一定时间的,虽然单个请求处理时间会很短,但是当请求数量数以百万计的时候,所耗费的时间是很大的,如果此时<strong>发送方</strong>还继续发送数据的话,<strong>接收方</strong>是处理不过来的(不要啊,”被大大的数据塞满”这种事情,我不接受啊!(艾伦坐)),这样显然是不好的,所以我们需要控制<strong>发送方</strong>的发送速度,而依据就是<strong>接收方</strong>处理速度,这就是TCP可靠的原因之一,<strong>流量控制</strong></p><details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>流量控制的机制:滑动窗口 </summary>              <div class="content">              <p>TCP用来实现<strong>流量控制</strong>的方法就是依靠<strong>滑动窗口</strong>,在此之前,我们还是一样需要知道什么是<strong>窗口</strong>,为什么要有<strong>窗口</strong>,<strong>窗口</strong>的出现是解决了什么问题<br><code>知其然,我们还需要知其所以然</code></p><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>什么是窗口 </summary>              <div class="content">              <p>窗口实际上是<strong>操作系统开辟的一块缓冲区</strong>, <strong>发送方</strong>发送数据就会将数据存放在缓冲区里面,如果<strong>发送方</strong>收到<strong>接收方</strong>回应的确认应答,这个数据就会从缓冲区里面删除,如果没收到就需要保留在缓冲区,TCP头部字段中<strong>有一个16位的窗口大小</strong></p>              </div>            </details><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么引入窗口,解决了什么问题 </summary>              <div class="content">              <p>我们都知道,TCP是运用应答机制来确保数据的传达从而实现TCP的可靠,<strong>每次请求都需要收到确认才会进行下一次的请求</strong><br><code>就好像你和喜欢的人聊天一样,她不回你你就不敢继续往下聊了,因为你喜欢她,你害怕你多说一句她就会觉得你烦,只有等她回你&quot;嗯&quot;,&quot;哈哈&quot;,&quot;对&quot;的时候,你才能继续往下聊,真惨啊~</code><br>但是!你为什么要这样卑微?自卑让你弯下身段,派大星要你站起来!<br>我们要先爱自己,她不理老子,老子照样给你发消息,至于发多少那要看哥对你喜欢的程度以及你能接受多少的程度了</p><p>TCP也是这样认为的,所以它开辟了一个叫做<strong>窗口</strong>的东西,<strong>窗口的大小</strong>就是<strong>无需等待确认应答,而可以继续发送数据的最大值</strong></p><p>假设<strong>窗口大小</strong>为3,也就是说<strong>发送方</strong>可以<strong>连续发送</strong>3个TCP段而不需要等待回应,并且中途若有 ACK 丢失,可以通过<strong>下一个确认应答进行确认</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%AA%97%E5%8F%A3.jpg" class title="窗口"></p>              </div>            </details><p>知道了窗口的概念,现在我们来看看TCP是如何<strong>利用窗口来达到流量控制</strong>的目的</p><p>TCP头部有一个<strong>16位的窗口大小</strong>字段<br><code>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据,而不会导致接收端处理不过来</code><br>所以,通常窗口的大小是由接收方的决定的,<strong>发送方发送的数据大小不能超过接收方的窗口大小</strong>,否则接收方就无法正常接收到数据</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>发送方的滑动窗口 </summary>              <div class="content">              <img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B9.jpg" class title="发送方"><p>如上图所示(实际上不一定是这样的)<br>当我们将<strong>可用窗口</strong>的数据(也就是46~51)全部发送出去后,<strong>可用窗口</strong>的大小就会变为0,表明在没有收到ACK确认前是没办法继续发送数据了<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B91.jpg" class title="发送方1"></p><p>当<strong>发送方</strong>收到之前发送的数据(32~36)的ACK时,<strong>如果发送窗口大小没有变化的话</strong>,整个发送窗口往<strong>右移</strong>5个字节,也就是已经确认收到的字节,那么此时,<strong>52-56</strong>这5个字节也就又变成了<strong>可用窗口</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B92.jpg" class title="发送方2"></p><p>在程序中,TCP是这样表示这<strong>四个部分</strong>的<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B93.jpg" class title="发送方3"></p><ol><li><strong>SND.WND</strong>:表示发送窗口的大小(大小是由接收方指定的)</li><li><strong>SND.UNA</strong>:是一个绝对指针,它指向的是已发送但未收到确认的第一个字节的序列号,也就是<strong>发送窗口</strong>的第一个字节</li><li><strong>SND.NXT</strong>:也是一个绝对指针,它指向未发送但可发送范围的第一个字节的序列号,也就是<strong>可用窗口</strong>的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针,它需要 SND.UNA 指针加上 SND.WND 大小的偏移量,就可以指向 #4 的第一个字节了<br>那么可用窗口大小的计算就可以是:<br><code>可用窗口大小 = SND.WND -(SND.NXT - SND.UNA)</code></li></ol>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>接收方的滑动窗口 </summary>              <div class="content">              <img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E6%8E%A5%E6%94%B6%E6%96%B9.jpg" class title="接收方"><ol><li><strong>RCV.WND</strong>:表示接收窗口的大小,它会通告给发送方</li><li><strong>RCV.NXT</strong>:是一个指针,它指向期望从发送方发送来的下一个数据字节的序列号,也就是 #3 的第一个字节</li><li>指向 #4 的第一个字节是个<strong>相对指针</strong>,它需要<strong>RCV.NXT</strong>指针加上<strong>RCV.WND</strong>大小的偏移量,就可以指向 #4 的第一个字节了</li></ol>              </div>            </details><p><code>接收方的滑动窗口大小和发送方的滑动窗口并不是相等的,而是约等的,是因为传输过程存在延迟</code><br>我们举个栗子来讲一下<strong>TCP利用滑动窗口来做到流量控制的过程</strong></p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>举个栗子 </summary>              <div class="content">              <p>我们依旧假设客户端为发送方,服务器为接收方(因为TCP连接也可以是服务端与服务端的连接,所以这边只是假设)</p><ol><li>双方通过<strong>三次握手</strong>建立连接,在三次握手的过程中,客户端会通过报文中的<strong>窗口大小字段</strong>告知服务端,服务端也会将自己的窗口大小设置成一样的,这边假设为<strong>400</strong>个字节吧</li><li>我们假设客户端有<strong>1000字节</strong>的代发数据,每个TCP包为<strong>100个字节</strong></li><li>因为客户端的窗口为400字节,代表可以<strong>连续发送</strong>400个字节的数据,在这里就是可以连续发送4个TCP包而无需等待应答,此时客户端的<strong>SND.WND&#x3D;400</strong>,<strong>SND.NEXT&#x3D;0</strong>,<strong>SND.UNA&#x3D;0</strong></li><li>因为此时客户端的可用窗口为400,所以可以发送400个字节,每发送一个TCP包,<strong>SND.NEXT</strong>都要+100,所以发送完序列号<strong>1&#96;100</strong>的TCP包后,<strong>SND.NEXT</strong>指向101字节,<strong>SND.UNA</strong>是不变的,因为还没有接收到确认报文</li><li>就这样,当发送方的<strong>可用窗口</strong>变为0的时候,也就是<strong>SND.NEXT</strong>指向401的时候,发送方就不能继续发送数据了</li><li>在服务端的角度来看的话(服务端也有发送窗口,这里我们就先关注接收窗口),<strong>RCV.WND&#x3D;400</strong>,<strong>RCV.NEXT&#x3D;0</strong>,当服务端收到第一个报文,也就是序列号为<strong>1~100</strong>的报文时,<strong>RCV.NEXT&#x3D;101</strong>(下一个期望收到的序列,也就是应答报文的ack),整个接收窗口向后移动100个字节</li><li>发送方接收到客户端发送来的应答报文后,根据ack来确认报文送达,<strong>SND.UNA</strong>往右移动100个字节,此时<strong>可用窗口大小就&#x3D;400-(401-101)&#x3D;100</strong>,相当于发送窗口右移100个字节,这也是为什么说是<strong>滑动窗口</strong></li></ol><p><code>这个栗子里,我们假设接收窗口和发送窗口是不变的,在是我们知道窗口实际上是一块操作系统内存缓冲区,而大小是会被操作系统调整的</code></p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>操作系统如何影响接收窗口和发送窗口? </summary>              <div class="content">              <p>还是看看下面两个例子(客户端作为发送方,服务端作为接收方,发送窗口和接收窗口初始大小为<strong>360</strong>)</p><div class="tabs" id="tab-fifth-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#fifth-tabs-1">栗子一</a></li><li class="tab"><a class="#fifth-tabs-2">栗子二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fifth-tabs-1"><ol><li>客户端作为发送方,服务端作为接收方,发送窗口和接收窗口初始大小为<strong>360</strong></li><li>服务端非常的繁忙,当收到客户端的数据时,应用层不能及时读取数据<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%9C%BA%E6%99%AF1.jpg" class title="场景1"></li><li>客户端发送<strong>140字节</strong>数据后,<strong>可用窗口</strong>变为<strong>220</strong>(360 - 140)</li><li>服务端收到<strong>140字节</strong>数据,但是<strong>服务端非常繁忙</strong>,应用进程只读取了<strong>40个字节</strong>,还有<strong>100字节</strong>占用着缓冲区,于是接收窗口收缩到了<strong>260</strong>(360 - 100),最后发送确认信息时,将<strong>窗口大小</strong>发送给客户端</li><li>客户端收到确认和窗口通告报文后,<strong>发送窗口</strong>减少为<strong>260</strong></li><li>客户端发送 180 字节数据,此时<strong>可用窗口</strong>减少到<strong>80</strong></li><li>服务端收到 180 字节数据,但是<strong>应用程序没有读取任何数据</strong>,这 180 字节直接就<strong>留在了缓冲区</strong>,于是接收窗口收缩到了<strong>80</strong>(260 - 180),并在发送确认信息时,通过窗口大小给客户端</li><li>客户端收到确认和窗口通告报文后,发送窗口减少为 80</li><li>客户端发送 80 字节数据后,<strong>可用窗口</strong>耗尽</li><li>服务端收到 80 字节数据,但是<strong>应用程序依然没有读取任何数据</strong>,这<strong>80字节</strong>留在了缓冲区,于是接收窗口收缩到了<strong>0</strong>,并在发送确认信息时,通过窗口大小给客户端</li><li>客户端收到确认和窗口通告报文后,发送窗口减少为<strong>0</strong><br>可见最后窗口都收缩为 0 了,也就是发生了窗口关闭<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>窗口关闭 </summary>           <div class="content">           <p>窗口关闭指的是:如果窗口大小为<strong>0</strong>时,就会阻止发送方给接收方传递数据,直到窗口变为<strong>非0</strong>为止<br>窗口关闭的潜在危害:<strong>死锁</strong><br>我们假设这样一个情况</p><ol><li><strong>接收端</strong>因为来不及处理数据,所以数据填满了接收窗口(也就是缓冲区),发送确认报文的时候,报文里的窗口大小就为0,<strong>发送端</strong>接收到消息后,将自己的发送窗口也变为0,此时<strong>发送端</strong>将无法发送消息</li><li>等<strong>接收端</strong>处理完数据后,会向对方发送一个<strong>窗口非0</strong>的ACK报文</li><li>这个时候,这个ACK报文在网络中走丢了,那么<strong>发送方</strong>就永远接受不到<strong>接收窗口非0</strong>的这个消息,所以<strong>发送方</strong>的发送窗口就一直为0,一直没办法发送数据了<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD.jpg" class title="窗口关闭"></li></ol><p>解决办法:<br>TCP 为每个连接设有一个持续定时器,<strong>只要 TCP 连接一方收到对方的零窗口通知,就启动持续计时器</strong>,如果<strong>持续计时器超时</strong>,就会发送<strong>窗口探测(Window probe)报文</strong>(这个即使接收窗口为0也可以接收到),而对方在确认这个探测报文时,给出自己现在的接收窗口大小:</p><ol><li>如果接收窗口仍然为 0,那么收到这个报文的一方就会重新启动持续计时器</li><li>如果接收窗口不是 0,那么死锁的局面就可以被打破了<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%AA%97%E5%8F%A3%E6%8E%A2%E6%B5%8B.jpg" class title="窗口探测"></li></ol><p>窗口探查探测的次数一般为 3 此次,每次次大约 30-60 秒(不同的实现可能会不一样)。如果 3 次过后接收窗口还是 0 的话,有的 TCP 实现就会发<strong>RST报文</strong>来中断连接</p>           </div>         </details></li></ol></div><div class="tab-pane" id="fifth-tabs-2"><p>当服务端系统资源非常紧张的时候,操心系统可能会直接减少了接收缓冲区大小,这时应用程序又无法及时读取缓存数据,那么这时候就有严重的事情发生了,会出现数据包丢失的现象</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%9C%BA%E6%99%AF2.jpg" class title="场景2"><ol><li>客户端发送 140 字节的数据,于是<strong>可用窗口</strong>减少到了220</li><li>服务端因为现在非常的繁忙,<strong>操作系统于是就把接收缓存减少了100字节</strong>,又因为应用程序没有读取任何数据,所以140字节留在了缓冲区中,于是<strong>接收窗口</strong>大小从360收缩成了<strong>120</strong>,最后发送确认信息时,通告窗口大小给对方</li><li>假设此时客户端因为还没有收到服务端的通告窗口报文,所以不知道此时接收窗口收缩成了<strong>120</strong>,客户端只会看自己的可用窗口还有<strong>220</strong>,所以客户端就发送了<strong>180字节数据</strong>,于是可用窗口减少到<strong>40</strong></li><li>服务端收到了<strong>180字节数据</strong>时,发现数据大小超过了接收窗口的大小,于是就把数据包丢失了</li><li>此时客户端收到<strong>第2步服务端发送的确认报文和通告窗口报文</strong>,尝试减少发送窗口到 100,把窗口的右端向左收缩了 80,此时<strong>可用窗口的大小</strong>就会出现诡异的负值<br><code>所以,如果发生了先减少缓存,再收缩窗口,就会出现丢包的现象</code><br><strong>为了防止这种情况发生,TCP 规定是不允许同时减少缓存又收缩窗口的,而是采用先收缩窗口,过段时间在减少缓存,这样就可以避免了丢包情况</strong></li></ol></div></div></div>              </div>            </details>              </div>            </details>              </div>            </details>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>拥塞控制 </summary>
              <div class="content">
              <p><strong>拥塞控制</strong>也是TCP实现可靠的重要手段之一,和<strong>流量控制</strong>不同的是,<strong>拥塞避免</strong>是争对网络传输而做出的一系列举措</p><p>网络错综复杂,当网络特别拥挤阻塞的时候,我们会经常出现<strong>数据包丢失、时延</strong>等问题,这样就会要用<strong>超时重传</strong>来解决,但是一重传就会导致网络的负担更重,于是会导致更大的延迟以及更多的丢包,这个情况就会进入恶性循环被不断地放大,这显然是不利于网络传输的</p><p>所以TCP只好牺牲自我,来降低发送量,啊!TCP可真是无私啊~<br>那么,为了在<strong>发送方</strong>调节所发送的数据量,我们需要通过<strong>拥塞窗口</strong>来控制</p><details class="orange" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>拥塞窗口是什么?和发送窗口有什么关系? </summary>              <div class="content">              <p><strong>拥塞窗口cwnd</strong>是发送方维护的一个的<strong>状态变量</strong>,它会根据网络的拥塞程度<strong>动态变化</strong>的</p><p>我们在前面提到过<strong>发送窗口swnd</strong>和<strong>接收窗口rwnd</strong>是<strong>约等于</strong>的关系,那么由于引入了<strong>拥塞窗口</strong>的概念后,此时发送窗口的值是<strong>swnd &#x3D; min(cwnd, rwnd)</strong></p><p>拥塞窗口(cwnd)的变化规则:</p><ol><li>只要网络中没有出现拥塞,<strong>cwnd就会增大</strong></li><li>一旦网络中出现拥塞,<strong>cwnd就会减小</strong></li></ol><p>如何知道网络出现拥塞呢?<br>其实只要<strong>发送方</strong>没有在规定时间内接收到<strong>ACK应答报文</strong>,<strong>也就是发生了超时重传,就会认为网络出现了用拥塞</strong></p>              </div>            </details><details class="orange" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>拥塞控制算法 </summary>              <div class="content">              <ol><li>慢开始(慢启动):当我们的TCP在三次握手建立连接后,首先就是<strong>慢启动</strong>过程,顾名思义,就是一点点慢慢地增加<strong>拥塞窗口</strong>的大小,<code>TCP规定,只要发送方收到一个ACK确认报文,cwnd就加一</code><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>慢启动 </summary>           <div class="content">           <p>我们假设cwnd和swnd一样,一开始初始为1</p><ol><li>发送一个MSS大小的数据,等接收到一个ACK后,cwnd+1(cwnd&#x3D;2),于是下一次就可以发送两个MSS大小的数据了</li><li>发送两个MSS大小的数据,会接收到两个ACK,cwnd+2(cwnd&#x3D;4),下一次就可以发送四个了</li><li>发送四个MSS大小的数据,会接收到四个ACK,cwnd+4(cwnd&#x3D;8),下一次就可以发送八个了<br>…<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E6%85%A2%E5%90%AF%E5%8A%A8.jpg" class title="慢启动"></li></ol>           </div>         </details></li></ol><p>会发现,这一阶段的cwnd是以2为次方的指数增长,学过数学的都知道<strong>指数爆炸</strong>吧,也就是越到后面变化的越夸张,所以我们也不能一直这样下去,需要设定一个<strong>阈值</strong>,当<strong>cwnd小于阈值</strong>的时候,使用<strong>慢启动算法</strong>,等<strong>大于阈值</strong>的时候,就需要用到<strong>拥塞避免</strong>算法<br>2. 拥塞避免:该算法就是为了防止<strong>指数爆炸</strong>的情况,其实也是一个cwnd增加的算法,不过该算法是<strong>线性增加</strong>的</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.jpg" class title="拥塞避免"><p>就这么一直增长着后,网络就会慢慢进入了拥塞的状况了,于是就会出现丢包现象,这时就需要对丢失的数据包进行重传<br><code>当触发了重传机制的时候,就会进入拥塞发生算法</code><br>3. 拥塞发生:</p><div class="tabs" id="tab-sixth-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#sixth-tabs-1">超时重传</a></li><li class="tab"><a class="#sixth-tabs-2">快速恢复</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-tabs-1"><p>当发送方经过一定时间(RTO)也没有收到ACK报文时,也就是<strong>超时</strong>了,就会使用<strong>拥塞发生算法</strong>,我们需要将<strong>原本慢启动的阈值</strong>变成cwnd的一半(cwnd&#x2F;2),然后重新从<strong>慢启动</strong>开始,如下所示:<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A01.jpg" class title="超时重传1"></p></div><div class="tab-pane" id="sixth-tabs-2"><p>使用<strong>超时重传</strong>的话,需要重新从<strong>慢启动</strong>开始,这很让人不甘心,在上面我们说过,如果在<strong>RTO时间</strong>内,接收到连续四个相同的ACK的话,就可以使用<strong>快速重传</strong>,同样的,当我们收到四个相同的ACK时候,我们会选择另一种<strong>拥塞发生</strong>算法:<strong>快速回复</strong><br>TCP认为这种情况不严重,因为大部分没丢,只丢了一小部分,则<strong>阈值</strong>和<strong>cwnd</strong>变化如下:</p><ol><li><strong>cwnd &#x3D; cwnd&#x2F;2 ,也就是设置为原来的一半</strong></li><li><strong>阈值 &#x3D; cwnd</strong></li></ol><p>进入快速恢复算法<br>算法如下:</p><ol><li>拥塞窗口 cwnd &#x3D; 阈值 + 3(3 的意思是确认有 3 个数据包被收到了)</li><li>重传丢失的数据包</li><li>如果再收到重复的 ACK,那么 cwnd 增加 1</li><li>如果收到新数据的 ACK 后,设置 cwnd 为 阈值,接着就进入了拥塞避免算法<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.jpg" class title="快速恢复"></li></ol></div></div></div><p>整个过程如下:</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" class title="拥塞控制">              </div>            </details>
              </div>
            </details>

<h3 id="TCP的拆包和粘包问题"><a href="#TCP的拆包和粘包问题" class="headerlink" title="TCP的拆包和粘包问题"></a>TCP的拆包和粘包问题</h3><p>粘包:因为我们知道TCP是基于<strong>数据流</strong>的协议,发送端为了将多个发给接收端的包,更有效的发给对方,使用了优化方法(<strong>Nagle 算法</strong>),将多次间隔较小且数据量小的数据,合并成一个大的数据块,然后进行封包<br>这样做虽然提高了效率,但是接收端就<strong>难于分辨出完整的数据包</strong>了,因为面向流的通信是<strong>无消息保护边界的</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%B2%98%E5%8C%85.jpg" class title="粘包">

<p>假设客户端发送了两个数据包D1和D2，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p>
<ol>
<li>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，没有粘包和拆包</li>
<li>服务端一次接受到了两个数据包，<strong>D1和D2粘合</strong>在一起，称之为<strong>TCP粘包</strong></li>
<li>服务端分两次读取到了数据包，第一次读取到了<strong>完整的D1包和D2包的部分内容</strong>，第二次读取到了<strong>D2包的剩余内容</strong>，这称之为<strong>TCP拆包</strong></li>
<li>服务端分两次读取到了数据包，第一次读取到了<strong>D1包的部分内容D1_1</strong>，第二次读取到了<strong>D1包的剩余部分内容 D1_2 和完整的 D2 包</strong></li>
</ol>
<details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>导致出现粘包和拆包的原因 </summary>
              <div class="content">
              <ol><li>发送端等待缓冲区满才进行发送，造成粘包</li><li>接收方来不及接收缓冲区内的数据，会将一个数据包拆除几个小的数据包，造成拆包</li><li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li></ol>
              </div>
            </details>
<details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>解决粘包和拆包的办法 </summary>
              <div class="content">
              <ol><li><strong>发送定长包</strong>:如果每个消息的大小都是一样的，如果不够长就通过<strong>补充空格</strong>的方式来使其与其他数据包大小一致，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息</li><li><strong>包头加上包体长度</strong>:包头是定长的 4 个字节，说明了包体的长度。接收方先接收包头长度，依据包头长度来接收包体</li><li>在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界</li><li>使用更加复杂的应用层协议</li></ol>
              </div>
            </details>

<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="什么是UDP"><a href="#什么是UDP" class="headerlink" title="什么是UDP"></a>什么是UDP</h3><p><strong>UDP协议</strong>与<strong>TCP</strong>协议不同在，UDP协议是<strong>无连接</strong>，<strong>尽最大可能交付</strong>，<strong>面向报文</strong>的<strong>不可靠协议</strong></p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>无连接 </summary>
              <div class="content">
              <p>即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延</p>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>尽最大可能交付 </summary>
              <div class="content">
              <p>即不保证可靠交付，因此主机不需要维护复杂的连接状态表</p>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>面向报文 </summary>
              <div class="content">
              <p>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不分拆，而是保留这些报文的边界。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文</p>
              </div>
            </details>

<h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/UDP.jpg" class title="UDP">
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>UDP头部字段 </summary>
              <div class="content">
              <ol><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计</li></ol>
              </div>
            </details>

<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ol>
<li><p>连接</p>
<ol>
<li>TCP 是<strong>面向连接</strong>的传输层协议，传输数据前先要<strong>建立连接</strong></li>
<li>UDP 是<strong>不需要连接</strong>，<strong>即刻</strong>传输数据</li>
</ol>
</li>
<li><p>服务对象</p>
<ol>
<li>TCP 是<strong>一对一</strong>的两点服务，即一条连接只有两个端点</li>
<li>UDP 支持<strong>一对一、一对多、多对多</strong>的交互通信</li>
</ol>
</li>
<li><p>可靠性</p>
<ol>
<li>TCP 是<strong>可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达</strong></li>
<li>UDP 是<strong>尽最大努力交付</strong>，不保证可靠交付数据</li>
</ol>
</li>
<li><p>拥塞控制、流量控制</p>
<ol>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ol>
</li>
<li><p>首部开销</p>
<ol>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小</li>
</ol>
<p> 这也是为什么TCP头部有一个<strong>首部长度</strong>字段而UDP没有的原因，而UDP有<strong>包长度</strong>字段而TCP没有的原因也很简单:</p>
<ol>
<li>TCP数据长度&#x3D;IP总长度–IP首部长度-TCP首部长度(TCP有该字段)<br> <code>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的</code></li>
<li>当然，UDP也可以通过该公式计算，但是!<strong>为了网络设备硬件设计和处理方便，首部长度需要是 4字节的整数倍</strong>,如果去掉了<strong>包长度</strong>，那首部长度就不是4字节的整数倍了</li>
</ol>
</li>
</ol>
<h2 id="TCP和UDP的应用场景"><a href="#TCP和UDP的应用场景" class="headerlink" title="TCP和UDP的应用场景"></a>TCP和UDP的应用场景</h2><ol>
<li>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：<ol>
<li>FTP 文件传输</li>
<li>HTTP &#x2F; HTTPS</li>
</ol>
</li>
<li>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：<ol>
<li>包总量较少的通信，如 DNS 、SNMP 等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ol>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章花了我3天的时间来写，你别说，TCP要记的东西真的好多，不光是因为这个，也因为我最近写笔试写麻了，要不容易熬到周六了，周末还有一个腾讯的海笔，下周周五晚上直接两个笔试，我也只能选一个，大概率选阿里吧，大厂虐我千百遍，我待大厂如初恋捏，即使他们都是海笔，好像赶紧找一个实习啊，一点也不想去学校安排的那个破实习</p>
<p>明天周六啦!新海诚的电影上线啦!我明天要一个人去看!一个人怎么了，也没什么不好的嘛哈哈~<br>晚安，垃圾世界~</p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> 传输层相关协议</li>
        <li><strong>作者:</strong> 这题超纲了</li>
        <li><strong>创建于:</strong> 2023-03-22 17:01:46</li>
        
            <li>
                <strong>更新于:</strong> 2023-06-23 14:47:18
            </li>
        
        <li>
            <strong>链接:</strong> https://qx-gg.github.io/2023/03/22/blog14/
        </li>
        <li>
            <strong>版权声明:</strong> 本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">#计算机网络</a>&nbsp;
                        </li>
                    
                </ul>
            

            <div class="recommended-article">
  <div class="recommended-article-header">
    <i aria-hidden="true"></i><span>推荐阅读</span>
  </div>
  <div class="recommended-article-group"><a class="recommended-article-item" href="/2023/03/16/blog13/" title="应用层相关协议" rel="bookmark">
  <img src="https://Qx-GG.github.io/images/水墨/水墨14.jpg" alt="应用层相关协议">
  <span class="title">应用层相关协议</span>
</a><a class="recommended-article-item" href="/2023/03/29/blog15/" title="IP层(网络层)相关协议" rel="bookmark">
  <img src="https://Qx-GG.github.io/images/水墨/水墨16.jpg" alt="IP层(网络层)相关协议">
  <span class="title">IP层(网络层)相关协议</span>
</a><a class="recommended-article-item" href="/2023/02/24/blog5/" title="浙江宇视科技一面" rel="bookmark">
  <img src="https://Qx-GG.github.io/images/水墨/水墨6.jpg" alt="浙江宇视科技一面">
  <span class="title">浙江宇视科技一面</span>
</a></div>
</div>

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/03/25/day5/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">随笔·广州·一个人看电影咯</span>
                                    <span class="post-nav-item">上一篇</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/03/19/day4/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">随笔·广州·拍毕业证件照和体检而导致没有出去的休息日</span>
                                    <span class="post-nav-item">下一篇</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
                <div class="comment-container">
                    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;评论
    </div>
    

        
            
 
    <div id="waline"></div>
    <script type="module"  data-pjax>
        import { init } from 'https://evan.beee.top/js/waline.mjs';

        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://waline-qin.6eek.net',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
            });
        }

        if ('true') {
            const loadWalineTimeout = setTimeout(() => {
                loadWaline();
                clearTimeout(loadWalineTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadWaline);
        }
        
    </script>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">传输层相关协议</div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%BE%93%E5%B1%82"><span class="nav-text">运输层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="nav-text">TCP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFTCP"><span class="nav-text">什么是TCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%8D%8F%E8%AE%AE%E5%A4%B4%E9%83%A8"><span class="nav-text">TCP协议头部</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81TCP%E5%8D%8F%E8%AE%AE"><span class="nav-text">为什么需要TCP协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E8%BF%9E%E6%8E%A5"><span class="nav-text">TCP连接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="nav-text">三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="nav-text">四次挥手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0"><span class="nav-text">TCP如何保证可靠</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E7%9A%84%E6%8B%86%E5%8C%85%E5%92%8C%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-text">TCP的拆包和粘包问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP%E5%8D%8F%E8%AE%AE"><span class="nav-text">UDP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFUDP"><span class="nav-text">什么是UDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E5%A4%B4%E9%83%A8"><span class="nav-text">UDP头部</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">TCP和UDP的应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-text">结语</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">这题超纲了</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span>
                <br>
            <span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.1.5</a>
        </div>
        
        
        
            <div id="start_div" style="display:none">
                2023/2/23 15:15:11
            </div>
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <div class="customize-info info-item">和我一起去充满橘子味的村庄叭</div>
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
            
                
        
                
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>



<script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/layouts/navbarShrink.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/scrollTopBottom.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/lightDarkSwitch.js"></script>


    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/localSearch.js"></script>



    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/codeBlock.js"></script>



    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/layouts/lazyload.js"></script>



    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/runtime.js"></script>
    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/libs/odometer.min.js"></script>
    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/assets/odometer-theme-minimal.css">



  <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/libs/Typed.min.js"></script>
  <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/plugins/typed.js"></script>





    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/libs/minimasonry.min.js"></script>
    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/plugins/masonry.js"></script>


<div class="post-scripts pjax">
    
        <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/tocToggle.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/libs/anime.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/layouts/toc.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/plugins/tabs.js"></script>
    
</div>


    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
