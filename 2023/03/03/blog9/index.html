<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="这题超纲了">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    
        
            <link rel="preconnect" href="https://npm.elemecdn.com" crossorigin>
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/03/03/blog9/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
        <meta name="description" content="五花马、千金裘,呼儿将出换美酒,与尔同销万古愁。">
<meta property="og:type" content="article">
<meta property="og:title" content="CPU是如何执行程序的呢？CPU又是如何调度任务的呢？一些关于CPU的知识总结">
<meta property="og:url" content="http://example.com/2023/03/03/blog9/index.html">
<meta property="og:site_name">
<meta property="og:description" content="五花马、千金裘,呼儿将出换美酒,与尔同销万古愁。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E5%8C%BA%E5%9F%9F.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E5%AD%98%E5%82%A8%E5%99%A8.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/1.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/2.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/3.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E5%86%99%E7%9B%B4%E8%BE%BE.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E5%86%99%E5%9B%9E.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/MESI.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/MESI1.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E4%BC%AA%E5%85%B1%E4%BA%AB.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E7%BB%93%E6%9E%84%E4%BD%93.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E7%BB%93%E6%9E%84%E4%BD%931.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E8%B0%83%E5%BA%A6%E7%B1%BB.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97.jpg">
<meta property="og:image" content="http://example.com/2023/03/03/blog9/%E4%BC%98%E5%85%88%E7%BA%A7.jpg">
<meta property="article:published_time" content="2023-03-03T03:22:22.000Z">
<meta property="article:modified_time" content="2023-06-23T06:38:34.082Z">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/03/03/blog9/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC.jpg">
    
    
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id="></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', '');
        </script>
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/%E6%B4%BE1.jpg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/%E6%B4%BE1.jpg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/%E6%B4%BE1.jpg">
    <!--- Page Info-->
    
    <title>
        
            CPU是如何执行程序的呢？CPU又是如何调度任务的呢？一些关于CPU的知识总结 -
        
        这题超纲了的BLOG
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/assets/fonts.css">
    <!--- Font Part-->
    
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    
    
        <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    
    
        <link href="https://fonts.googleapis.com/css2?family=Farsan&display=swap" rel="stylesheet">
    

    <!--- Inject Part-->
    
        
            
    
            
    
    <script id="hexo-configurations">
    let Global = window.Global || {};
    Global.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    Global.theme_config = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":true,"link_icon":true},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":["铜皮","草根","柳筋","骨气","铸庐","洞府境","观海境","龙门境","金丹境","元婴境","玉璞境","仙人境","飞升境","十四境","十五境"]},"code_block":{"copy":true,"style":"mac","font":{"enable":true,"family":null,"url":"https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap"}},"toc":{"enable":true,"max_depth":5,"number":false,"expand":true,"init_open":true},"copyright":true,"lazyload":true,"recommendation":{"enable":true,"title":"推荐阅读","limit":3,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#005080","secondary":null},"global":{"fonts":{"chinese":{"enable":true,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"english":{"enable":true,"family":"Farsan","url":"https://fonts.googleapis.com/css2?family=Farsan&display=swap"}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":false,"scale":true},"scroll_progress":{"bar":true,"percentage":true},"busuanzi_counter":{"enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"pjax":true,"open_graph":true,"google_analytics":{"enable":true,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/水墨/水墨.jpg","dark":"/images/水墨/水墨1.jpg"},"title":"~欢迎来到“派大星”的博客~","subtitle":{"text":["言念君子,温其如玉","我见青山多妩媚,料青山见我应如是","有些人心如花木,皆向阳而生","遇事不决,可问春风。春风不语,即随本心","人生当苦无妨,良人当归即好"],"hitokoto":{"enable":true,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#000000","dark":"#FAFFFE"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":true,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"social_links":{"enable":"enable","links":{"github":"https://github.com/Qx-GG","instagram":null,"zhihu":"https://www.zhihu.com/people/bu-shang-530bu-gai-ming","twitter":null,"email":null,"weixin":"/images/微信.jpg","bilibili":"https://space.bilibili.com/38628118?spm_id_from=333.1007.0.0"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null}]},"mermaid":{"enable":false,"version":"9.3.0"}},"version":"2.1.5","navbar":{"auto_hide":false,"color":{"left":"#FAFFFE","right":"#FAFFFE","transparency":35},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-chart-bar"},"Links":{"path":"/links","icon":"fa-regular fa-link"},"About":{"icon":"fa-regular fa-user","submenus":{"Me":"/about","Github":"https://github.com/Qx-GG","Bilibili":"https://space.bilibili.com/38628118?spm_id_from=333.1007.0.0"}},"WorMhole":{"path":"https://foreverblog.cn/go.html","icon":"fa-regular fa-planet-ringed"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"言念君子,温其如玉","links":{"PYQ":{"path":"/shuoshuo","icon":"fa-regular fa-messages"},"Photo":{"path":"/masonry","icon":"fa-regular fa-photo-film"}}},"article_date_format":"auto","categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}}};
    Global.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    Global.data_config = {"masonry":true};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/fontawesome/regular.min.css">
    
    
    
        <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/fontawesome/duotone.min.css">
    
    
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="null" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="main-content-container">

        <div class="main-content-header">
            <header class="navbar-container">
    
    <div class="navbar-content">
        <div class="left">
            
                <a class="logo-image" href="/">
                    <img src="/images/%E6%B4%BE1.jpg">
                </a>
            
            <a class="logo-title" href="/">
                
                这题超纲了的BLOG
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        首页
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/archives"  >
                                    
                                        
                                            <i class="fa-regular fa-archive"></i>
                                        
                                        归档
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/tags"  >
                                    
                                        
                                            <i class="fa-regular fa-chart-bar"></i>
                                        
                                        标签
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/links"  >
                                    
                                        
                                            <i class="fa-regular fa-link"></i>
                                        
                                        链接
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown" 
                                    href="#" onClick="return false;">
                                    
                                        
                                            <i class="fa-regular fa-user"></i>
                                        
                                        关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                                    
                                </a>
                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                    
                                        <li>
                                        <a href="/about">ME
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://github.com/Qx-GG">GITHUB
                                        </a>
                                        </li>
                                    
                                        <li>
                                        <a target="_blank" rel="noopener" href="https://space.bilibili.com/38628118?spm_id_from=333.1007.0.0">BILIBILI
                                        </a>
                                        </li>
                                    
                                    </ul>
                                
                            </li>
                    
                        
                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="" 
                                    target="_blank" rel="noopener" href="https://foreverblog.cn/go.html"  >
                                    
                                        
                                            <i class="fa-regular fa-planet-ringed"></i>
                                        
                                        WORMHOLE
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i></div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="navbar-drawer">
        <ul class="drawer-navbar-list">
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                首页
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/archives"  >
                             
                                
                                    <i class="fa-regular fa-archive"></i>
                                
                                归档
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/tags"  >
                             
                                
                                    <i class="fa-regular fa-chart-bar"></i>
                                
                                标签
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        href="/links"  >
                             
                                
                                    <i class="fa-regular fa-link"></i>
                                
                                链接
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="has-dropdown" 
                        href="#" onClick="return false;">
                            
                                
                                    <i class="fa-regular fa-user"></i>
                                
                                关于&nbsp;<i class="fa-solid fa-chevron-down"></i>
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                              
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" href="/about">ME</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://github.com/Qx-GG">GITHUB</a>
                            </li>
                        
                            <li class="dropdown-item flex-center">
                                <a class="dropdown-item" target="_blank" rel="noopener" href="https://space.bilibili.com/38628118?spm_id_from=333.1007.0.0">BILIBILI</a>
                            </li>
                        
                    
            
                
                    <li class="drawer-navbar-item flex-center">
                        <a class="" 
                        target="_blank" rel="noopener" href="https://foreverblog.cn/go.html"  >
                             
                                
                                    <i class="fa-regular fa-planet-ringed"></i>
                                
                                WORMHOLE
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="main-content-body">

            

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
                      
                <div class="article-title">
                    <img src="https://Qx-GG.github.io/images/水墨/水墨10.jpg" alt="CPU是如何执行程序的呢？CPU又是如何调度任务的呢？一些关于CPU的知识总结" />
                    <h1 class="article-title-cover">CPU是如何执行程序的呢？CPU又是如何调度任务的呢？一些关于CPU的知识总结</h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/%E6%B4%BE%E5%A4%A7%E6%98%9F.png">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">这题超纲了</span>
                            
                                <span class="author-label">柳筋</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2023-03-03 11:22:22</span>
        <span class="mobile">2023-03-03 11:22</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2023-06-23 14:38:34</span>
            <span class="mobile">2023-06-23 14:38</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>14.3k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>50 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1974443814&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>欲速则不达，鼠鼠决定一星期写3篇文章就够了，其中一篇是拿来记录一下日常生活的，所以说只有两篇是拿来写一些几天内学习到的知识点，同时也可以更好地将学到的知识点串起来，所以就开始今天的主题叭，关于CPU的一些知识~</p>
<p>在去学习CPU前，我们先需要知道什么是<strong>冯诺依曼模型</strong></p>
<h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><p>在 1945 年冯诺依曼和其他计算机科学家们提出了计算机具体实现的报告，其遵循了图灵机的设计，而且还提出用电子元件构造计算机，并约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是<code>中央处理器(CPU)</code>、<code>内存</code>、<code>输入设备</code>、<code>输出设备</code>、<code>总线</code></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC.jpg" class title="冯诺依曼">

<h3 id="中央处理器-CPU"><a href="#中央处理器-CPU" class="headerlink" title="中央处理器(CPU)"></a>中央处理器(CPU)</h3><p>中央处理器，也就是我们常说的CPU，是一台计算机的运算核心和控制核心。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU由运算器、控制器、寄存器、高速缓存及实现它们之间联系的数据、控制及状态的总线构成</p>
<h4 id="32位CPU和64位CPU的差别"><a href="#32位CPU和64位CPU的差别" class="headerlink" title="32位CPU和64位CPU的差别"></a>32位CPU和64位CPU的差别</h4><p>32位CPU和64位CPU最主要的差别在于CPU一次能计算的字节数是多少</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>CPU一次能计算的字节数是多少 </summary>
              <div class="content">
              <ol><li>32位CPU一次性能计算的字节数为4个字节</li><li>64位CPU一次性能计算的字节数位8个字节<br>(一个字节位8个比特，也就是8位)</li></ol>
              </div>
            </details>

<p>我们说的CPU的32位和64位，一般指的是CPU的<strong>位宽</strong></p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么要这样设计CPU呢 </summary>
              <div class="content">
              <p>之所以要这样设计CPU，是为了一次性能够计算更多的数据。</p><ol><li>假设有一个位宽为8的CPU(也就是8位的CPU)，那么这个CPU一次能处理的最大整数就是<code>(2^7+2^6+...+1)=255</code></li><li>此时我想要计算1000×500;由于CPU最多只能处理255以内的整数，所以此时就会分为好几次去计算1000×500;这样会很浪费CPU的时间，因为我们知道一个程序里不可能就一条指令，所以为了提高CPU的效率，科学家就将CPU分为32位和64位</li><li>32位的CPU可以计算的最大整数为<strong>4294967295</strong></li></ol>
              </div>
            </details>

<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>64位CPU相比于32位CPU的优势在哪里?64位CPU的性能一定比32位CPU的性能好嘛 </summary>
              <div class="content">
              <ol><li>上面我们知道64位的CPU能够比32位CPU多计算4个字节的数据，当我们计算超过32位的数据时，32位CPU就需要分步骤进行，而64位CPU不需要</li><li>64位CPU可以寻址更大的内存空间，32位CPU 大的寻址地址是<strong>4G</strong>，即使你加了<strong>8G</strong>大小的内存，也还是只能寻址到<strong>4G</strong>，而64位CPU最大寻址地址是<strong>2^64</strong>，远超于32位CPU最大寻址地址的<strong>2^32</strong></li><li>由于我们大部分程序不需要计算超过32位的数据，所以其实64位CPU的优势没办法体现出来，所以和32位CPU的性能差不太多</li></ol>
              </div>
            </details>
<h4 id="CPU内部的组件"><a href="#CPU内部的组件" class="headerlink" title="CPU内部的组件"></a>CPU内部的组件</h4><p>我们把CPU想象成一个工厂，那么一个核心(算术逻辑单元)就是一个车间，一个车间同一时间只能进行一个任务(进程)，只有执行完了当前任务(进程),车间才能去执行其他任务，因为CPU处理任务的速度很快，快到我们人类无法感知，所以就会出现一种错觉，<strong>同一时间在执行很多进程</strong>，这也就是所谓的<strong>并发</strong></p>
<p>我们知道，一个工厂里肯定不止一个车间的，所以说在现代的计算机里，大部分都是多核的，也就是说CPU可以在同一时间将不同的任务交给不同的核心进行处理，这就是<strong>并行</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg" class title="并发与并行">

<p>CPU由<strong>运算器</strong>、<strong>寄存器</strong>和<strong>控制器</strong>组成</p>
<h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><p>在刚刚的比喻中，我们知道一个核心就是一个车间，车间里很定需要工人，<strong>运算器</strong>在这个车间里面就扮演这个角色，当有数据给他并告诉他要执行什么运算的时候，就由<strong>运算器</strong>进行运算并将结果给其他人，<strong>运算器</strong>只负责运算</p>
<h5 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h5><p>那么总得有人把东西交给普通工人吧，并且把处理好的东西拿走，那么<strong>寄存器</strong>就实现了这个功能，<strong>寄存器</strong>就是负责传递信息(数据)或者搬运信息(数据)，主要作用是存储计算时的数据，需要时可以直接从<strong>寄存器</strong>中获取，<strong>寄存器也分很多种，不同的寄存器实现不同的功能</strong></p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>常见的寄存器种类 </summary>
              <div class="content">
              <ol><li>通用寄存器:用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</li><li>程序计数器:用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。</li><li>指令寄存器:用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。</li></ol>
              </div>
            </details>

<h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>在一个工厂里，总得有人来控制整个工厂的运行，不能群龙无首啊，此时<strong>控制器</strong>就出现了，它的主要功能就是根据调度核心里的其他组件</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>我们的程序和数据都是存储在内存，存储的区域是线性的。</p>
<p>数据存储的单位是一个二进制位（bit），即 0 或 1。最小的存储单位是字节（byte），1 字节等于 8 位。</p>
<p>内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。</p>
<p>这里提一嘴，内存属于计算机中的<strong>存储设备</strong>，同样属于<strong>存储设备</strong>的还有我们熟知的<strong>硬盘</strong>，而<strong>硬盘</strong>又分为<strong>固态硬盘</strong>和<strong>机械硬盘</strong>，这里先不说这么多，先往后看叭</p>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是用于<strong>CPU</strong>和<strong>内存</strong>以及其他设备之间的通信</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>3种总线 </summary>
              <div class="content">
              <ol><li>地址总线，用于指定 CPU 将要操作的内存地址</li><li>数据总线，用于读写内存的数据</li><li>控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线</li></ol>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>当 CPU 要读写内存数据的时候，一般需要通过两个总线 </summary>
              <div class="content">
              <ol><li>首先要通过<strong>地址总线</strong>来指定内存的地址</li><li>再通过<strong>数据总线</strong>来传输数据；</li></ol>
              </div>
            </details>

<h3 id="输入、输出设备"><a href="#输入、输出设备" class="headerlink" title="输入、输出设备"></a>输入、输出设备</h3><p>输入设备(鼠标、键盘、摄像头等等)向计算机输入数据，计算机经过计算后，把数据输出给输出设备(屏幕)。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</p>
<h3 id="CPU位宽和线路位宽"><a href="#CPU位宽和线路位宽" class="headerlink" title="CPU位宽和线路位宽"></a>CPU位宽和线路位宽</h3><p>我们知道，64位CPU和32位CPU其实说的是CPU的位宽，但是我们在去了解CPU是如何执行一个程序前，我们得先知道，数据在计算机是如何传输的呢？</p>
<h4 id="线路位宽"><a href="#线路位宽" class="headerlink" title="线路位宽"></a>线路位宽</h4><ol>
<li><p>其实计算机无论怎么样都是由一堆硬件组装起来的，所以想要传递数据肯定只能依靠这些硬件，也就是依靠一些线路来传输的，学过数字信号处理的同学应该都知道利用高电平来表示1，低电平来表示0，通过不同的组合，可以表示成不同的二进制数叭，所以其实我们的数据在线路中也是这样传递的，通过操控电压，高电压代表<strong>1</strong>，低电压代表<strong>0</strong></p>
</li>
<li><p>我们想要传递<strong>数字5</strong>，转化为二进制也就是<strong>101</strong>，由于一条电线(一条线路)同一时间只能传递一个电流，来表示一种状态，所以<strong>101</strong>想要用一条线路来传递的话，我们就需要传递3次，当数字更大的时候，传递的次数也就更多了，这样显然是不高效的，所以我们需要增加线路来传输数据，就用<strong>101</strong>来说，如果又3条或者3条以上的线路的话，那么只需要一次就可以完成数据的传输。</p>
</li>
<li><p>上面那种只能一位一位来传输数据的情况，我们称为<strong>串行</strong>传输，下一个bit必须等待上一个bit传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以<strong>并行</strong>传输。</p>
</li>
<li><p><strong>线路的位宽简单来讲就是用来传递数据的线路的数量</strong>，为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。</p>
</li>
<li><p>CPU想要操作一些地址空间就需要通过地址总线，如果只有一条的话，每次访问都只能操作2个地址空间(0或者1);如果CPU想要访问4G的地址空间的话，就需要32条地址总线，因为2^32&#x3D;4G，也就是说线路位宽为32</p>
</li>
</ol>
<h4 id="CPU位宽"><a href="#CPU位宽" class="headerlink" title="CPU位宽"></a>CPU位宽</h4><ol>
<li><p>CPU的位宽最好不要小于线路的位宽，比如<strong>32位CPU</strong>控制<strong>40位宽</strong>的地址总线和数据总线的话，工作起来就很麻烦，因为<strong>40位宽</strong>的总线能传输的最大数为<strong>2^40</strong>，远远大于<strong>32位CPU</strong>所能处理的最大整数<strong>2^32</strong>,这样CPU可能就需要分步骤来处理传输的数据，所以<strong>32位CPU</strong>最好和<strong>32位宽</strong>的线路搭配，因为<strong>32位CPU</strong>一次最多只能操作<strong>32位宽</strong>的地址总线和数据总线。</p>
</li>
<li><p>如果用<strong>32位CPU</strong>去加和两个<strong>64</strong>位大小的数字，就需要把这2个<strong>64位的数字</strong>分成2个<strong>低位32位数字</strong>和2个<strong>高位32位数字</strong>来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。</p>
</li>
<li><p>对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，并且 64 位 CPU 内部的逻辑运算单元也支持 64 位数字的计算。</p>
</li>
<li><p>由于我们大部分程序不需要计算超过32位的数据，所以其实64位CPU的优势没办法体现出来，所以和32位CPU的性能差不太多</p>
</li>
<li><p>32 位 CPU 最大只能操作 4GB 内存，就算你装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 2^64</p>
</li>
</ol>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？ </summary>
              <div class="content">
              <p>64位和32位软件，实际上代表指令是64位还是32位的:</p><ol><li>如果 32 位指令在 64 位机器上(64位CPU)执行，需要一套兼容机制，就可以做到兼容运行了。但是如果 64 位指令在 32 位机器(32位CPU)上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令</li><li>操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上</li></ol><p>总之，硬件的 64 位和 32 位指的是 CPU 的位宽，软件的 64 位和 32 位指的是指令的位宽。</p>
              </div>
            </details>

<p><strong>了解完这些，我们才算简单的了解了计算机的组成，接下来我们要知道CPU是如何执行一个程序的</strong></p>
<h2 id="程序执行的基本过程"><a href="#程序执行的基本过程" class="headerlink" title="程序执行的基本过程"></a>程序执行的基本过程</h2><p><strong>程序其实是一条又一条的指令</strong>，所以程序的执行其实就是把每一条指令一步一步地执行起来，而负责执行指令的就是CPU了</p>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>CPU执行程序的基本过程 </summary>
              <div class="content">
              <ol><li>CPU读取<strong>程序计数器</strong>的值，我们知道<strong>程序计数器</strong>的值为指令的内存地址</li><li>CPU通过<strong>控制单元</strong>操控<strong>地址总线</strong>去访问CPU从<strong>程序计数器</strong>读取到的值，然后通知内存设备准备好数据</li><li>内存设备准备好数据后通过<strong>数据总线</strong>将指令数据传到CPU中，期间CPU会通过<strong>Catch Line</strong>来保存数据(这部分后面会详细讲解)，这样等以后CPU还想访问该数据的时候就无需再去内存中获取了</li><li>CPU将传递来的指令数据保存在<strong>指令寄存器</strong>中</li><li>CPU分析<strong>指令寄存器</strong>的指令，确定其指令的类型和参数，如果是<strong>计算类</strong>的指令，就将指令交给<strong>逻辑运算单元</strong>处理;如果是<strong>存储类型</strong>的指令，就交给<strong>控制单元</strong>处理</li><li>CPU执行完指令后，<strong>程序计数器</strong>的值自动增加，表示指向下一条指令</li></ol><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>自增的大小 </summary>              <div class="content">              <p><strong>程序计数器</strong>自增的大小是由CPU的位宽决定的，例如<strong>32为CPU</strong>，指令是4个字节，需要4个内存地址存放，因此<strong>程序计数器</strong>的值会自增<strong>4</strong></p>              </div>            </details> <details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>简单总结 </summary>              <div class="content">              <p>一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令</p><p>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <strong>CPU 的指令周期</strong></p>              </div>            </details> 
              </div>
            </details>

<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>举个栗子(a=1+2) </summary>
              <div class="content">
              <p>我们知道一个程序想要运行，需要经过4个过程:预处理——&gt;编译——&gt;汇编——&gt;链接</p><p>CPU 是不认识<strong>a &#x3D; 1 + 2</strong>这个字符串，这些字符串只是方便我们程序员认识，要想这段程序能跑起来，还需要把整个程序翻译成<strong>汇编语言</strong>的程序，这个过程称为编译成汇编代码。</p><p>针对汇编代码，我们还需要用汇编器翻译成机器码，这些机器码由 0 和 1 组成的机器语言，这一条条机器码，就是一条条的<strong>计算机指令</strong>，这个才是 CPU 能够真正认识的东西。</p><p>那么看看在32位CPU的环境下，(a&#x3D;1+2)是如何执行的叭</p><ol><li><p>在程序<strong>编译</strong>这个过程中，编译器发现<strong>1</strong>和<strong>2</strong>是数据，那么当程序运行的时候，在内存中专门有一块区域来存放这些数据(根据数据的类型来分配，有数据段(.data)、BSS段(.bss)、代码段、栈区、堆区)，如下图所示</p><ol><li>数据1被存放在了地址为0x104的位置</li><li>数据2被存放在了地址为0x100的位置<br><strong>注意，数据和指令是分开区域存放的，存放指令区域的地方称为「正文段」</strong><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%8C%BA%E5%9F%9F.jpg" class title="区域"></li></ol></li><li><p>编译器会把(a&#x3D;1+2)编译成4条指令，存放到正文段中，如上图所示</p><ol><li>0x200 的内容是 load 指令将 0x100 地址中的数据 1 装入到寄存器 R0；</li><li>0x204 的内容是 load 指令将 0x104 地址中的数据 2 装入到寄存器 R1；</li><li>0x208 的内容是 add 指令将寄存器 R0 和 R1 的数据相加，并把结果存放到寄存器 R2；</li><li>0x20c 的内容是 store 指令将寄存器 R2 中的数据存回数据段中的 0x108 地址中，这个地址也就是变量 a 内存中的地址；</li></ol></li><li><p>编译完成后，具体执行程序的时候，程序计数器会被设置为 0x200 地址，然后依次执行这 4 条指令</p></li><li><p>由于是32位CPU，所以一条指令的大小为4个字节，所以每条指令间间隔4个字节，而数据的大小是根据你在程序中指定的变量类型，比如<strong>int</strong>类型的数据则占<strong>4</strong>个字节，<strong>char</strong>类型的数据则占<strong>1</strong>个字节。</p></li></ol>
              </div>
            </details>

<p><strong>以上就是CPU执行程序的过程，关于CPU的秘密还不止这一点，我们有没有想过，既然有了内存，为什么还需要寄存器来保存数据呢?硬盘和内存什么关系？CPU里面除了寄存器外还有没有可以存储数据的东西呢？如果有的话是如何实现的呢？实现的话又会带来什么问题呢？</strong></p>
<p>别急，让我先急!</p>
<p>接下来慢慢看叭</p>
<h2 id="计算机中的存储设备"><a href="#计算机中的存储设备" class="headerlink" title="计算机中的存储设备"></a>计算机中的存储设备</h2><p>鼠鼠毕业后找到工作了肯定要自己组装一台电脑的，那么鼠鼠除了CPU和显卡需要购买，还有显示屏等等，最重要的是，还需要买一些存储设备，不然怎么下载游戏?因为存储设备比较多，有内存和硬盘，硬盘又分为<strong>固态硬盘</strong>和<strong>机械硬盘</strong><br>当断电后，内存条中的数据是会丢失的，而硬盘中的数据并不会丢失，因为硬盘是持久化存储设备，同时也是一个 I&#x2F;O 设备。后面我会写一篇文章就是关于数据是如何读写到硬盘上的，先写完今天再说</p>
<p>但其实 CPU 内部也有存储数据的组件，这个应该比较少人注意到，比如寄存器、**CPU L1&#x2F;L2&#x2F;L3 Cache **也都是属于存储设备，只不过它们能存储的数据非常小，但是它们因为靠近 CPU 核心，所以访问速度都非常快，快过硬盘好几个数量级别。</p>
<h2 id="为何有了内存还需要寄存器"><a href="#为何有了内存还需要寄存器" class="headerlink" title="为何有了内存还需要寄存器?"></a>为何有了内存还需要寄存器?</h2><p>我们知道，CPU是需要从内存从读取数据才能进行处理的，而寄存器也可以存储数据，只是存储空间比较小，但是由于CPU与内存的距离较远，读取速度相对于就在CPU内部的寄存器而言慢了很多，况且寄存器离<strong>控制单元</strong>和<strong>逻辑运算单元</strong>都很近，所以计算速度会快很多。</p>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p>在所有的存储器中，我们按照CPU读取速度的快慢，将所有存储器分成以下级别:</p>
<ol>
<li>速度最快的就是<strong>寄存器</strong>，但是能处理的数据量是最少的</li>
<li>CPU Cache也是在CPU内部结构里的，所以它们的速度也很快，就比寄存器慢一点，但是存储的数据也更多了</li>
<li>内存，前面两个都属于CPU内部的存储器，在CPU外部，速度最快的就是内存了</li>
<li>固态硬盘和机械硬盘是最慢的，相对而言，固态硬盘又比机械硬盘快了一个档次</li>
</ol>
<p><strong>对于存储器而言，它的处理速度越快，耗能也就越多，而且制造材料就更贵，成本就更高，以至于速度快的存储器的存储空间都比较小</strong><br>CPU 里的寄存器和 Cache，是整个计算机存储器中价格最贵的，虽然存储空间很小，但是读写速度是极快的，而相对比较便宜的内存和硬盘，速度肯定比不上 CPU 内部的存储器，但是能弥补存储空间的不足。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%AD%98%E5%82%A8%E5%99%A8.jpg" class title="存储器">

<h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><p>最靠近<strong>控制单元</strong>和<strong>逻辑运算单元</strong>的存储器就是<strong>寄存器</strong>了，它使用的制造材料也很贵但也是最快的，又因为它是在CPU里的，所以它的存储量也很小，并且数量也不是很多</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>寄存器的数量 </summary>
              <div class="content">
              <p>寄存器的数量一般在几十到几百之间，每个寄存器存储一定字节的数据<br>例如:<br>    1. 32位CPU的存储器一般存储4字节的数据<br>    2. 64位CPU的存储器一般存储8字节的数据</p><p>寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写，CPU 时钟周期跟 CPU 主频息息相关，比如 2 GHz 主频的 CPU，那么它的时钟周期就是 1&#x2F;2G，也就是 0.5ns（纳秒）。</p><p>CPU 处理一条指令的时候，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，则会拉长指令的处理周期，从而给用户的感觉，就是电脑「很慢」。</p>
              </div>
            </details>

<h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><p>CPU Cache 用的是一种叫 SRAM（Static Random-Access Memory，静态随机存储器） 的芯片。</p>
<p>SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。</p>
<p>在<strong>SRAM</strong>里面，一个比特的数据，通常需要<strong>6</strong>个晶体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。</p>

<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么要有CPU Cache? </summary>
              <div class="content">
              <p>根据摩尔定律，CPU 的访问速度每 18 个月就会翻倍，相当于每年增长 60% 左右，内存的速度当然也会不断增长，但是增长的速度远小于 CPU，平均每年只增长 7% 左右。于是，CPU 与内存的访问性能的差距不断拉大</p><p>到现在，一次内存访问所需时间是200<del>300多个时钟周期，这意味着 CPU 和内存的访问速度已经相差200</del>300 多倍了</p><p>为了弥补 CPU 与内存两者之间的性能差异，就在 CPU 内部引入了CPU Cache，也称高速缓存</p>
              </div>
            </details>

<p>CPU 的高速缓存(CPU Cache)，通常可以分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二次缓存、三次缓存</p>
<h4 id="L1-Cache"><a href="#L1-Cache" class="headerlink" title="L1 Cache"></a>L1 Cache</h4><p>一级缓存的访问速度几乎和寄存器一样快，通常只需要 2~4 个时钟周期，而大小在几十 KB 到几百 KB 不等。<br><strong>每个CPU核心都有一块属于自己的L1 Cache</strong>，并且L1 Cache通常分为<strong>数据缓存</strong>和<strong>指令缓存</strong><br>可以在Linux下通过以下命令查看L1 Cache的数据缓存和指令缓存的容量大小</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index0/size    //查看数据缓存</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index1/size    //查看指令缓存</span></span><br></pre></td></tr></table></figure></div>

<h4 id="L2-Cache"><a href="#L2-Cache" class="headerlink" title="L2 Cache"></a>L2 Cache</h4><p>二级缓存的速度就比一级缓存慢，因为它距离CPU核心更远，但同时，它的大小也比一级缓存大<br><strong>同样的，二级缓存也是每个CPU都有的</strong><br>可以在Linux下通过以下命令查看L2 Cache的容量大小</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index2/size</span></span><br></pre></td></tr></table></figure></div>
<h4 id="L3-Cache"><a href="#L3-Cache" class="headerlink" title="L3 Cache"></a>L3 Cache</h4><p>L3 Cache与CPU核心又比L2 Cache更远，所以访问速度也比二级缓存更慢，但大小也更大<br><strong>L2 Cache是所有CPU核心共享的，但每个CPU里面也只有一块</strong><br>可以在Linux下通过以下命令查看L3 Cache的容量大小</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index3/size</span> </span><br></pre></td></tr></table></figure></div>

<h3 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h3><p>内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 DRAM （Dynamic Random Access Memory，动态随机存取存储器） 的芯片。</p>
<p>相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。</p>
<p>DRAM 存储一个比特数据，只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。</p>
<p>DRAM的数据访问电路和刷新电路比SRAM更复杂，所以内存的访问速度也更慢，但是大小也会大得多</p>
<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>硬盘又分为固态硬盘(SSD)和机械硬盘(HDD)</p>
<h4 id="固态硬盘-SSD"><a href="#固态硬盘-SSD" class="headerlink" title="固态硬盘(SSD)"></a>固态硬盘(SSD)</h4><p>结构和内存类似，但是硬盘的优点就在于在断电后，数据依旧保存在硬盘上的，意思就是说硬盘上的数据如果不是刻意去破坏，那么就是永久的。内存的读写速度大概是SSD的<strong>10-1000</strong>倍</p>
<h4 id="机械硬盘-HDD"><a href="#机械硬盘-HDD" class="headerlink" title="机械硬盘(HDD)"></a>机械硬盘(HDD)</h4><p>机械硬盘是比较传统的硬盘，它是通过物理读写的方式来访问数据的，因此它的访问速度特别慢，内存的读写速度大概是它的<strong>10w</strong>倍</p>
<p>随着时间的发展，由于固态硬盘的价格越来越便宜，导致机械硬盘几乎没什么人会用了，因此HDD正在被SSD取代</p>
<h2 id="存储器的存储关系"><a href="#存储器的存储关系" class="headerlink" title="存储器的存储关系"></a>存储器的存储关系</h2><p>现代的一台计算机，都用上了 CPU Cahce、内存、到 SSD 或 HDD 硬盘这些存储器设备了。</p>
<p>其中，存储空间越大的存储器设备，其访问速度越慢，所需成本也相对越少。</p>
<p>CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。</p>
<p>比如，CPU Cache 的数据是从内存加载过来的，写回数据的时候也只写回到内存，CPU Cache 不会直接把数据写到硬盘，也不会直接从硬盘加载数据，而是先加载到内存，再从内存加载到 CPU Cache 中。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/1.jpg" class width="1">
<p>所以，每个存储器只和相邻的一层存储器设备打交道，并且存储设备为了追求更快的速度，所需的材料成本必然也是更高，也正因为成本太高，所以 CPU 内部的寄存器、L1\L2\L3 Cache 只好用较小的容量，相反内存、硬盘则可用更大的容量，这就我们今天所说的存储器层次结构。</p>
<p>另外，当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/2.jpg" class width="2">

<p>我们从上面的知识中可以知道，CPU执行程序的时候是需要去从内存中获取数据的，假设CPU里面没有存储器，那么既不是每次获取数据都需要从内存中获取吗，准确的来说，即使是之前已经获取过的数据，想要再次获取就要重新去内存里面查找，这杨效率也太低了吧，所以就有了<strong>寄存器</strong>这个存储器，但是<strong>寄存器</strong>能存储的数据量实在是太小了，所以就有了CPU Cache的出现。</p>
<p>那么，CPU Cache是如何将内存中的数据保存下来的呢?</p>
<h2 id="CPU-Cache-1"><a href="#CPU-Cache-1" class="headerlink" title="CPU Cache"></a>CPU Cache</h2><h3 id="CPU-Cache的读取过程"><a href="#CPU-Cache的读取过程" class="headerlink" title="CPU Cache的读取过程"></a>CPU Cache的读取过程</h3><p>CPU Cache的数据是从<strong>内存</strong>中读取过来的，它是以<strong>一小块一小块</strong>读取数据的，而不是按单个数据读取的，所以在CPU Cache中，这样一小块一小块的数据被称为<strong>Cache Line(缓存块)</strong><br>在Linux下查看Cache Line的大小</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size     //查看L1 Cache一次性能载入的数据的大小，index1就是一次性能载入的指令的大小，index2就是L2 Cache，index3就是L3 Cache</span></span><br></pre></td></tr></table></figure></div>
<p>我们假设在Linux下输入上面的命令得出的结果为<strong>64</strong>，意思就是说L1 Cache一次性能从内存中读取64字节的数据到L1 Cache中的数据缓存，什么意思呢？</p>
<p>假设我们内存中有一个数组<strong>int array[100]</strong>,当我们CPU根据程序指数器的内容去访问array[0]的时候，由于是<strong>int</strong>类型的数组，一个元素占<strong>4个字节</strong>，而我们的CPU Cache一次性能载入的最大数据量为64字节，那么此时就会继续往后遍历到array[15]，那么此时就刚好是64字节，那么**array[0]<del>array[15]<strong>都会被缓存到CPU Cache中，这样等以后CPU还想要获取</strong>array[0]</del>array[15]**中的数据时，就无需再去访问内存，直接访问CPU Cache就可以了，这也是CPU Cache的好处</p>
<p>事实上，CPU 读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache，只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/3.jpg" class width="3">
<p>这样的访问机制，跟我们使用「内存作为硬盘的缓存」的逻辑是一样的，如果内存有缓存的数据，则直接返回，否则要访问龟速一般的硬盘。</p>
<p><strong>那 CPU 怎么知道要访问的内存数据，是否在 Cache 里？如果在的话，如何找到 Cache 对应的数据呢？</strong>我们从最简单、基础的**直接映射 Cache(Direct Mapped Cache)**说起，来看看整个 CPU Cache 的数据结构和访问逻辑。</p>
<h3 id="CPU-Cache的数据结构和访问逻辑"><a href="#CPU-Cache的数据结构和访问逻辑" class="headerlink" title="CPU Cache的数据结构和访问逻辑"></a>CPU Cache的数据结构和访问逻辑</h3><p>我们前面提到了，CPU Cache去内存读取数据时，是<strong>一块一块</strong>地读取的，而读取的大小我们可以通过一些命令获取。<br>那么在内存中，这样一块的数据我们成为<strong>内存块</strong>，读取的时候，我们需要知道的是数据所在的内存块的地址。</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>直接映射 Cache </summary>
              <div class="content">
              <p>所谓<strong>直接映射Cache策略</strong>，就是将内存块始终映射到CPU Cache的某一块Cache Line，映射的方法则采用<strong>取模运算</strong><br>当然了，这样做很容易出现类似<strong>哈希冲突</strong>一样的问题，就是多个<strong>内存块</strong>映射到同一块<strong>Cache Line</strong></p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>解决“哈希冲突” </summary>
              <div class="content">
              <p>为了区别不同的<strong>内存块</strong>，我们在对应的<strong>Cache Line</strong>中加入<strong>组标记(Tag)</strong>,这个组标记会记录当前 CPU Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块<br>除此之外，Cache Line还有两个信息</p><ol><li>从内存加载过来的实际存放数量</li><li><strong>有效位</strong>，这个组标记会记录当前 CPU Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块</li></ol>
              </div>
            </details>

<p>我们知道，我们CPU有时候需要读取的并不是一整个<strong>内存块</strong>，就那上面的数组例子来说，CPU想要获取array[2]的值，<strong>CPU Cache</strong>为了尽可能地将多的数据保存，所以就将<strong>array[0]~array[15]<strong>的数据全部保存在</strong>Cache Line</strong>中，但是CPU只需要<strong>array[2]<strong>的数据，所以我们就需要一个</strong>偏移量</strong>来帮助CPU定位到需要的数据</p>
<p>我们通常称<strong>CPU Cache上的一个数据片段</strong>为<strong>字</strong>，而在CPU Cache上找到CPU所需要的<strong>字</strong>，就需要<strong>偏移量(offset)</strong></p>
<p>因此，一个内存的访问地址，包括<strong>组标记、CPU Line 索引、偏移量</strong>这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由<strong>索引 + 有效位 + 组标记 + 数据块</strong>组成。</p>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>如果内存中的数据已经在 CPU Cahe 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤： </summary>
              <div class="content">
              <ol><li>根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Line 的地址</li><li>找到对应 CPU Line 后，判断 CPU Line 中的有效位，确认 CPU Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行</li><li>对比内存地址中组标记和 CPU Line 中的组标记，确认 CPU Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行</li><li>根据内存地址中偏移量信息，从 CPU Line 的数据块中，读取对应的字。</li></ol>
              </div>
            </details>

<p><code>以上我们说的都是CPU访问内存的数据，但我们一直没说CPU是如何将数据写回到内存中的，现在我们就来说一下</code></p>
<h3 id="CPU写数据操作"><a href="#CPU写数据操作" class="headerlink" title="CPU写数据操作"></a>CPU写数据操作</h3><p>我们知道CPU内部有着CPU Cache，因为离 CPU 核心相当近，它的访问速度是很快的，于是它充当了 CPU 与内存之间的缓存角色。</p>
<p>如果CPU再修改完数据的时候收到指令需要把修改完的数据返回，那么此时CPU就需要把数据先写回<strong>CPU Cache</strong>中，那次是<strong>CPU Cache</strong>中的数据就和<strong>内存</strong>中的数据不一致了，那么我们要如何保持<strong>缓存的一致性</strong>呢？</p>
<p>有两种方法:<strong>写直达</strong>和<strong>写回</strong></p>
<h4 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h4><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%86%99%E7%9B%B4%E8%BE%BE.jpg" class title="写直达">
<ol>
<li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；</li>
<li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</li>
</ol>
<p>顾名思义，<strong>写直达</strong>就是每次都将数据写回<strong>CPU Cache</strong>中和<strong>内存</strong>中，但这样的效率太低了，因为不是每次修改完数据用户都需要读取的，那此时写回内存将没有任何意义。</p>
<h4 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h4><p>为了提高效率，有发明了另外一种方法。<br>在写回机制中，<strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong>，减少了数据写回内存的频率，这样便可以提高系统的性能。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%86%99%E5%9B%9E.jpg" class title="写回">

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>写回的流程 </summary>
              <div class="content">
              <ol><li>当CPU发生<strong>写操作</strong>的时候，先检查<strong>CPU Cache</strong>中对应的<strong>Cache Line</strong>中是否有数据，有的话就将数据更改为<strong>修改后的数据</strong>，并且标记为<strong>脏</strong>，因为此时<strong>Cache Line</strong>中的数据和对应的内存中的数据是不一样的</li><li>当CPU发生<strong>写操作</strong>的时候，发现<strong>修改完的数据</strong>的对应的<strong>Cache Line</strong>中的保存的是<strong>别的内存地址的数据</strong>时<ol><li>如果该数据不是脏的，直接将修改后的数据进行覆盖，并且标记为<strong>脏</strong></li><li>如果该数据是脏的，那么就先将该<strong>Cache Line</strong>上的数据<strong>写回到对应地址的内存上</strong>，然后将<strong>修改后的数据放入Cache Line中</strong>，并且标记为<strong>脏</strong></li></ol></li></ol>
              </div>
            </details>
<p>可以发现<strong>写回</strong>这个方法，在把数据写入到 Cache 的时候，只有在<strong>缓存不命中</strong>，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。</p>
<p>这样的好处是，如果我们大量的操作都能够命中缓存，那么大部分时间里 CPU 都不需要读写内存，自然性能相比写直达会高很多。</p>
<h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>从上面的知识中，我们学到了很多关于CPU Cache的知识，但我们都是在单个CPU核心的情况下考虑问题的，这显然是不够的，因为现在的计算机都是多核的了，那么此时我们就要考虑，如何保证缓存的一致性</p>
<h4 id="什么是缓存一致性"><a href="#什么是缓存一致性" class="headerlink" title="什么是缓存一致性?"></a>什么是缓存一致性?</h4><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>举个栗子 </summary>
              <div class="content">
              <p>我们知道，每个CPU核心都有自己的L1 Cache和L2 Cache，但是L3 Cache是共享的。<br>假设此时有两个CPU核心，分别为CPU1和CPU2，此时它们俩分别运行两个线程，但是都是拿来操作共享资源i的。<br>此时(假设i&#x3D;0):</p><ol><li>CPU1读取i的值，并对i进行+1操作，我们知道CPU是采用<strong>写回</strong>机制的，所以此时CPU1的CPU Cache上i的值变为1，并且被标记为<strong>脏</strong></li><li>CPU2开始读取i的值，按道理来说，CPU2读取到的i值应该是1，但是由于<strong>写回</strong>的机制，CPU1并没有将修改完的i值写入内存中，这也就导致CPU2读取的i值还是0，这也就发生了错误</li></ol>
              </div>
            </details>
<p>这个就是所谓的缓存一致性问题，<strong>1号核心</strong>和<strong>2号核心</strong>的缓存，在这个时候是不一致，从而会导致执行结果的错误。</p>
<h3 id="如何避免缓存一致性问题"><a href="#如何避免缓存一致性问题" class="headerlink" title="如何避免缓存一致性问题"></a>如何避免缓存一致性问题</h3><p>要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这2点:</p>
<ol>
<li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播(Wreite Propagation)</strong></li>
<li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串形化(Transaction Serialization)</strong><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>写传播 </summary>
              <div class="content">
              <p><strong>写传播</strong>就是当某个CPU核心更新了CPU Cache中的数据，就要把该事件<strong>广播</strong>给所有CPU核心，其中最常见的方法就是<strong>总线嗅探(Bus Snooping)</strong></p><p>以前面i的例子来说:<br>当CPU1对i进行了+1操作后，修改了L1 Cache的数据，会通过总线把这个时间广播给其他CPU,然后每个CPU都会<strong>监听</strong>总线上的广播事件，然后检查自己L1 Cache上是否有该数据，如果有的话也将数据更新到自己的L1 Cache</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>事务的串行化 </summary>
              <div class="content">
              <p>还是举个栗子叭:</p><ol><li>假设我们有4个CPU核心，然后有一个数据为i</li><li>CPU1将数据i修改成100</li><li>CPU2将数据i修改成200</li><li>这两个操作都会通过<strong>写传播</strong>，用总线将数据更新的事件传递给其他CPU，在这里就是CPU3和CPU4</li><li>假设CPU3先收到了i修改成100的事件，然后再收到将i修改成200的事件，最后再CPU3的L1 Cache中，i的值为200</li><li>假设CPU4先收到了i修改成200的事件，然后再收到将i修改成100的事件，最后再CPU4的L1 Cache中，i的值为100</li></ol><p>显然，这里就又出现错误了，虽然我们通过<strong>写传播</strong>，将数据更新这个事件传输了，但由于其他CPU执行的顺序不同，也会出现数据不一致的情况，所以我们必须保证CPU3和CPU4都能看到<strong>相同顺序的数据变化</strong>，这就是<strong>数据的串行化</strong></p><p>要实现<strong>数据的串行化</strong>，必须满足以下两点:</p><ol><li>CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；</li><li>要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。</li></ol>
              </div>
            </details></li>
</ol>
<p>上面我们知道可以用<strong>总线嗅探</strong>来实现<strong>写传播</strong>，但是没有办法实现<strong>数据串行化</strong>，再加上虽然<strong>总线嗅探</strong>方法很简单，但是CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，这无疑会加重总线的负载。</p>
<p>那么我们有没有什么方法，既可以减轻总线的负载来满足<strong>写传播</strong>，又能实现<strong>数据的串行化</strong>呢?</p>
<p>当然是有的啦，这是一个协议，基于总线嗅探机制实现了事务串形化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性</p>
<h4 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h4><p>MESI协议其实是4个状态的英文首字母组合起来的:</p>
<ol>
<li>Modified 已修改</li>
<li>Exclusive 独占</li>
<li>Shared 共享</li>
<li>Invalidated 已失效<br>我们可以用这四个状态来标记 Cache Line 四个不同的状态</li>
</ol>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>已修改 </summary>
              <div class="content">
              <p><strong>已修改</strong>状态就是我们前面提到的脏标记，代表该 Cache Line 上的数据已经被更新过，但是还没有写到内存里。而<strong>已失效</strong>状态，表示的是这个 Cache Line 里的数据已经失效了，不可以读取该状态的数据。</p>
              </div>
            </details>

<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>独占 </summary>
              <div class="content">
              <p><strong>独占</strong>状态代表 Cache Line 里的数据是干净的，也就是说，这个时候 Cache Line 里的数据和内存里面的数据是一致性的,同时也代表着只有一个CPU核心拥有该数据，这个时候无论如何修改这个数据，都不需要向其他CPU核心广播，这样就解决了<strong>总线嗅探</strong>导致的总线负载过大的问题</p><p>同样的，如果一个CPU核心处于<strong>独占</strong>状态的时候，有另外一个CPU核心读取了相同的数据，那么此时这两个CPU核心都会从<strong>独占</strong>变成<strong>共享</strong></p>
              </div>
            </details>

<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>共享 </summary>
              <div class="content">
              <p><strong>共享</strong>状态代表 Cache Line 里的数据是干净的，也就是说，这个时候 Cache Line 里的数据和内存里面的数据是一致性的，也代表着不止一个CPU核心拥有这个数据。</p><p>当其中一个CPU核心想要修改<strong>共享</strong>的数据的时候，需要先向其他CPU核心广播消息，让其他CPU核心将<strong>共享</strong>的数据修改成<strong>已失效</strong>状态，然后该CPU核心才能对这个数据进行修改，修改完也要把状态变成<strong>已修改</strong></p>
              </div>
            </details>

<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>已失效 </summary>
              <div class="content">
              <p>代表该Cache Line中的数据已经失效了，不可以读取该状态的数据</p>
              </div>
            </details>

<p>还是举个栗子:</p>
<ol>
<li>CPU1读取内存中的A数据，那么此时A数据就被读取到CPU1的Cache Line中，由于CPU1的Cache Line并没有缓存该数据，所以此时将CPU1的Cache Line标记为<strong>独占</strong></li>
<li>CPU2也读取内存中的A数据，由于CPU1的Cache Line缓存了该数据，但是CPU2的Cache Line并没有缓存A数据，于是CPU2就将A数据缓存到自己的Cache Line中，并且CPU1和CPU2的Cache Line的状态都修改成<strong>共享</strong></li>
<li>此时CPU1想要修改A数据，那么就需要先将<strong>想要修改A数据</strong>的信息传递给其他CPU核心，CPU2接收到该信息，检查自己的Cache Line，发现自己的Cache Line有A数据，于是将自身的Cache Line中的A数据标志为<strong>已失效</strong>状态，然后CPU1就开始修改A数据，修改结束后，将Cache Line的状态修改成<strong>已修改</strong></li>
<li>如果CPU1<strong>继续</strong>修改Cache Line中A数据的值，由于此时的 Cache Line 是<strong>已修改</strong>状态，因此不需要给其他 CPU 核心发送消息，直接更新数据即可。</li>
<li>如果此时CPU3想要读取A数据，那么此时CPU1会先将<strong>已修改</strong>的A数据，写回到内存中，然后CPU3将更新完的A数据缓存到自己的Cache Line中，并且CPU1和CPU3的Cache Line状态都修改成<strong>共享</strong></li>
</ol>
<p>所以，可以发现当 Cache Line 状态是<strong>已修改</strong>或者<strong>独占</strong>状态时，修改更新其数据不需要发送广播给其他 CPU 核心，这在一定程度上减少了总线带宽压力</p>
<p>事实上，整个 MESI 的状态可以用一个有限状态机来表示它的状态流转。还有一点，对于不同状态触发的事件操作，可能是来自本地 CPU 核心发出的广播事件，也可以是来自其他 CPU 核心通过总线发出的广播事件。下图即是 MESI 协议的状态图：</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/MESI.jpg" class title="MESI">

<p>MESI 协议的四种状态之间的流转过程，如下表格，可以更详细的看到每个状态转换的原因：</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/MESI1.jpg" class title="MESI">

<p><code>同样的，当多个CPU核心读取同一块内存块的时候，还是会出现一个问题</code><br>那就是<strong>伪共享</strong>问题</p>
<h3 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h3><p>什么是<strong>伪共享</strong>问题?<br>让我们看看下面这个场景:</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>伪共享场景 </summary>
              <div class="content">
              <p>现在假设有一个双核心的 CPU，这两个 CPU 核心并行运行着两个不同的线程，它们同时从内存中读取两个不同的数据，分别是类型为 long 的变量 A 和 B，这个两个数据的地址在物理内存上是连续的，如果 Cahce Line 的大小是 64 字节，并且变量 A 在 Cahce Line 的开头位置，那么这两个数据是位于同一个 Cache Line 中，又因为 CPU Line 是 CPU 从内存读取数据到 Cache 的单位，所以这两个数据会被同时读入到了两个 CPU 核心中各自 Cache 中。<br><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E4%BC%AA%E5%85%B1%E4%BA%AB.jpg" class title="伪共享"></p><p>然后我们根据上面说的MESI协议来分析一下什么是伪共享:</p><p>假设 CPU1绑定了线程 A，CPU2绑定了线程 B，线程 A 只会读写变量 A，线程 B 只会读写变量 B。</p><ol><li>当我们的CPU核心1想要读取数据A，那么此时因为Cache Line最大能读取64个字节的数据，而一个A数据为long类型，也就是8个字节，所以Cache Line会继续往后读取，也就是说会把数据B也读取到CPU1的Cache Line中，并且检查是否有其他核心拥有该数据，检查完发现没有，于是CPU1在自己的Cache Line中将数据标记为<strong>独占</strong></li><li>当CPU2想要读取数据B时，会发现CPU1的Cache Line已经有了该数据，那么CPU2的Cache Line就会把这一块数据标记为<strong>共享</strong>，同样的，CPU1的Cache Line也会把这一块数据标记为<strong>共享</strong></li><li>CPU1想要修改数据A，此时因为是<strong>共享</strong>状态，所以会先广播，CPU2接收到广播后就把<strong>共享</strong>的数据标记成<strong>已失效</strong>，然后CPU1就对数据A进行修改，然后将这一块数据标记为<strong>已修改</strong></li><li>CPU2想要修改数据B，于是会先读取数据B，因为此时数据B在CPU1的Cache Line中被标记为<strong>已修改</strong>(其实数据B并没有修改，只是因为数据B和已经修改的数据A是同一块内存块的)，所以此时CPU1会先利用<strong>写回</strong>机制，把这一块数据写回内存，然后CPU2读取该内存块，并且进行修改，然后再CPU2的Cache Line中标记为<strong>已修改</strong>，而CPU1中的这一块数据就被标记为<strong>已失效</strong></li><li>当CPU1又想要修改数据A时，会和上面的一样</li></ol><p>那么，当我们一直重复<strong>步骤4</strong>和<strong>步骤5</strong>的时候，一点也没体现出CPU Cache的优势，因为需要一直写回到内存中，就相当于直接从内存中进去读取和写入，虽然变量 A 和 B 之间其实并没有任何的关系，但是因为同时归属于一个 Cache Line ，这个 Cache Line 中的任意数据被修改后，都会相互影响</p><p>因此，这种因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为<strong>伪共享(False Sharing)</strong></p>
              </div>
            </details>

<h4 id="如何解决-避免-伪共享问题"><a href="#如何解决-避免-伪共享问题" class="headerlink" title="如何解决(避免)伪共享问题"></a>如何解决(避免)伪共享问题</h4><p>在 Linux 内核中存在 __cacheline_aligned_in_smp 宏定义，是用于解决伪共享的问题。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifdef CONFIG_SMP</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __cacheline_aligned_in_smp _-cacheline_aligned</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __cacheline_aligned_in_smp</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br></pre></td></tr></table></figure></div>
<p>从上面的宏定义，我们可以看到:</p>
<ol>
<li>如果在多核（MP）系统里，该宏定义是 __cacheline_aligned，也就是 Cache Line 的大小</li>
<li>而如果在单核系统里，该宏定义是空的</li>
</ol>
<p>因此，针对在同一个 Cache Line 中的共享的数据，如果在多核之间竞争比较严重，为了防止伪共享现象的发生，可以采用上面的宏定义使得变量在 Cache Line 里是对齐的</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>举个栗子 </summary>
              <div class="content">
              <p>有这样一个结构体:</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>结构体里的两个成员变量 a 和 b 在物理内存地址上是连续的，于是它们可能会位于同一个 Cache Line 中，如下图<br><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E7%BB%93%E6%9E%84%E4%BD%93.jpg" class title="结构体"></p><p>所以，为了防止前面提到的 Cache 伪共享问题，我们可以使用上面介绍的宏定义，将 b 的地址设置为 Cache Line 对齐地址，如下:</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b __cacheline_aligned_in_smp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>这样 a 和 b 变量就不会在同一个 Cache Line 中了，如下图:<br><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E7%BB%93%E6%9E%84%E4%BD%931.jpg" class title="结构体"></p><p>所以，避免  Cache 伪共享实际上是用空间换时间的思想，浪费一部分 Cache 空间，从而换来性能的提升</p>
              </div>
            </details>

<p><code>我们知道，进程是系统分配资源的基本单位，线程是CPU执行调度的基本单位，我们也知道了进程的调度算法，但是线程呢?CPU还如何选择线程执行调度呢?接着往下看吧</code></p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>在 Linux 内核中，进程和线程都是用<strong>tark_struct</strong>结构体表示的，区别在于线程的 tark_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的<strong>tark_struct</strong>相比进程的<strong>tark_struct</strong>承载的 资源比较少，因此以<strong>轻</strong>得名。</p>
<p>一般来说，没有创建线程的进程，是只有单个执行流，它被称为是主线程。如果想让进程处理更多的事情，可以创建多个线程分别去处理，但不管怎么样，它们对应到内核里都是<strong>tark_struct</strong>,所以，Linux 内核里的调度器，调度的对象就是 tark_struct，接下来我们就把这个数据结构统称为<strong>任务</strong></p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在Linux系统中，我们根据任务的<strong>优先级</strong>以及<strong>响应要求</strong>，将任务分为两种，其中优先级数值越小，优先级越高</p>
<ol>
<li>实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 0~99 范围内的就算实时任务</li>
<li>普通任务，响应时间没有很高的要求，优先级在 100~139 范围内都是普通任务级别</li>
</ol>
<h3 id="调度类"><a href="#调度类" class="headerlink" title="调度类"></a>调度类</h3><p>由于优先级的不同，Linux为了保障优先级高的任务尽可能地被执行，于是分为了以下几种<strong>调度类</strong></p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>几种调度类 </summary>
              <div class="content">
              <ol><li><p>Deadline调度类，它的调度器为<strong>Deadline调度器</strong>，调度策略为<strong>SCHED_DEADLINE(按照deadline调度，意思就是说距离当前时间点最近的deadline的任务会先被调度)<strong>，这种调度器一般是用来调度</strong>实时任务</strong>的</p></li><li><p>Realtime调度类，它的调度器为<strong>RT调度器</strong>，调度策略有两种</p><ol><li>SCHED_FIFO，对于相同优先级的任务，会将所有任务放入一个队列，然后根据队列的<strong>先进先出</strong>规则来调度任务，如果在一个任务被执行的过程中出现了优先级更高的任务，那么CPU就会停下当前手头上的任务，转而去执行优先级更高的那个任务</li><li>SCHED_RR，对于相同优先级的任务，轮流着运行，每个任务都有一定的时间片，当用完时间片的任务会被放到队列尾部，以保证相同优先级任务的公平性，但是高优先级的任务依然可以抢占低优先级的任务</li></ol><p> 这个调度类一般也用于<strong>实时任务</strong></p></li><li><p>Fair调度类，它的调度器为<strong>CFS调度器</strong>，调度策略也有两种</p><ol><li>SCHED_NORMAL，<strong>普通任务</strong>的调度策略</li><li>SCHED_BATCH，后台任务的调度策略，不和终端进行交互，因此在不影响其他需要交互的任务，可以适当降低它的优先级</li></ol><p> 这个调度类是用于<strong>普通任务</strong>的</p></li></ol><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E8%B0%83%E5%BA%A6%E7%B1%BB.jpg" class title="调度类">
              </div>
            </details>

<h3 id="完全公平调度"><a href="#完全公平调度" class="headerlink" title="完全公平调度"></a>完全公平调度</h3><p>在我们平时写代码时，一般的线程都属于<strong>普通任务</strong>，<strong>普通任务</strong>的比例也是最大的，而对于<strong>普通任务</strong>而言，<strong>公平</strong>才是最重要的，Linux为了满足<strong>普通任务</strong>的公平性，基于<strong>CFS</strong>的调度算法应运而生，那就是<strong>完全公平调度</strong>算法</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>算法理念 </summary>
              <div class="content">
              <p>这个算法的理念是想让分配给每个任务的 CPU 时间是一样，于是它为每个任务安排一个虚拟运行时间<strong>vruntime</strong>，如果一个任务在运行，其运行的越久，该任务的<strong>vruntime</strong>自然就会越大，而没有被运行的任务，<strong>vruntime</strong>是不会变化的</p><p>在<strong>CFS调度算法中</strong>，<strong>vruntime</strong>越小，就越会被选择，也就是说，<strong>CFS调度算法</strong>会优先选择<strong>vruntime</strong>小的任务</p><p>因为普通任务也会有优先级的区别，所以对于<strong>vruntime</strong>的计算，是需要考虑上普通任务的优先级的</p>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>vruntime的计算 </summary>
              <div class="content">
              <p><code>虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD/权重</code></p><p>NICE_0_LOAD:我们可以不用知道是什么，只需要知道它是一个<strong>常量</strong><br>权重: 注意权重值并不是优先级的值，内核中会有一个 nice 级别与权重值的转换表，nice 级别越低的权重值就越大，至于 nice 值是什么，我们后面会提到</p>
              </div>
            </details>

<h3 id="CPU运行队列"><a href="#CPU运行队列" class="headerlink" title="CPU运行队列"></a>CPU运行队列</h3><p>一个系统通常都会运行着很多任务，多任务的数量基本都是远超 CPU 核心数量，因此这时候就需要<strong>排队</strong></p>
<p>事实上，每个 CPU 都有自己的**运行队列(Run Queue, rq)**，用于描述在此 CPU 上所运行的所有进程，其队列包含三个运行队列，Deadline 运行队列 dl_rq、实时任务运行队列 rt_rq 和 CFS 运行队列 csf_rq，其中 csf_rq 是用红黑树来描述的，按 vruntime 大小来排序的，最左侧的叶子节点，就是下次会被调度的任务。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97.jpg" class title="运行队列">

<p>这几种调度类是有优先级的，优先级如下：Deadline &gt; Realtime &gt; Fair，这意味着 Linux 选择下一个任务执行的时候，会按照此优先级顺序进行选择，也就是说先从 dl_rq 里选择任务，然后从 rt_rq 里选择任务，最后从 csf_rq 里选择任务<br><strong>因此，实时任务总是会比普通任务优先被执行</strong></p>
<h3 id="如何调整优先级"><a href="#如何调整优先级" class="headerlink" title="如何调整优先级"></a>如何调整优先级</h3><ol>
<li>因为我们知道，<strong>实时任务</strong>肯定会比<strong>普通任务</strong>先进行调度，所以如果我们想要提高某个<strong>普通任务</strong>的优先级，那么方法之一就是将<strong>普通任务</strong>变成<strong>实时任务</strong></li>
<li>如果你想让某个普通任务有更多的执行时间，可以调整任务的<strong>nice</strong>值，从而让优先级高一些的任务执行更多时间。nice的值能设置的范围是<strong>负20~19</strong>，值越低，表明优先级越高，因此<strong>负20</strong>是最高优先级，<strong>19</strong>则是最低优先级，默认优先级是 0</li>
<li>它与优先级(priority)的关系是这样的：priority(new) &#x3D; priority(old) + nice，因为<strong>普通任务</strong>的优先值为<strong>100~139</strong>，又因为<strong>nice</strong>是调整<strong>普通任务</strong>的优先级，所以<strong>nice</strong>的值只能是<strong>负20~19</strong><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E4%BC%98%E5%85%88%E7%BA%A7.jpg" class title="优先级"></li>
<li>在前面我们提到了，权重值与 nice 值的关系的，nice 值越低，权重值就越大，计算出来的 vruntime 就会越少，由于 CFS 算法调度的时候，就会优先选择 vruntime 少的任务进行执行，所以 nice 值越低，任务的优先级就越高</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于CPU的知识点总结就到这里了，鼠鼠写了好多字啊，虽然有的文字是直接复制<strong>小林coding公众号</strong>的内容，图片也都是出自这里的，但鼠鼠也有在认真思考总结的嘛，鼠鼠也没那么不堪对吧，虽然鼠鼠到现在还没收到一家公司的面试，有的公司可能都不看我一眼<br>(悲)我同学都收到腾讯的面试邀请了，我们读的不是一个大学吗，为什么我简历他们都不愿意看一眼(悲)</p>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> CPU是如何执行程序的呢？CPU又是如何调度任务的呢？一些关于CPU的知识总结</li>
        <li><strong>作者:</strong> 这题超纲了</li>
        <li><strong>创建于:</strong> 2023-03-03 11:22:22</li>
        
            <li>
                <strong>更新于:</strong> 2023-06-23 14:38:34
            </li>
        
        <li>
            <strong>链接:</strong> https://qx-gg.github.io/2023/03/03/blog9/
        </li>
        <li>
            <strong>版权声明:</strong> 本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0</a> 进行许可。
        </li>
    </ul>
</div>

                </div>
            

            
                <ul class="post-tags-box">
                    
                        <li class="tag-item">
                            <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">#操作系统</a>&nbsp;
                        </li>
                    
                </ul>
            

            <div class="recommended-article">
  <div class="recommended-article-header">
    <i aria-hidden="true"></i><span>推荐阅读</span>
  </div>
  <div class="recommended-article-group"><a class="recommended-article-item" href="/2023/03/07/blog10/" title="操作系统中的内存管理" rel="bookmark">
  <img src="https://Qx-GG.github.io/images/水墨/水墨11.jpg" alt="操作系统中的内存管理">
  <span class="title">操作系统中的内存管理</span>
</a><a class="recommended-article-item" href="/2023/02/24/blog3/" title="关于线程池的构建及理解" rel="bookmark">
  <img src="https://Qx-GG.github.io/images/水墨/水墨4.jpg" alt="关于线程池的构建及理解">
  <span class="title">关于线程池的构建及理解</span>
</a><a class="recommended-article-item" href="/2023/02/24/blog5/" title="浙江宇视科技一面" rel="bookmark">
  <img src="https://Qx-GG.github.io/images/水墨/水墨6.jpg" alt="浙江宇视科技一面">
  <span class="title">浙江宇视科技一面</span>
</a></div>
</div>

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/03/05/day2/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">随笔·广州·心心念念的&#34;太古仓&#34;之行</span>
                                    <span class="post-nav-item">上一篇</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/02/28/blog8/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item">C++的继承、封装和多态</span>
                                    <span class="post-nav-item">下一篇</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
                <div class="comment-container">
                    <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fa-solid fa-comments"></i>&nbsp;评论
    </div>
    

        
            
 
    <div id="waline"></div>
    <script type="module"  data-pjax>
        import { init } from 'https://evan.beee.top/js/waline.mjs';

        function loadWaline() {
            init({
                el: '#waline',
                serverURL: 'https://waline-qin.6eek.net',
                lang: 'zh-CN',
                dark: 'body[class~="dark-mode"]',
                requiredMeta: ['nick','mail'], // cannot customize by theme config, change it yourself
            });
        }

        if ('true') {
            const loadWalineTimeout = setTimeout(() => {
                loadWaline();
                clearTimeout(loadWalineTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadWaline);
        }
        
    </script>



        
    
</div>

                </div>
            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">此页目录</div>
        <div class="page-title">CPU是如何执行程序的呢？CPU又是如何调度任务的呢？一些关于CPU的知识总结</div>
        <ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E6%A8%A1%E5%9E%8B"><span class="nav-text">冯诺依曼模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8-CPU"><span class="nav-text">中央处理器(CPU)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#32%E4%BD%8DCPU%E5%92%8C64%E4%BD%8DCPU%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="nav-text">32位CPU和64位CPU的差别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E5%86%85%E9%83%A8%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="nav-text">CPU内部的组件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E5%99%A8"><span class="nav-text">运算器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="nav-text">控制器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98"><span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BA%BF"><span class="nav-text">总线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E8%AE%BE%E5%A4%87"><span class="nav-text">输入、输出设备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU%E4%BD%8D%E5%AE%BD%E5%92%8C%E7%BA%BF%E8%B7%AF%E4%BD%8D%E5%AE%BD"><span class="nav-text">CPU位宽和线路位宽</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E8%B7%AF%E4%BD%8D%E5%AE%BD"><span class="nav-text">线路位宽</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CPU%E4%BD%8D%E5%AE%BD"><span class="nav-text">CPU位宽</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B"><span class="nav-text">程序执行的基本过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87"><span class="nav-text">计算机中的存储设备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E6%9C%89%E4%BA%86%E5%86%85%E5%AD%98%E8%BF%98%E9%9C%80%E8%A6%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-text">为何有了内存还需要寄存器?</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-text">存储器的层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8-1"><span class="nav-text">寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-Cache"><span class="nav-text">CPU Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#L1-Cache"><span class="nav-text">L1 Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#L2-Cache"><span class="nav-text">L2 Cache</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#L3-Cache"><span class="nav-text">L3 Cache</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98-1"><span class="nav-text">内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AC%E7%9B%98"><span class="nav-text">硬盘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98-SSD"><span class="nav-text">固态硬盘(SSD)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98-HDD"><span class="nav-text">机械硬盘(HDD)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AD%98%E5%82%A8%E5%85%B3%E7%B3%BB"><span class="nav-text">存储器的存储关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU-Cache-1"><span class="nav-text">CPU Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-Cache%E7%9A%84%E8%AF%BB%E5%8F%96%E8%BF%87%E7%A8%8B"><span class="nav-text">CPU Cache的读取过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU-Cache%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E8%AE%BF%E9%97%AE%E9%80%BB%E8%BE%91"><span class="nav-text">CPU Cache的数据结构和访问逻辑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU%E5%86%99%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C"><span class="nav-text">CPU写数据操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E7%9B%B4%E8%BE%BE"><span class="nav-text">写直达</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%99%E5%9B%9E"><span class="nav-text">写回</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">缓存一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-text">什么是缓存一致性?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-text">如何避免缓存一致性问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MESI%E5%8D%8F%E8%AE%AE"><span class="nav-text">MESI协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="nav-text">伪共享问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3-%E9%81%BF%E5%85%8D-%E4%BC%AA%E5%85%B1%E4%BA%AB%E9%97%AE%E9%A2%98"><span class="nav-text">如何解决(避免)伪共享问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-text">线程调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1"><span class="nav-text">任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E7%B1%BB"><span class="nav-text">调度类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E5%85%AC%E5%B9%B3%E8%B0%83%E5%BA%A6"><span class="nav-text">完全公平调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97"><span class="nav-text">CPU运行队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%B0%83%E6%95%B4%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">如何调整优先级</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-text">结语</span></a></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>
            
            

        </div>

        <div class="main-content-footer">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2023</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">这题超纲了</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        访问人数&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a> 驱动</span>
                <br>
            <span class="theme-version-container">主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.1.5</a>
        </div>
        
        
        
            <div id="start_div" style="display:none">
                2023/2/23 15:15:11
            </div>
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <div class="customize-info info-item">和我一起去充满橘子味的村庄叭</div>
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
            
                
        
                
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="article-tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fa-regular fa-comments"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-side-tools-container">
        <div class="side-tools-container">
    <ul class="hidden-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="visible-tools-list">
        <li class="right-bottom-tools toggle-tools-list flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="arrow-up fas fa-arrow-up"></i>
                <span class="percent"></span>
            </li>
        
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fa-solid fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fa-solid fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    


</main>



<script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/utils.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/main.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/layouts/navbarShrink.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/scrollTopBottom.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/lightDarkSwitch.js"></script>


    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/localSearch.js"></script>



    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/codeBlock.js"></script>



    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/layouts/lazyload.js"></script>



    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/runtime.js"></script>
    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/libs/odometer.min.js"></script>
    <link rel="stylesheet" href="//npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/assets/odometer-theme-minimal.css">



  <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/libs/Typed.min.js"></script>
  <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/plugins/typed.js"></script>





    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/libs/minimasonry.min.js"></script>
    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/plugins/masonry.js"></script>


<div class="post-scripts pjax">
    
        <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/tools/tocToggle.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/libs/anime.min.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/layouts/toc.js"></script><script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/plugins/tabs.js"></script>
    
</div>


    <script src="https://npm.elemecdn.com/hexo-theme-redefine@2.1.5/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax',
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            Global.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            Global.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            Global.refresh();
        });
    });
</script>




</body>
</html>
