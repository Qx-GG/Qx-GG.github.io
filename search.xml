<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于【背包问题】的理解以及求解思路</title>
    <url>/2023/02/23/blog1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1464325108&auto=1&height=66"></iframe>

<h2 id="日常力扣刷题"><a href="#日常力扣刷题" class="headerlink" title="日常力扣刷题"></a>日常力扣刷题</h2><p>今天的问题：给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。（力扣416题，难度中等）</p>
<p>我的解题思路：</p>
<ol>
<li>看到数组以及是需要给出最后结果，我一般都会先考虑动态规划，而动态规划的难点就在于如何写出状态转移方程，在本题目中很难看出数组之间存在什么联系。于是就先放弃这个想法，显而易见的是如果能分成两个数组，那么俩数组之和一定相等并且为nums数组之和的一半，所以我就先求出nums之和sum，当然，sum肯定得是偶数。</li>
<li>那么现在问题就变成了在nums数组里面找出n个数，加起来正好为sum&#x2F;2（每个数都能选一次）。</li>
<li>一开始的思路肯定是用DFS，一个数一个数地累加，但是发现超时了（虽然本来就有猜想会超时，但还是会去写一下），然后想到有重复状态的出现，于是改成记忆化搜索,既然是记忆化，就可以用一个数组来记录状态，这样就又有点像动态规划了。</li>
<li>仔细一想，从数组里取出n个数字，每个数字可能被取走（1），也可能没被取走（0），这就有点像[0-1]背包问题了。</li>
</ol>
<h2 id="什么是-0-1-背包问题？如何求解呢"><a href="#什么是-0-1-背包问题？如何求解呢" class="headerlink" title="什么是[0-1]背包问题？如何求解呢?"></a>什么是[0-1]背包问题？如何求解呢?</h2><p>[0-1]背包问题是[背包问题]的其中一种，那么什么是[0-1]背包问题呢？不妨看看下面这道题([0-1]背包问题经典题目)：<br>已知有n个物品，每个物品的重量记录在weight[n]，一个数组price[n]代表每个物品的价格，有一个背包能够承受的重量为target，求如何选取物品才能在不超重的情况下拿到的物品价格总和最大？<br>注：每个物品只能拿一次！</p>
<p>解题：</p>
<ol>
<li>很明显，这种最值问题大多都是用动态规划来求解的，那么这个问题的关键就在于如何找出状态转移方程呢？</li>
<li>那么如何找出状态转移方程呢？一般情况下我们都是创建一个动态数组dp[n],但是在这题上面我们能难找到它们之间的联系，因为每个物品都有两个值，一个是重量，一个是价格。那么我们能不能创建一个二位动态数组来进行转换呢？想到这里，我们不妨先创建一个二维数组。</li>
<li>创建二维数组要创建多大呢？因为我们最后只需要一个结果，所以有一个值肯定是所给的target，那另一个选什么呢？在一般的一维动态规划中我们不都是选取所给数组的大小为创建大小吗？所以我们不如也选取给的重量的数组的大小为一个值？(为什么选重量呢？因为所给的target是与重量有关的，当然了，这里选那个都一样，都是n)。所以我们创建一个二维的动态数组dp</li>
</ol>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (target+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line"><span class="comment">//dp[i][j]表示选取[0-i]个物品中，重量加起来不超过j时的最大值</span></span><br></pre></td></tr></table></figure></div>

<ol start="4">
<li><p>首先我们先定义初始条件：当选取0个物品时，无论背包所能承受的重量多大都没关系，所以dp[0][j]&#x3D;-1;当背包承受的重量为0的时候，无论有多少个物品可以选择，能选择的数量都只能是0，所以dp[i][0]&#x3D;0;</p>
</li>
<li><p>开始找状态转移方程，dp[i][j]表示能选的物品加入weight[i-1]的时候，不超过背包承重为j时的最大价格，那么此时，就有俩个选择:</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>两种选择 </summary>
              <div class="content">
              <ol><li>在这个背包里面添加这个物品，但想要添加成功就不能超重，那么就需要j&gt;weight[i-1];此时的dp[i][j]&#x3D;dp[i][j-weight[i-1]]+price[i];</li><li>不在背包里添加这个物品，那么dp[i][j]&#x3D;dp[i-1][j];</li></ol>
              </div>
            </details>
</li>
<li><p>综上，dp[i][j]&#x3D;max(dp[i][j-weight[i-1]]+price[i],dp[i-1][j]);</p>
</li>
<li><p>dp[n][target]就是最后的结果</p>
</li>
</ol>
<p>代码如下：</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MaxPrice</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; weight,vector&lt;<span class="type">int</span>&gt;&amp; price,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=weight.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//创建二维数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (target+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">//初始化数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp[<span class="number">0</span>].<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i]=<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行状态转移</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;dp[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=weight[i<span class="number">-1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j]=<span class="built_in">max</span>(dp[i][j-weight[i<span class="number">-1</span>]]+price[i],dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>建议画个图可以更深刻的理解逻辑，并且会发现，每一行的数据都只和上一行的数据或者上一行的左边某几列有关系，既然这样，我们完全可以优化一下我们的代码，将二维数组变成一维数组</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(target+<span class="number">1</span>)</span></span>;</span><br><span class="line">dp[weight[<span class="number">0</span>]]=price[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=target;j&gt;weight[i];j--)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j]=<span class="built_in">max</span>(dp[j],dp[j-weight[i]]+price[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[target]</span><br></pre></td></tr></table></figure></div>

<p>有小伙伴会问，为什么内循环是逆序啊？这边建议自己按照流程画个图就知道为什么了捏！<br>[背包问题]不只有[0-1]背包问题，还有[完全背包]等等,想要完全搞懂的话建议去看下面这篇文章，里面讲解的很详细：<a class="link" href="http://t.csdn.cn/e782s">http://t.csdn.cn/e782s <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="回到原本的题目"><a href="#回到原本的题目" class="headerlink" title="回到原本的题目"></a>回到原本的题目</h2><p>既然学会了[0-1]背包问题，那么这题也就会做了吧，唯一的区别就是这题需要加起来的值&#x3D;sum&#x2F;2，但这并不妨碍用[0-1]背包问题的模板来解题,代码如下:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid=sum/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>]&gt;mid)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt; (mid+<span class="number">1</span>,<span class="literal">false</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;dp.<span class="built_in">size</span>();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;dp.<span class="built_in">size</span>();i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;dp[<span class="number">0</span>].<span class="built_in">size</span>();j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(j&gt;=nums[i<span class="number">-1</span>])</span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i][j]=dp[i<span class="number">-1</span>][j]|dp[i<span class="number">-1</span>][j-nums[i<span class="number">-1</span>]];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i][mid])</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()][mid];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>今天的学习就到这边了，想要掌握好背包问题的话，建议去把力扣上的有关问题都做一遍<br>「力扣」上的 0-1 背包问题：<br>「力扣」第 416 题：分割等和子集（中等）；<br>「力扣」第 474 题：一和零（中等）；<br>「力扣」第 494 题：目标和（中等）；<br>「力扣」第 879 题：盈利计划（困难）；<br>「力扣」上的 完全背包问题：<br>「力扣」第 322 题：零钱兑换（中等）；<br>「力扣」第 518 题：零钱兑换 II（中等）；<br>「力扣」第 1449 题：数位成本和为目标值的最大数字（困难）。<br>这里要注意鉴别：「力扣」第 377 题，不是「完全背包」问题。</p>
<p>晚安~</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统中的内存管理</title>
    <url>/2023/03/07/blog10/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5257205&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是一篇鼠鼠看完<code>小林coding</code>文章后总结的关于操作系统中的内存管理的一些知识点，并且穿插了几个面试题，我自己是看完了小林的答案才知道的，觉得属于这一块的内容于是就写上去了，gogogo!</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>我们知道，所有的程序最后都是在<strong>内存</strong>中执行的，准确来说，应该是说所有程序运行的时候，都需要加载到内存中才能被CPU获取从而进行代码的执行</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>单片机 </summary>
              <div class="content">
              <p>鼠鼠是电子信息工程专业的，虽然我对这个专业一点兴趣都没有，但是有些知识鼠鼠还是知道的，比如<strong>单片机</strong><br>单片机是<strong>没有操作系统</strong>的，所以我们想要将单片机上的程序运行起来，就必须通过一些工具将我们写的代码<strong>烧入</strong>单片机的内存中，这样程序才能执行，而且单片机的CPU是<strong>直接操作物理内存的</strong></p><p>那么这样做有什么问题呢?</p><p>因为单片机是直接操作物理地址的，所以就会出现在同一个地址上可能会有两种代码，比如第一个代码烧入单片机后占据了物理内存的某个位置，当我们烧入第二个代码时，万一也是在相同的物理地址上，第一个程序就没办法继续执行了</p>
              </div>
            </details>

<p>在现代的计算机中，操作系统是如何解决上面的问题呢?</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ol>
<li>因为如果有一个进程在某一块内存上运行，此时该内存上是无法运行第二个人进程的，就无法做到<strong>并行</strong>地运行多个进程，<strong>为了避免多个程序都引用了绝对物理地址</strong>，于是就引入了<strong>虚拟内存</strong></li>
<li><strong>每个进程分配独立的虚拟地址(32位操作系统会有4G的虚拟地址，其中1G是属于内核空间，3G属于用户空间；64位操作系统就大得多，用户空间和内核空间都是128T)，互不干涉，有个前提就是每个进程都没办法直接访问物理地址</strong>，至于虚拟地址是如何落到物理地址上的，对进程来说是<strong>透明的</strong>，操作系统已经把这些都安排好了</li>
<li><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来</strong><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>虚拟内存地址 </summary>
              <div class="content">
              <p>程序使用的内存地址</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>物理内存地址 </summary>
              <div class="content">
              <p>实际物理硬件(内存条)里面的空间地址</p>
              </div>
            </details></li>
</ol>
<p>操作系统引入了虚拟内存。进程持有的虚拟地址会通过CPU芯片中的**内存管理单元(MMU)**的映射关系，来转化为物理地址，然后通过物理地址来访问内存</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80.jpg" class title="虚拟地址">

<p>那么<strong>操作系统是如何管理虚拟地址和物理地址的关系的呢?</strong></p>
<p>主要是<strong>内存分段</strong>和<strong>内存分页</strong></p>
<h3 id="内存分段"><a href="#内存分段" class="headerlink" title="内存分段"></a>内存分段</h3><ol>
<li>程序是由若干个逻辑分段组成的，可由<strong>代码段</strong>，<strong>数据分段</strong>，<strong>堆</strong>，<strong>栈</strong>构成，<strong>因为不同段有不同的属性，所以就用分段的形式把这些段分离出来</strong></li>
<li>分段机制下，虚拟地址分为两部分:<strong>段选择子</strong>和<strong>段内偏移量</strong><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>段选择子 </summary>
              <div class="content">
              <p>段选择子保存在<strong>寄存器</strong>中，段选择子最重要的是<strong>段号</strong>，可以用作<strong>段表</strong>的索引<br><strong>段表</strong>包含<strong>段基地址</strong>，<strong>段界限</strong>，<strong>特权级</strong></p>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>段内偏移量 </summary>
              <div class="content">
              <p>段内偏移量位于0和段表中的<strong>段界限</strong>之间，如果段内偏移量合法，那么<strong>物理内存地址&#x3D;段基地址+段内偏移量</strong></p>
              </div>
            </details>
<img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/%E6%AE%B5.jpg" class title="段"></li>
</ol>
<p>我们知道<strong>内存分段</strong>会将*<strong>虚拟地址</strong>分为4个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上偏移量，于是就能找到物理内存中的地址</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/%E6%AE%B51.jpg" class title="段1">

<p>虽然分段的方法很好，但是它也是有一些问题的，其中之一就是<strong>内存碎片</strong></p>
<h4 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h4><p>首先我们先来考虑这样一个情况:</p>
<ol>
<li>有一个大小为900MB的物理内存，其中执行了3个进程，分别为<ol>
<li>进程1，占据了400的物理内存</li>
<li>进程2，占据了200的物理内存</li>
<li>进程3，占据了100的物理内存<br> 此时空余的物理内存大小为:900-400-200-100&#x3D;200MB</li>
</ol>
</li>
<li>此时我们结束掉大小为200的物理内存，那么我们剩余的物理内存大小就为400MB</li>
<li>当我们想要运行大小为300MB的一个进程4，此时是没办法运行的，这是为什么呢？<img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87.jpg" class title="内存碎片">
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>内存碎片 </summary>
              <div class="content">
              <p>内存碎片也分为两种</p><ol><li>外部内存碎片:产生了多个不连续的小物理内存，导致新的程序无法被载入，就例如上面那张图所示</li><li>内部内存碎片:程序所有的内存都被装载到了物理内存，<strong>但这个程序很大一部分内存是不经常使用的，这样会导致内存的浪费</strong></li></ol>
              </div>
            </details></li>
</ol>
<h4 id="如何解决外部内存碎片问题"><a href="#如何解决外部内存碎片问题" class="headerlink" title="如何解决外部内存碎片问题?"></a>如何解决外部内存碎片问题?</h4><p>我们可以利用<strong>内存交换</strong>的方法来解决外部内存碎片的问题，如何做到的呢?</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>内存交换 </summary>
              <div class="content">
              <p>将一个程序写到硬盘上，然后再从硬盘上读回到内存中，只不过读回来的时候，<strong>不能装载回原来的位置，而是紧接着已被占用的内存</strong></p><p><code>这个内存交换空间，在Linux系统中是Swap空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换</code></p>
              </div>
            </details>
<p>但是因为对于多进程的系统而言，内存碎片是很容易产生的，又因为硬盘的访问速度比内存慢太多了，每一次内存交换，都要把一大段连续的内存数据写到磁盘中，<strong>所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿</strong></p>
<p>为了解决内存交换效率低下的问题，科学家们有研究出了一个新的方法:<strong>内存分页</strong></p>
<h3 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h3><ol>
<li>为了解决内存碎片的问题，另外，当需要进行内存交换时，让需要交换写入或者从磁盘中装载的数据更少一点，就出现了<strong>内存分页</strong>技术</li>
<li><strong>内存分页是把整个虚拟内存空间和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且<strong>尺寸固定</strong>的内存空间，我们称之为<strong>页(page)</strong>,在Linux下，每一页的大小也<strong>4KB</strong></li>
<li>虚拟地址通过<strong>页表</strong>来映射物理地址<img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/%E5%88%86%E9%A1%B5.jpg" class title="分页"></li>
<li>页表实际上存储在 CPU 的**内存管理单元(MMU)**中，于是CPU就可以直接通过MMU,找出要实际要访问的物理内存地址</li>
<li>当进程访问的虚拟地址在页表中查不到时,系统会产生一个<strong>缺页异常</strong>，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行</li>
</ol>
<h4 id="内存分页如何解决内存碎片、内存交换效率低的问题"><a href="#内存分页如何解决内存碎片、内存交换效率低的问题" class="headerlink" title="内存分页如何解决内存碎片、内存交换效率低的问题?"></a>内存分页如何解决内存碎片、内存交换效率低的问题?</h4><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>不会产生内存碎片的原因 </summary>
              <div class="content">
              <p>由于<strong>无论是虚拟内存空间还是物理内存空间</strong>都是预先划分好的，也就是说不会像分段那样会产生间隙较小的内存，而采用了分页，那么<strong>释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存</strong></p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>解决内存交换的效率低下问题的原因 </summary>
              <div class="content">
              <p>如果内存不够，操作系统会把其他<strong>正在运行的进程中[最近未经使用(LRU算法)]的内存页面给释放掉</strong>，称为<strong>换出(暂时写在硬盘上)</strong><br>一旦需要的时候，再加载进物理内存，称之为<strong>换入</strong><br>所以，一次性写入磁盘的也只有少数的一页或者几页，不会花费太多时间，<strong>内存交换的效率就比较高</strong></p>
              </div>
            </details>
<img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/%E5%88%86%E9%A1%B51.jpg" class title="分页1">

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>分页技术的好处之一 </summary>
              <div class="content">
              <p>分页技术使得程序在加载的时候，不需要将所有程序都加载到物理内存中。可以在进行虚拟内和物理内存的页之间的映射之后，并不把全部页都加载到物理内存，<strong>而是只有在程序运行时，需要用到对应虚拟内存页里面的指令和数据时，再将该页加载到物理内存中</strong></p>
              </div>
            </details>

<h4 id="虚拟地址如何映射到物理地址"><a href="#虚拟地址如何映射到物理地址" class="headerlink" title="虚拟地址如何映射到物理地址?"></a>虚拟地址如何映射到物理地址?</h4><p><code>虚拟地址=页号+页内偏移量</code><br>页号:页表的索引(页表包含物理页每页所在的物理内存的基地址)<br>页内偏移量:数据在物理页中的位置</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/%E9%A1%B5%E8%A1%A8.jpg" class title="页表">

<p>世界上没有完美的人，无论什么事都有两面性，就像我单身的话，我就只有偶尔会烦恼没有女朋友，但如果我有女朋友，我就会有很多烦恼，比如要送什么礼物啊，要去哪里约会啊，要如何当好一个合格的男朋友啊什么什么的，所以我选择<strong>单身!</strong>,并不是鼠鼠找不到奥，只是鼠鼠不想谈(哭)</p>
<p>所以内存分页也会出现一定的问题的</p>
<h4 id="内存分页出现的问题"><a href="#内存分页出现的问题" class="headerlink" title="内存分页出现的问题"></a>内存分页出现的问题</h4><p>因为一个进程对应一个页表(每个页在Linux下为4KB)，而在一个系统中可以同时运行非常多的进程，这样页表会非常庞大</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>举个栗子 </summary>
              <div class="content">
              <p>一个进程的虚拟空间在32位操作系统中位4GB，而每一页在Linux下为4KB，因为一张页表需要包含所有虚拟空间的地址，所以一张页表大概需要100万个页(4GB&#x2F;4KB)，而每个页的页表项需要<strong>4个字节</strong>，所以整个4GB空间的映射需要<strong>4×100万&#x3D;4MB</strong>的内存来存储页表</p><p>虽然单个进程来看好像4MB不是很多，但是当有100个进程呢?1000个进程呢?此时光是页表占用的空间的很大了，这还只是在32位操作系统下，在64位操作系统下我都不敢相信欸!</p>
              </div>
            </details>

<h4 id="如何解决内存分页出现的问题"><a href="#如何解决内存分页出现的问题" class="headerlink" title="如何解决内存分页出现的问题"></a>如何解决内存分页出现的问题</h4><p>聪明的科学家相处了<strong>多级页表</strong>的方法来解决这个问题，那么什么是多级页表呢?<br>我们很容易地可以从字面意思知道，<strong>多级页表</strong>就是将页表分级，分为一级，两级等等，那么如何分呢?<br>如下(在32位操作系统下):</p>
<ol>
<li>我们把有着100多万个页表项的页表进行二次分页</li>
<li>将一级页表分为<strong>1024</strong>个<strong>二级页表</strong>，每个<strong>二级页表</strong>包含<strong>1024</strong>个页表项，如下图所示<img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8.jpg" class title="二级页表">
此时一个进程需要映射的所有页表大小加起来为**4字节×1024(一级页表的大小)+1024×(一张二级页表的大小 1024×4字节)&#x3D;4KB+4MB</li>
</ol>
<p>此时很多人会疑惑，这样不是比单级页表所需要的内存空间更大了嘛？但实际上真的是这样吗?不对哦<br>在这里我们需要知道:</p>
<ol>
<li>大多数进程是没办法使用到4GB的虚拟内存的，也就是说我们不需要把4GB的虚拟地址都有一个映射到的物理地址，只有进程占用的虚拟内存才需要映射</li>
<li>这也就意味很多页是用不到的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存</li>
<li>如果只是单级页表的话，因为<strong>页表的职责就是将虚拟地址转化为物理地址</strong>，也就是说，我们不能有<code>虚拟地址没法在叶表上找到对应的物理地址</code>这种情况出现，所以必须包含所有的虚拟空间地址</li>
<li>如果是二级表的话，一级表其实和二级表是类似的，也包含了所有的虚拟地址，只不过一级表中每一页包含了很多个虚拟地址，那样就可以只用<strong>1024</strong>个页表项来包含整个虚拟地址了</li>
<li>当一个进程没有用到某个一级页表包含的虚拟地址时，就不需要去创建二级页表了，只有当需要的时候才创建</li>
</ol>
<p>做个简单的计算，假设只有<strong>20%<strong>的一级页表项被用到了，那么页表占用的内存空间就只有</strong>4KB(一级页表)+ 20%×4MB(二级页表)&#x3D; 0.804MB</strong>，这远远小于单级页表的4MB大小</p>
<p>当然了，有二级页表，自然也可以有3级、4级等等，在当今的64位操作系统下，2级页表也不够看了，所以如今大多是4级页表，分别是:</p>
<ol>
<li>全局页目录项 PGD(Page Global Directory)</li>
<li>上层页目录项 PUD(Page Upper Directory)</li>
<li>中间页目录项 PMD(Page Middle Directory)</li>
<li>页表项 PTE(Page Table Entry)<img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/%E5%9B%9B%E7%BA%A7%E9%A1%B5%E8%A1%A8.jpg" class title="四级页表"></li>
</ol>
<p>此时又出现问题啦，没错，我们总是在不断地寻找问题并解决问题，我们一直在这个道路上前进</p>
<p><code>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销</code></p>
<p>我们应该知道:<br>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域</p>
<p>我们就可以利用这一特性，把最常访问的几个页表项存储到访问速度更快的硬件，于是计算机科学家们，就在 CPU 芯片中，加入了一个专门存放程序最常访问的页表项的<strong>Cache</strong>,这个 Cache 就是 TLB(Translation Lookaside Buffer)，通常称为页表缓存、转址旁路缓存、快表等</p>
<h4 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h4><img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/TLB.jpg" class title="TLB">
<ol>
<li>在 CPU 芯片里面，封装了内存管理单元（Memory Management Unit）芯片，它用来完成地址转换和 TLB 的访问与交互</li>
<li>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表</li>
<li>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个</li>
</ol>
<h3 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h3><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/%E6%AE%B5%E9%A1%B5%E5%BC%8F.jpg" class title="段页式">
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ol>
<li>先将程序分为多个具有逻辑意义的段(<strong>代码段</strong>，<strong>数据段</strong>，<strong>栈</strong>，<strong>堆</strong>等)，也就是<strong>分段机制</strong></li>
<li>再把每个段划分位多个<strong>页</strong>，这样，虚拟地址结构就由<strong>段号，段内页号和页内偏移量</strong>三部分组成</li>
</ol>
<h4 id="段页式地址变换到物理地址"><a href="#段页式地址变换到物理地址" class="headerlink" title="段页式地址变换到物理地址"></a>段页式地址变换到物理地址</h4><p>想要将段内式地址变换得到物理地址需要经过三次内存访问:</p>
<ol>
<li>第一次，通过段号访问段表，获取页表的起始地址</li>
<li>第二次，通过第一次访问到的页表起始地址访问页表，通过<strong>段内页号</strong>找到页表中对应的页号，获取对应的物理地址</li>
<li>第三次，通过第二次得到的物理地址加上页内偏移量，获得真正的<strong>物理地址</strong><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优势 </summary>
              <div class="content">
              <p>提高了内存的利用率</p>
              </div>
            </details>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>劣势 </summary>
              <div class="content">
              <p>增加了硬件成本和系统开销</p>
              </div>
            </details></li>
</ol>
<h3 id="Linux的内存管理"><a href="#Linux的内存管理" class="headerlink" title="Linux的内存管理"></a>Linux的内存管理</h3><p>先来看看Intel处理器的发展历史</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Intel处理器的发展历史 </summary>
              <div class="content">
              <ol><li>早期 Intel 的处理器从<strong>80286</strong>开始使用的是<strong>段式内存管理</strong>。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。因此，在不久以后的 80386 中就实现了对<strong>页式内存管理</strong>。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理</li><li>但是这个<strong>80386</strong>的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，页式内存管理的作用是在由段式内存管理所映射而成的的地址上再加上一层地址映射</li><li>由于此时段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”(也称虚拟地址)。于是，段式内存管理先将<strong>逻辑地址</strong>映射成<strong>线性地址</strong>，然后再由<strong>页式内存管理</strong>将<strong>线性地址</strong>映射成<strong>物理地址</strong><img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/Intel.jpg" class title="Intel">逻辑地址:   程序所使用的地址，通常是没被段式内存管理映射的地址线性地址:   通过段式内存管理映射的地址，称为线性地址，也叫虚拟地址`逻辑地址是「段式内存管理」转换前的地址，线性地址则是「页式内存管理」转换前的地址`</li></ol>
              </div>
            </details>
<p>知道这些后，再来看看Linux的内存管理</p>
<ol>
<li><p>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制</p>
</li>
<li><p>这主要是上面 Intel 处理器发展历史导致的，因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择</p>
</li>
<li><p>但是事实上，Linux 内核所采取的办法是使段式映射的过程实际上不起什么作用。也就是说，“上有政策，下有对策”，若惹不起就躲着走</p>
</li>
<li><p>Linux 系统中的每个段都是从<strong>0 地址</strong>开始的整个 4GB 虚拟空间(32 位环境下)，也就是<strong>所有的段的起始地址都是一样的</strong>。</p>
</li>
<li><p>这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间(虚拟地址)，这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。</p>
</li>
</ol>
<h2 id="关于内存管理的一些问题"><a href="#关于内存管理的一些问题" class="headerlink" title="关于内存管理的一些问题"></a>关于内存管理的一些问题</h2><h3 id="在4G物理内存的机器上，申请8G的内存会怎么样？"><a href="#在4G物理内存的机器上，申请8G的内存会怎么样？" class="headerlink" title="在4G物理内存的机器上，申请8G的内存会怎么样？"></a>在4G物理内存的机器上，申请8G的内存会怎么样？</h3><p>在回答这个问题之前，让我们先了解一下用户如何申请内存，我们在写代码的时候，如果希望开辟一个新的空间，我们可以使用**malloc()&#x2F;new()**函数来申请内存空间，那么底层是怎么实现的呢?</p>
<h4 id="Linux下分配虚拟内存-申请内存-的两种方法"><a href="#Linux下分配虚拟内存-申请内存-的两种方法" class="headerlink" title="Linux下分配虚拟内存(申请内存)的两种方法"></a>Linux下分配虚拟内存(申请内存)的两种方法</h4><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>brk </summary>
              <div class="content">
              <p>申请小于128k的内存时，使用brk分配内存，将<strong>数据段.data</strong>的最高地址指针_edata向高地址移动，即增加<strong>堆</strong>的有效区域来申请新的内存空间</p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>mmap </summary>
              <div class="content">
              <p>申请大于128k的内存时，使用mmap分配内存，mmap是在进程的文件映射区找一块空闲存储空间，128K限制可由M_MMAP_THRESHOLD选项进行修改</p>
              </div>
            </details>

<p>注意:<br><code>当应用程序使用**malloc**进行申请空间后，实际上申请的是**虚拟空间**，只有当我们使用这块虚拟空间的时候，CPU就会去访问这块虚拟内存，根据页表进行映射，但由于是第一次，会发现页表上并没有该虚拟地址对应的物理地址，此时CPU就会产生一个缺页中断，进程会从用户态变成内核态，并将缺页中断交给Page Fault Handler(缺页中断函数)处理</code><br>缺页中断处理函数会看是否有空闲的物理内存:</p>
<ol>
<li>如果有，就直接分配物理内存，并建立虚拟内存与物理内存之间的映射关系</li>
<li>如果没有空闲的物理内存，那么内核就会开始进行回收内存的工作，如果回收内存工作结束后，空闲的物理内存仍然无法满足此次物理内存的申请，那么内核就会放最后的大招了触发**OOM(Out of Memory)**机制</li>
</ol>
<h4 id="在不同的环境下对问题的解答"><a href="#在不同的环境下对问题的解答" class="headerlink" title="在不同的环境下对问题的解答"></a>在不同的环境下对问题的解答</h4><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>在32位操作系统下并且物理内存只有4GB的环境下 </summary>
              <div class="content">
              <p>如果在该环境下进行申请，是会<strong>失败</strong>的<br>因为我们知道32位操作系统下，进程的虚拟内存在用户态最大只有<strong>3GB</strong>，所以是没有办法申请8GB的虚拟内存的，也就是无法申请内存</p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>在64位操作系统下并且物理内存只有4GB的环境下 </summary>
              <div class="content">
              <p>因为如果只是申请虚拟内存的话，是可以成功的，因为64G的操作系统环境下，用户空间高达128T<br>但是也有可能在Linux下是会失败的，那是因为Linux有一个参数需要我们注意，那就是<strong>overcommit_memory</strong></p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/vm/overcommit_memory </span><br><span class="line">//查看overcommit_memory参数</span><br></pre></td></tr></table></figure></div><p>overcommit_memory参数的值:</p><ol><li>如果值为<strong>0(默认值)<strong>，代表:<strong>Heuristic overcommit handling</strong>，它允许overcommit，但</strong>过于明目张胆的</strong> overcommit 会被拒绝，比如<strong>malloc一次性申请的内存大小就超过了系统总内存</strong>。Heuristic的意思是“试探式的”，内核利用某种算法猜测你的内存申请是否合理，大概可以理解为单次申请不能超过free memory + free swap + pagecache的大小 + SLAB中可回收的部分 ，超过了就会拒绝overcommit</li><li>如果值为 1，代表:Always overcommit. 允许overcommit，对内存申请来者不拒</li><li>如果值为 2，代表：Don’t overcommit. 禁止overcommit</li></ol>
              </div>
            </details>

<h4 id="问题衍生"><a href="#问题衍生" class="headerlink" title="问题衍生"></a>问题衍生</h4><p>假设我们在64位操作系统，并且overcommit_memory的值为1的时候，申请128T的虚拟内存就一定可以成功嘛?</p>
<p>答案:不一定，我们还需要根据物理内存的大小来判断。</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>当我们的物理内存只有2G </summary>
              <div class="content">
              <p>实验后发现，当我们还没有申请到128T虚拟内存的时候就被杀死了，而且错误信息为<strong>killed</strong>,也就是触发<strong>OOM</strong>了</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>什么是OOM? </summary>              <div class="content">              <p>内存溢出(Out Of Memory，简称OOM)是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。此时程序就运行不了，系统会提示内存溢出</p>              </div>            </details><p>这是因为即使我们只是申请虚拟内存，但仍旧使用到了物理内存(比如内核保存虚拟内存的数据结构，也是占用物理内存的),所以如果<strong>物理内存</strong>太小的话，大概率是会出发OOM机制的</p>
              </div>
            </details>

<p>那么，2G的物理内存就没有办法申请128T的虚拟内存了吗?<br>其实这也是要根据情况来说的，是什么情况呢?那就是要看我们的操作系统有没有开启<strong>Swap机制</strong><br>使用<strong>swapfile</strong>的方式开启了<strong>1GB</strong>的<strong>swap空间</strong>之后再做实验，虽然最后出现了<strong>Cannot allocate memory</strong>，但计算下来我们发现其实以及申请成功了，实际上我们是不可能申请完整个 128T 的用户空间的，因为程序运行本身也需要申请虚拟空间</p>
<h4 id="Swap机制的作用"><a href="#Swap机制的作用" class="headerlink" title="Swap机制的作用"></a>Swap机制的作用</h4><p>前面我们说过了，在<strong>分段机制下</strong>，如果想要解决内存碎片的问题，最开始的解决方法就是<strong>swap</strong><br><code>当系统的物理内存不够用的时候，就需要将物理内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间会被临时保存到磁盘，等到那些程序要运行时，再从磁盘中恢复保存的数据到内存中</code><br><code>另外，当内存使用存在压力的时候，会开始触发内存回收行为，会把这些不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了</code></p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>swap的两个过程 </summary>
              <div class="content">
              <p>换入:是在进程再次访问这些内存的时候，把它们从磁盘读到内存中来<br>换出:是把进程暂时不用的内存数据存储到磁盘中，并释放这些数据占用的内存<br><img lazyload src="/images/loading.svg" data-src="/2023/03/07/blog10/swap.jpg" class title="swap"></p>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>swap的优势 </summary>
              <div class="content">
              <p>应用程序实际可以使用的内存空间将远远超过系统的物理内存。由于硬盘空间的价格远比内存要低，因此这种方式无疑是经济实惠的</p>
              </div>
            </details>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>swap的劣势 </summary>
              <div class="content">
              <p>频繁地读写硬盘，会显著降低操作系统的运行速率</p>
              </div>
            </details>

<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>swap机制触发的两种场景 </summary>
              <div class="content">
              <ol><li>内存不足:之前一直说的，物理内存不足的时候，会将(最久未经使用)的物理内存换出</li><li>内存闲置:<br>应用程序在启动阶段使用的大量内存在启动后往往都不会使用，通过后台运行的守护进程(kSwapd)，我们可以将这部分只使用一次的内存交换到磁盘上为其他内存的申请预留空间。kSwapd 是 Linux 负责页面置换(Page replacement)的守护进程，它也是负责交换闲置内存的主要进程，它会在回收内存页中的空闲内存保证系统中的其他进程可以尽快获得申请的内存。kSwapd 是后台进程，所以回收内存的过程是异步的，不会阻塞当前申请内存的进程</li></ol>
              </div>
            </details>
<h4 id="Swap机制换出换入的是什么类型的内存"><a href="#Swap机制换出换入的是什么类型的内存" class="headerlink" title="Swap机制换出换入的是什么类型的内存"></a>Swap机制换出换入的是什么类型的内存</h4><p>内核缓存的文件数据，因为都有对应的磁盘文件，所以在回收文件数据的时候， 直接写回到对应的文件就可以了，这部分内存被称为<strong>文件页</strong></p>
<p>但是像进程的堆、栈数据等，它们是没有实际载体，这部分内存被称为<strong>匿名页</strong>。而且这部分内存很可能还要再次被访问，所以不能直接释放内存，于是就需要有一个能保存匿名页的磁盘载体，这个载体就是 Swap 分区</p>
<p>匿名页回收的方式是通过 Linux 的 Swap 机制，Swap 会把不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了</p>
<h4 id="有了Swap机制后就可以无上限地申请虚拟内存空间了吗"><a href="#有了Swap机制后就可以无上限地申请虚拟内存空间了吗" class="headerlink" title="有了Swap机制后就可以无上限地申请虚拟内存空间了吗?"></a>有了Swap机制后就可以无上限地申请虚拟内存空间了吗?</h4><p>岂可休，这肯定是不允许的啊!这样子的话…会坏掉的…，哪里有可能一直换下去啊，到了一定程度就会出发OOM机制了，啊当然我自己是没试过的</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的一些设计模式</title>
    <url>/2023/03/10/blog11/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=167827&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天来学习一下C++的一些设计模式，本人只学了几个，甚至于我只用过一个，但这不妨碍我去理解这些设计模式，其他的设计模式以后会慢慢补充哒，废话不多说，直接来吧!</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p><strong>设计模式(英语 design pattern)<strong>是对</strong>面向对象</strong>设计中反复出现的问题的解决方案</p>
<p>这个术语是在1990年代由Erich Gamma等人从建筑设计领域引入到计算机科学中来的。这个术语的含义还存有争议。算法不是设计模式，因为算法致力于解决问题而非设计问题。设计模式通常描述了一组相互紧密作用的类与对象。设计模式提供一种讨论软件设计的公共语言，使得熟练设计者的设计经验可以被初学者和其他设计者掌握。设计模式还为软件重构提供了目标</p>
<p>随着软件开发社群对设计模式的兴趣日益增长，已经出版了一些相关的专著，定期召开相应的研讨会，而且Ward Cunningham为此发明了WikiWiki用来交流设计模式的经验。</p>
<p><code>总之，设计模式就是为了解决某类重复出现的问题而出现的一套成功或有效的解决方案</code></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>在烂大街的WebServer项目中，我们经常利用单例模式来创建对象，<strong>日志</strong>，<strong>数据库连接池</strong>等等这种只需要一个对象的情况下，我们就可以使用<strong>单例模式</strong>来创建对象</p>
<h4 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h4><p><strong>单例模式</strong>就是指在内存中<strong>只会创建且仅创建一个对象</strong>的设计模式。当我们在程序中多次使用同一个对象且作用相同时(比如日志对象，我们总是往里面写入数据)，为了防止频繁的创建对象而使得内存飙升，我们就可以使用<strong>单例模式</strong>只创建一个对象，所有程序都是用这一个对象</p>
<h5 id="单例模式的类型"><a href="#单例模式的类型" class="headerlink" title="单例模式的类型"></a>单例模式的类型</h5><ol>
<li>懒汉模式:顾名思义，就是在程序需要使用这个对象的时候才创建</li>
<li>饿汉模式:当类加载的时候，无论该程序中是否会需要使用到该对象，都会创建，就像一个很饿的人，总是想快点吃</li>
</ol>
<h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><p>懒汉式创建对象的方法是在**程序使用对象前，先判断该对象是否已经实例化(判空)**，若已实例化直接返回该类对象，否则则先执行实例化操作</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/10/blog11/%E6%87%92%E6%B1%89.jpg" class title="懒汉">

<p>在写懒汉模式的单例时，我们需要注意以下几个点:</p>
<ol>
<li>全局只有一个实例<br><code>我们知道，在C++中，如果我们给类中的成员变量加上static关键字后，那么该成员变量就会变成全局唯一的静态变量，所有通过该类创建出来的实例都共享同一个变量，并且静态成员变量需要在类外进行初始化</code></li>
<li>将类的构造函数私有化，为的就是不让其他程序利用构造函数重新构造一个新的实例</li>
<li>静止赋值和拷贝，所以需要将默认拷贝函数也delete掉</li>
<li>用户只能通过类中的成员函数获取唯一实例，由于实例为静态成员变量，所以<strong>获取函数必须也是静态成员函数</strong>，因为只有静态成员函数才能获取静态成员变量</li>
</ol>
<p>以下是一个有缺陷但逻辑是对的<strong>懒汉模式</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//获取唯一实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> single *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> single *p;   <span class="comment">//私有静态指针变量指向唯一实例</span></span><br><span class="line">    <span class="built_in">single</span>()&#123;&#125;;         <span class="comment">//私有化构造函数</span></span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;;        <span class="comment">//私有化析构函数</span></span><br><span class="line">    single&amp; <span class="keyword">operator</span>=(<span class="type">const</span> single&amp;)=<span class="keyword">delete</span>;    <span class="comment">//进制拷贝函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">single* single::p=<span class="literal">NULL</span>; <span class="comment">//类外初始化静态变量</span></span><br><span class="line"><span class="function">single* <span class="title">single::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果实例没创建</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=<span class="keyword">new</span> <span class="built_in">single</span>();  <span class="comment">//创建实例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面的函数在单线程的时候是没有问题的，但是在多线程的时候就出现问题了，也就是老生常谈的<strong>线程安全问题</strong>，当有三个线程都掉了<strong>GetInstance函数</strong>的时候，就会创建出三个实例，这是不符合单例模式的定义的，那么如何解决这个问题呢?还是利用很经典的<strong>互斥锁</strong></p>
<p>以下是修改完的代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//获取唯一实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> single *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//互斥锁,静态锁是因为静态函数只能访问静态变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_t</span> mutex;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> single *p;   <span class="comment">//私有静态指针变量指向唯一实例</span></span><br><span class="line">    <span class="built_in">single</span>()&#123;&#125;;         <span class="comment">//私有化构造函数</span></span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;;        <span class="comment">//私有化析构函数</span></span><br><span class="line">    single&amp; <span class="keyword">operator</span>=(<span class="type">const</span> single&amp;)=<span class="keyword">delete</span>;    <span class="comment">//进制拷贝函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">single* single::p=<span class="literal">NULL</span>; <span class="comment">//类外初始化静态变量</span></span><br><span class="line"><span class="function">single* <span class="title">single::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="comment">//上锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果实例没创建</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=<span class="keyword">new</span> <span class="built_in">single</span>();  <span class="comment">//创建实例</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但是这样也有一个问题，那就是每次调用都要上锁，但事实上，只要创建好了单例，那么其余线程都会满足<strong>p&#x3D;&#x3D;NULL</strong>，所以我们再做一次更新</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//获取唯一实例</span></span><br><span class="line">    <span class="function"><span class="type">static</span> single *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//互斥锁,静态锁是因为静态函数只能访问静态变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_t</span> mutex;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> single *p;   <span class="comment">//私有静态指针变量指向唯一实例</span></span><br><span class="line">    <span class="built_in">single</span>()&#123;&#125;;         <span class="comment">//私有化构造函数</span></span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;;        <span class="comment">//私有化析构函数</span></span><br><span class="line">    single&amp; <span class="keyword">operator</span>=(<span class="type">const</span> single&amp;)=<span class="keyword">delete</span>;    <span class="comment">//进制拷贝函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">single* single::p=<span class="literal">NULL</span>; <span class="comment">//类外初始化静态变量</span></span><br><span class="line"><span class="function">single* <span class="title">single::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果实例没创建</span></span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=<span class="keyword">new</span> <span class="built_in">single</span>();  <span class="comment">//创建实例</span></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h5 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h5><p>和<strong>懒汉模式</strong>不同，<strong>懒汉模式</strong>只有在用户调用<strong>GetInstance函数</strong>的时候，才会去判断并且创建，而<strong>饿汉模式</strong>则是当我们类编译的时候，就进行单例的创建，代码如下</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">single</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> single* <span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> single *p;</span><br><span class="line">    <span class="built_in">single</span>()&#123;&#125;;</span><br><span class="line">    ~<span class="built_in">single</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">single* single::p=<span class="keyword">new</span> <span class="built_in">single</span>(); <span class="comment">//直接创建单例</span></span><br><span class="line"><span class="function">single* <span class="title">single::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><code>饿汉模式虽好，但其存在隐藏的问题，在于非静态对象(函数外的static对象)在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 GetInstance()函数会返回一个未定义的实例</code></p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>当我们在一个程序中定义了很多类的时候，如果我们频繁的去创建不同的类对象的时候骂我们需要一直new对象，这是很不利于我们后期对代码的维护的，那么有没有一种方法，就是可以自动帮我们创建类对象呢?</p>
<p>来了!它来了!<strong>工厂模式</strong>就是设计来帮我们解决这个问题的</p>
<h4 id="什么是工厂模式"><a href="#什么是工厂模式" class="headerlink" title="什么是工厂模式"></a>什么是工厂模式</h4><p>很简单，举个例子，在海贼王中存在着一个人造恶魔果实(smile果实)制造工厂,当我们想要什么样的恶魔果实，我们告诉工厂就行了，具体如何去创造就是工厂的事情了，不需要我们去关心，这就是工厂模式。利用工厂模式，我们可以不用关心对象的创作过程，我们只需要关心对象的实际操作，也就是说，<strong>工厂模式帮助我们分离了对象的创建和使用</strong>，方便后期的维护和扩展.</p>
<p>工厂模式也分为三种:</p>
<ol>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ol>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式(Simple Factory Pattern)专门定义一个类来负责创建其他类的实例，被创建的实例通常<strong>具有共同的父类</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/10/blog11/%E5%B7%A5%E5%8E%82.jpg" class title="简单工厂">
<ol>
<li>Factory工厂角色(工厂类):<br>工厂角色即工厂类，是简单工厂模式的核心，负责创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象</li>
<li>Product(抽象产品角色):<br>抽象产品角色是简单工厂模式所创建的所有对象的父类，负责描述所有实例所共有的公告接口。所创建的具体产品对象都是其子类对象</li>
<li>ConcreteProduct(具体产品角色):<br>具体产品角色是简单工厂模式的创建目标。每个具体产品角色都继承了抽象产品角色，需要实现定义在抽象产品中的方法<br><code>ProductA、ProductB和ProductC继承自Product虚拟类，Show方法是不同产品的自描述；Factory依赖于ProductA、ProductB和ProductC，Factory根据不同的条件创建不同的Product对象</code><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>简单工厂的实现 </summary>
              <div class="content">
              <p>我们以电视机的栗子来说吧<br>有一个工厂，它专门就是用来生产电视机的，但我们知道，电视机有很多牌子，不同的牌子价格和质量也是不同的<br>如下图所示:<br><img lazyload src="/images/loading.svg" data-src="/2023/03/10/blog11/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.jpg" class title="简单工厂"></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">ProductTypeTag</span></span><br><span class="line">&#123;</span><br><span class="line">  Hair,</span><br><span class="line">  Hisense,</span><br><span class="line">&#125;PRODUCTTYPE;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//抽象产品类 TV(电视机类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">TV</span>()&#123;&#125;;<span class="comment">//声明析构函数为虚函数，防止内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">//具体产品类 HairTV(海尔电视类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HairTV</span> : <span class="keyword">public</span> TV</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;I&#x27;m HairTV &quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">//具体产品类 HisenseTV(海信电视类)  </span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">HisenseTV</span> : <span class="keyword">public</span> TV</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;I&#x27;m HisenseTV&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 工厂类 TVFactory(电视机工厂类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TVFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">TV* <span class="title">CreateTV</span><span class="params">(PRODUCTTYPE type)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (type)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> Hair:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HairTV</span>();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">case</span> Hisense:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HisenseTV</span>();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建工厂类对象</span></span><br><span class="line">    TVFactory* myTVFactory = <span class="keyword">new</span>  <span class="built_in">TVFactory</span>();</span><br><span class="line">    TV* hairTV = myTVFactory-&gt;<span class="built_in">CreateTV</span>(Hair);</span><br><span class="line">    <span class="keyword">if</span> (hairTV != <span class="literal">NULL</span>)</span><br><span class="line">        hairTV-&gt;<span class="built_in">Show</span>();</span><br><span class="line"> </span><br><span class="line">    TV* hisenseTV = myTVFactory-&gt;<span class="built_in">CreateTV</span>(Hisense);</span><br><span class="line">    <span class="keyword">if</span> (hisenseTV != <span class="literal">NULL</span>)</span><br><span class="line">        hisenseTV-&gt;<span class="built_in">Show</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span>  myTVFactory;</span><br><span class="line">    myTVFactory = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> hairTV;</span><br><span class="line">    hairTV = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">delete</span> hisenseTV;</span><br><span class="line">    hisenseTV = <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details></li>
</ol>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优势 </summary>
              <div class="content">
              <p>本着高内聚低耦合的原则，将系统的逻辑部分和功能分开</p>
              </div>
            </details>

<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>劣势 </summary>
              <div class="content">
              <p>就拿上面的栗子来说吧，当我们想要生产<strong>派大星牌电视机</strong>的时候，我们就需要在工厂里面加入对<strong>派大星牌电视机</strong>的生产，但其实这就违背了我们设计模式中的一个<strong>开闭原则</strong></p><p>开闭原则:</p><ol><li>开放封闭原则(OCP,Open For Extension, Closed For Modification Principle)</li><li>类的改动是通过增加代码进行的，而不是修改源代码</li><li>说的是代码扩展性问题——对扩展开放，对修改关闭（封闭）</li></ol><p>开闭原则详细的解释：当增加新功能，<strong>不应该通过修改已经存在的代码来进行</strong>，而是应该通过扩展代码(比如增加新类，增加新成员函数)来进行</p><p>而当我们增加一个新的类时候，就需要对已经存在的工厂代码进行修改，而这就违背了这个原则</p>
              </div>
            </details>

<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>既然<strong>简单工厂</strong>模式违背了<strong>开闭原则</strong>，那么我们就在它的基础上做一些修改，使得改模式<strong>即保留了简单工厂模式的优点，又解决了它的缺点</strong>，而这，就是<strong>工厂方法模式</strong></p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>工厂方法模式 </summary>
              <div class="content">
              <p>在工厂模式中，工厂父类负责定义创建产品对象的公告接口，而工厂子类负责生成具体的产品对象。<br>目的是将产品的实例化操作延迟到工厂子类中完成，通过工厂子类来确定究竟应该实例化哪一个具体产品类</p>
              </div>
            </details>
<img lazyload src="/images/loading.svg" data-src="/2023/03/10/blog11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.jpg" class title="工厂模式">

<ol>
<li><p>Product(抽象产品)<br>抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，也是产品对象的共同父类或接口</p>
</li>
<li><p>ConcreteProduct(具体产品)<br>具体产品实现了抽象产品的接口，某种类型的具体产品由专门的具体工厂创建</p>
</li>
<li><p>Factory(抽象工厂)</p>
</li>
<li><p>ConcreteFactory(具体工厂)</p>
</li>
</ol>
<p>具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>简单工厂的实现 </summary>
              <div class="content">
              <p>还是继续上面的栗子<br>工厂方法模式，将原有的工厂进行分割，为每种品牌的电视机提供一个子工厂，海尔工厂专门负责生产海尔电视机，海信工厂专门负责生产海信电视机，若增加派大星电视，只需要增加一个新的派大星工厂</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img 工厂模式<span class="number">1.</span>jpg 工厂模式 %&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品类 TV(电视机类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TV</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">TV</span>()&#123;&#125;;<span class="comment">//声明析构函数为虚函数，防止内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">//具体产品类 HairTV(海尔电视类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HairTV</span> : <span class="keyword">public</span> TV</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;I&#x27;m HairTV &quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">//具体产品类 HisenseTV(海信电视类)  </span></span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">HisenseTV</span> : <span class="keyword">public</span> TV</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;I&#x27;m HisenseTV&quot;</span>&lt;&lt;endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂类 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TVFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> TV *<span class="title">Create</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">TVFactory</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂类 海尔电视子工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HairFactory</span>::<span class="keyword">public</span> TVFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TV *<span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HairTV</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂类 海信电视子工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HisenseFactory</span>::<span class="keyword">public</span> TVFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TV* <span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HisenseFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc , <span class="type">char</span> *argv [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TVFactory *hairTVFactory = <span class="keyword">new</span> <span class="built_in">HairTVFactory</span>();</span><br><span class="line">  TV *hairTV = hairTVFactory-&gt;<span class="built_in">CreateTV</span>();</span><br><span class="line">  hairTV-&gt;<span class="built_in">Show</span>();</span><br><span class="line">  </span><br><span class="line">  TVFactory *hisenseTVFactory = <span class="keyword">new</span> <span class="built_in">HisenseTVFactory</span>();</span><br><span class="line">  TV *hisenseTV = hisenseTVFactory-&gt;<span class="built_in">CreateTV</span>();</span><br><span class="line">  hisenseTV-&gt;<span class="built_in">Show</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (hairTVFactory!= <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> hairTVFactory;</span><br><span class="line">    hairTVFactory = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (hairTV != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> hairTV;</span><br><span class="line">    hairTV = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (hisenseTVFactory != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> hisenseTVFactory;</span><br><span class="line">    hisenseTVFactory = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (hisenseTV != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> hisenseTV;</span><br><span class="line">    hisenseTV = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>当我们想要生产派大星电视机的时候，只需要加一个工厂和一个具体的派大星电视机类就好，而无需在原本的代码上进行修改</p>
              </div>
            </details>

<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>抽象工厂模式是工厂方法模式的泛化版，工厂模式是一种特殊的抽象工厂模式，在工厂模式中，每个具体工厂只能生产一种具体的产品，如海尔电视机厂只生产海尔电视机，而抽象工厂方法模式中，一个具体的工厂可以生产多个具体产品</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/10/blog11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.jpg" class title="抽象工厂">
<ol>
<li>AbstractFactory(抽象工厂)<br>抽象工厂用于声明生成抽象产品的方法，在一个抽象工厂中可以定义一组方法，每一个方法对应一个产品等级结构</li>
<li>ConcreteFactory(具体工厂)<br>具体工厂实现了抽象工厂声明的抽象产品的方法，生成一组具体产品</li>
<li>AbstractProduct(抽象产品)<br>抽象产品为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法</li>
<li>ConcreteProdunct(具体产品)<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>抽象工厂实现 </summary>
              <div class="content">
              <p>还是上面的栗子，我们知道，海尔公司不光生产电视，它还生产空调之类的，tcl也是<br><img lazyload src="/images/loading.svg" data-src="/2023/03/10/blog11/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%821.jpg" class title="抽象工厂"></p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 抽象产品类类 Television(电视机类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Television</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Television</span>()&#123;&#125;;<span class="comment">//析构函数声明为虚函数，防止内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//具体产品类 HaierTelevision（海尔电视机类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HaierTelevision</span> : <span class="keyword">public</span> Television</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m HaierTelevision&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体产品类 TCLTelevision（TCL电视机类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCLTelevision</span> : <span class="keyword">public</span> Television</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m TCLTelevision&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 抽象产品类  AirCondition（空调类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AirCondition</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">AirCondition</span>()&#123;&#125;;<span class="comment">//析构函数声明为虚函数，防止内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体产品类 HairAirCondition(海尔空调类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HairAirCondition</span> : <span class="keyword">public</span> AirCondition</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m HairAirCondition&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体产品类 TCLAirCondition(TCL空调类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCLAirCondition</span> : <span class="keyword">public</span> AirCondition</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I&#x27;m TCLAirCondition&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 抽象工厂类 EFactory(电器工厂类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EFactory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Television* <span class="title">CreateTelevision</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> AirCondition* <span class="title">CreateAirCondition</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">virtual</span> ~<span class="built_in">EFactory</span>()&#123;&#125;;<span class="comment">//析构函数声明为虚函数，防止内存泄漏</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体工厂类 HairFactory(海尔工厂类)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HairFactory</span> : <span class="keyword">public</span> EFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Television* <span class="title">CreateTelevision</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HaierTelevision</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">AirCondition* <span class="title">CreateAirCondition</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">HairAirCondition</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体工厂类 TCLFactory(TCL工厂类) </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TCLFactory</span> : <span class="keyword">public</span> EFactory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Television* <span class="title">CreateTelevision</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TCLTelevision</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">AirCondition* <span class="title">CreateAirCondition</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TCLAirCondition</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  EFactory *hairFactory = <span class="keyword">new</span> <span class="built_in">HairFactory</span> ();<span class="comment">/*实例化工厂抽象类*/</span></span><br><span class="line">  Television *haierTelevision =hairFactory-&gt;<span class="built_in">CreateTelevision</span>();<span class="comment">/*实例化产品抽象类*/</span></span><br><span class="line">  AirCondition *haierAirCondition = hairFactory-&gt;<span class="built_in">CreateAirCondition</span>();</span><br><span class="line">  </span><br><span class="line">  haierTelevision-&gt;<span class="built_in">Show</span>();</span><br><span class="line">  haierAirCondition-&gt;<span class="built_in">Show</span>();</span><br><span class="line">  </span><br><span class="line">  EFactory *tCLFactory = <span class="keyword">new</span> <span class="built_in">TCLFactory</span> ();</span><br><span class="line">  Television *tCLTelevision = tCLFactory-&gt;<span class="built_in">CreateTelevision</span>();</span><br><span class="line">  AirCondition *tCLAirCondition = tCLFactory-&gt;<span class="built_in">CreateAirCondition</span>();</span><br><span class="line">  </span><br><span class="line">  tCLTelevision-&gt;<span class="built_in">Show</span>();</span><br><span class="line">  tCLAirCondition-&gt;<span class="built_in">Show</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (hairFactory != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> hairFactory;</span><br><span class="line">    hairFactory = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (haierTelevision != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> haierTelevision;</span><br><span class="line">    haierTelevision= <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (tCLAirCondition != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> tCLAirCondition;</span><br><span class="line">    tCLAirCondition = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (tCLFactory != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> tCLFactory;</span><br><span class="line">    tCLFactory= <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (tCLTelevision != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> tCLTelevision;</span><br><span class="line">    tCLTelevision = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (tCLAirCondition != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">delete</span> tCLAirCondition;</span><br><span class="line">    tCLAirCondition = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details></li>
</ol>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优点 </summary>
              <div class="content">
              <ol><li>抽象工厂模式将产品族的依赖与约束关系放到抽象工厂中，便于管理</li><li>职责解耦，用户不需要关心一堆自己不关心的细节，由抽象工厂来负责组件的创建</li><li>切换产品族容易，只需要增加一个具体工厂实现，客户端选择另一个套餐就可以了</li></ol>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优点 </summary>
              <div class="content">
              <ol><li>抽象工厂模式类增加的速度很快，有一个产品族就需要增加一个具体工厂实现，比较繁琐</li><li>产品族难以扩展产品。当产品族中增加一个产品时，抽象工厂接口中需要增加一个函数，对应的所有具体工厂实现都需要修改，修改放大严重</li><li>抽象工厂并未完全屏蔽创建细节，给出的都是组件。对于这种情况可以结合工厂模式或简单工厂模式一起使用</li></ol>
              </div>
            </details>

<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><code>观察者模式又叫做发布-订阅模式</code><br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。<br>这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动的更新自己。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/10/blog11/%E8%A7%82%E5%AF%9F%E8%80%85.jpg" class title="观察者">

<p>或许观看以下实例或更清楚点(结构上图)</p>
<details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>观察者模式的实现 </summary>
              <div class="content">
              <details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Head.h </summary>              <div class="content">              <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAD_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEAD_H</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象观察者，为所有的具体观察者定义一个接口，在当主题更新的时候更新自己</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对所有观察者的集合，每一个主题都可以有很多个观察者，利用list双向链表将观察者保存起来，方便后面的更新</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Subject</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">attach</span><span class="params">(Observer *observer)</span></span>;    <span class="comment">//加入新的观察者</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">detach</span><span class="params">(Observer *observer)</span></span>;    <span class="comment">//删除观察者</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span></span>;                      <span class="comment">//调用该函数，可以开始对list里面的每个观察者进行更新操作，但这个函数并不直接更新数据，只起到了一个通知作用，真正用来更新数据的函数在观察者自己的类中</span></span><br><span class="line">	~<span class="built_in">Subject</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	list&lt;Observer*&gt; observers;          <span class="comment">//双向链表，存储观察者</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Observer</span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;&#125;                 <span class="comment">//抽象更新函数，具体实现由具体观察者来实现</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> string <span class="title">getName</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; &#125;  <span class="comment">//获取具体观察者的名字，为抽象函数，在具体观察者实现</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体主题</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> : <span class="keyword">public</span> Subject&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">string <span class="title">getSubjectState</span><span class="params">()</span></span>;                   <span class="comment">//获取具体主题的状态</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">setSubjectState</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span>;    <span class="comment">//将有关状态存入具体观察者对象，当具体主题的状态发生改变的时候，通知所有登记过的观察者</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string subjectState;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//具体观察者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteObserver</span> : <span class="keyword">public</span> Observer&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">ConcreteObserver</span>(ConcreteSubject *subject, string name); </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">()</span></span>;                              <span class="comment">//更新操作</span></span><br><span class="line">	<span class="function">string <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	string name;                <span class="comment">//观察者名字</span></span><br><span class="line">	string observerState;       <span class="comment">//观察者状态</span></span><br><span class="line">	ConcreteSubject *subject;   <span class="comment">//观察者对应的具体主题</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//HEAD_H</span></span></span><br></pre></td></tr></table></figure></div>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Head.cpp </summary>              <div class="content">              <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Head.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//将观察者插入观察者队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Subject::attach</span><span class="params">(Observer *observer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	observers.<span class="built_in">push_back</span>(observer);      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从观察者队列中删除观察者</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Subject::detach</span><span class="params">(Observer *observer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	observers.<span class="built_in">remove</span>(observer);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Subject::notify</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list&lt;Observer*&gt;::iterator it = observers.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">//循环队列里的观察者，并让他们执行更新操作</span></span><br><span class="line">	<span class="keyword">while</span>(it != observers.<span class="built_in">end</span>())&#123;</span><br><span class="line"> </span><br><span class="line">		(*it)-&gt;<span class="built_in">update</span>();</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Subject::~<span class="built_in">Subject</span>()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;开始析构了&quot;</span> &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	list&lt;Observer*&gt;::iterator it = observers.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">while</span>(it != observers.<span class="built_in">end</span>())&#123;</span><br><span class="line"> </span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;开始删除: &quot;</span> &lt;&lt; (*it)-&gt;<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">delete</span> *it;</span><br><span class="line">		it++;</span><br><span class="line">	&#125;</span><br><span class="line">	observers.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取主题当前状态</span></span><br><span class="line"><span class="function">std::string <span class="title">ConcreteSubject::getSubjectState</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> subjectState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置主题状态</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteSubject::setSubjectState</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	subjectState = str;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">ConcreteObserver::<span class="built_in">ConcreteObserver</span>(ConcreteSubject *subject, string name)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">this</span>-&gt;subject = subject;</span><br><span class="line">	<span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//观察者更新操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcreteObserver::update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	observerState = subject-&gt;<span class="built_in">getSubjectState</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;发布者更新东西了 ！！！ 订阅者：&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;  状态：&quot;</span> &lt;&lt; observerState &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">std::string <span class="title">ConcreteObserver::getName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>main.cpp </summary>              <div class="content">              <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Head.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> *argc, <span class="type">int</span> *argv[])</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">	ConcreteSubject *subject = <span class="keyword">new</span> ConcreteSubject;</span><br><span class="line"> </span><br><span class="line">	subject-&gt;<span class="built_in">attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(subject, <span class="string">&quot;第一个粉丝&quot;</span>));</span><br><span class="line">	subject-&gt;<span class="built_in">attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(subject, <span class="string">&quot;第二个粉丝&quot;</span>));</span><br><span class="line">	subject-&gt;<span class="built_in">attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(subject, <span class="string">&quot;第三个粉丝&quot;</span>));</span><br><span class="line"> </span><br><span class="line">	subject-&gt;<span class="built_in">setSubjectState</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">	subject-&gt;<span class="built_in">notify</span>();</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;----------- 华 丽 的 分 割 线 -----------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	subject-&gt;<span class="built_in">attach</span>(<span class="keyword">new</span> <span class="built_in">ConcreteObserver</span>(subject, <span class="string">&quot;王二麻子&quot;</span>));</span><br><span class="line">	subject-&gt;<span class="built_in">setSubjectState</span>(<span class="string">&quot;呵呵&quot;</span>);</span><br><span class="line">	subject-&gt;<span class="built_in">notify</span>();</span><br><span class="line"> </span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">delete</span> subject;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>              </div>            </details>
              </div>
            </details>

<ol>
<li>服务器发布新版本，让客户端更新</li>
<li>游戏群发邮件给补贴等</li>
<li>聊天室系统</li>
</ol>
<p>都可以很好的套用这种模式</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>鼠鼠终于!终于又收到了一个面试!虽然不是大厂的，但聊胜于无啊，希望今晚能顺利叭，写完了这篇博客就要看八股去咯，祝好运~</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络模型及各层的作用和主要协议</title>
    <url>/2023/03/15/blog12/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=202373&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>终于把操作系统的一些简单知识点看完了，虽然我不敢说自己操作系统这方面有多怎么怎么样，但至少比起一个月前的我好了太多了，以后慢慢补充遇到的一些OS的问题叭，从这篇blog开始，就开始我的<strong>计算机网络</strong>的学习叭，其实我感觉我对<strong>计算机网络</strong>的掌握程度还是不错的，毕竟有学过这门课，自我感觉还ok，但这次学习是更加细致，更加准确地去<strong>理解</strong>它，为了能在面试中对答如流，继续加油!</p>
<h3 id="计算机网络模型"><a href="#计算机网络模型" class="headerlink" title="计算机网络模型"></a>计算机网络模型</h3><p>在了解计算机网络模型之前，我们需要知道为什么会要分层？</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>计算机网络分层的优点 </summary>
              <div class="content">
              <ol><li><strong>各层之间是独立的</strong>。某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道该层通过层间的接口(即界面)所提供的服务。由于每一层只实现一种相对独立的功能，因而可将<strong>一个难以处理的复杂问题</strong>分解为<strong>若干个较容易处理的更小一些的问题</strong>。这样，整个问题的复杂程度就下降了</li><li><strong>灵活性好</strong>。当任何一层发生变化时(例如由于技术的变化)，只要层间接口关系保持不变，则在这层以上或以下各层均不受影响。此外，对某一层提供的服务还可进行修改。</li><li><strong>当某层提供的服务不再需要时，甚至可以将这层取消</strong>。</li><li><strong>结构上可分割开</strong>。各层都可以采用最合适的技术来实现。</li><li><strong>易于实现和维护</strong>。这种结构使得实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统。</li><li><strong>能促进标准化工作</strong>。因为每一层的功能及其所提供的服务都已有了精确的说明</li></ol><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>分层应注意的点 </summary>              <div class="content">              <ol><li>分层时应该注意<strong>使每一层的功能非常明确</strong></li><li>分层时应注意分层数量，若层数太少，就会使得每一层的协议太过复杂；若层数太多，又会在描述和综合各层功能的系统工程任务时遇到较多的困难</li></ol>              </div>            </details>
              </div>
            </details>

<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>计算机网络分层的缺点 </summary>
              <div class="content">
              <p>有些功能会在不同的层次中重复出现，因而产生了额外开销</p>
              </div>
            </details>

<p>常见的几个计算机网络模型:</p>
<ol>
<li>OSI七层参考模型</li>
<li>五层模型</li>
<li>TCP&#x2F;IP四层模型</li>
</ol>
<p>接下来简单介绍一下他们的区别</p>
<h4 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h4><p><strong>OSI七层参考模型</strong>即<strong>开放式系统互联</strong>。参考模型时国际标准化组织(OSI)制定的一个用于计算机或通信系统间互联的标准体系，一般称为<strong>OSI七层参考模型</strong>或者<strong>七层模型</strong>，它是一个七层扽，抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的一些协议</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/15/blog12/OSI.jpg" class title="OSI">
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>每一层具体的作用(从下往上) </summary>
              <div class="content">
              <ol><li>物理层:主要定义物理设备标准，如<code>网线的接口类型</code>等，主要作用是<strong>传输比特流(由0，1转化为强电流和弱电流来进行传输，达到目的地后转化为1，0)<strong>，这一层的数据叫做</strong>比特</strong></li><li>数据链路层:建立逻辑链接，进行<strong>硬件地址(MAC地址)<strong>的寻址，差错校验等功能。定义了<code>如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问</code>。将</strong>比特</strong>组合成<strong>字节</strong>进而组合成<strong>帧</strong>，用<strong>MAC</strong>地址访问介质<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>MAC地址 </summary>           <div class="content">           <p>在了解MAC地址前，我们先需要知道一个大家耳熟能详的东西，<strong>网卡</strong></p><details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>网卡 </summary>              <div class="content">              <p><code>网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件</code>，又被称为<strong>网络适配器</strong>或者<strong>网络接口卡</strong>。其拥有<strong>MAC地址</strong>，属于OSI模型的<strong>第二层，数据链路层</strong>，它使得用户可以通过电缆或无线相互连接。每个网卡都有一个被称为<strong>MAC地址</strong>的<strong>独一无二</strong>的48位串行号</p><p>网卡的主要功能:</p><ol><li>数据的封装与解封装</li><li>链路管理</li><li>数据编码和译码</li></ol>              </div>            </details><p>在知道了网卡是什么后，再来看MAC地址。</p><p>MAC地址全称(Media Access Control Address),也称为<strong>局域网地址</strong>，<strong>以太网地址</strong>，<strong>物理地址</strong>或者<strong>硬件地址</strong>，是一个用来确认网络设备位置的地址。在OSI模型中，<strong>第三层网络层负责IP地址，第二层数据链路层则负责MAC地址</strong>，一台设备若有多个网卡，则每个网卡都<strong>需要并会有一个唯一的MAC地址</strong>。只要不更改自己的MAC地址，MAC地址在世界上就是<strong>唯一的</strong><br><code>形象地说，MAC地址就如同身份证上的身份证号码，具有唯一性</code></p>           </div>         </details></li></ol><ol start="3"><li><p>网络层:进行**逻辑地址(IP地址)**寻址，在位于不同地理位置的网络中地两个主机系统之间提供连接和路径选择</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>IP </summary>              <div class="content">              <details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>协议 </summary>              <div class="content">              <p>在生活中，我们也能随处可见「协议」，例如:<br>    1. 刚毕业时会签一个「三方协议」<br>    2. 找房子时会签一个「租房协议」<br><img lazyload src="/images/loading.svg" data-src="/2023/03/15/blog12/%E5%8D%8F%E8%AE%AE1.jpg" class title="协议1"></p><p>生活中的协议，本质上与计算机中的协议是相同的，协议的特点:<br>1.「协」字，代表的意思是必须有两个以上的参与者。例如三方协议里的参与者有三个:你、公司、学校三个;租房协议里的参与者有两个:你和房东<br>2.「仪」字，代表的意思是对参与者的一种行为约定和规范。例如三方协议里规定试用期期限、毁约金等;租房协议里规定租期期限、每月租金金额、违约如何处理等</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>IP协议 </summary>              <div class="content">              <p><strong>IP协议</strong>是为计算机网络相互连接进行通信而设计地协议，<code>在因特网上，它是能使连接到网上的所有计算机网络实现相互通信的一套规则</code>，规定了计算机在因特网上进行通信时应当遵守的规则。</p><p>IP协议实际上是一套由<strong>软件程序</strong>组成的协议软件，它把<strong>各种不同的帧(不同的厂家生产的网络系统和设备所传输的数据的基本单位的不同)<strong>统一转化位</strong>IP数据报</strong>格式，这种转换时因特网的一个<strong>最重要</strong>的特点，使得所有各种机器都能在因特网上相互通信，<strong>即具有”开放性”的特点</strong>。因此，IP协议也可以叫做<strong>因特网协议</strong></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>IP地址 </summary>              <div class="content">              <p><strong>IP地址</strong>是指<strong>互联网协议地址</strong>，又称为<strong>网络协议地址</strong>。IP地址是IP协议提供的一种统一的地址格式，**它为互联网上的每一个网络和每一台主机分配一个逻辑地址(不是真实的)**，以此来屏蔽物理地址(MAC地址)的差异</p><p>IP地址是一个<strong>32位</strong>的二进制数(4个字节)，通常被分割为4个<strong>8位二进制数</strong></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>IP地址编码方式 </summary>              <div class="content">              <p>IP地址包括两个标识码:<strong>网络ID和主机ID</strong><br>同一个网络上的所有主机都使用同一个网络ID，网络上的主机(包括网络上的工作站，服务器和路由器等等)都有一个主机ID与之对应</p><ol><li>A类IP地址:IP四段号码中，第一段为网络号，其他三段号码为主机号(一般用在广域网)，例如IP:192.168.149.129，其中192就是网络号</li><li>B类IP地址:IP地址四段号码中，前俩段为网络号，剩余两端为主机号(一般用于中规模的网络)</li><li>C类IP地址:IP地址四段号码中，前三段为网络号，剩余最后一段为主机号(一般用于局域网)</li></ol>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>特殊地网址 </summary>              <div class="content">              <ol><li>每个字节都为0的地址(0.0.0.0)对应于当前的主机</li><li>IP地址中的为个字节都为1(255.255.255.255)是当前子网的广播地址</li><li>IP地址中凡是以”11110”开头的E类IP地址都将保留用于将来和实验使用</li><li>IP地址不能以十进制”127”作为开头，该类地址中，数字127.0.0.1到127.255.255.255用于回路测试，如”127.0.0.1”可以代表本地IP地址</li></ol>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>子网掩码 </summary>              <div class="content">              <p>又叫做<strong>网络掩码，地址掩码，子网络遮罩</strong>，它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网，以及哪些标识的是主机的位掩码<br>它的唯一作用就是将IP地址分为网络号和主机号，并说明该IP地址是在局域网上还是广域网上(<strong>子网掩码与IP地址相与</strong>)</p>              </div>            </details>              </div>            </details></li><li><p>运输层:定义了一些传输数据的协议和端口号，如:TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，UDP(用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，例如QQ聊天数据就是通过这种方式传输的)。主要是将从下层接受的数据进行分段和传输，达到目的地址后再进行重组。常常把这一层数据叫做段</p></li></ol><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>端口 </summary>              <div class="content">              <p>分为<strong>虚拟端口</strong>和<strong>物理端口</strong>，可以认为是设备与外界通讯交流的出口<br>虚拟端口:指计算机内部或者交换机，路由器内的端口，是不可见的，是指TCP&#x2F;IP协议中的端口，是<strong>逻辑意义上的端口</strong>，例如计算机中的80端口，21端口等等，<strong>如果把IP地址比作一个房间的话，那么端口就是这个房间的门</strong>，一个IP地址可以用2^16个端口</p><p>端口是由<strong>端口号</strong>来标记的，范围是<strong>0~2^16-1</strong>，每个端口拥有唯一的端口号，用于标识进程(不用进程号的原因是因为<strong>应用程序每次执行的进程号都不同</strong>)</p>              </div>            </details><ol start="5"><li>会话层:通过传输层建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求</li><li>表示层:数据的表示、安全、压缩。主要是进行对接受的数据进行解释、加密与解密、压缩与解压缩等(<strong>也就是把计算机能够识别的东西转换成人能够识别的东西，例如图像、声音等</strong>)</li><li>应用层:网络服务与最终用户的一个接口。这一层为用户的应用程序提供网络服务</li></ol>
              </div>
            </details>


<h4 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h4><p>OSI七层模型其实并不常用，现在常见的都是五层模型，又或者是TCP&#x2F;IP四层模型</p>

<p>与OSI七层模型相比，就是将<strong>应用层、表示层、会话层</strong>都合在一起为<strong>应用层</strong></p>
<h4 id="TCP-x2F-IP四层模型"><a href="#TCP-x2F-IP四层模型" class="headerlink" title="TCP&#x2F;IP四层模型"></a>TCP&#x2F;IP四层模型</h4><img lazyload src="/images/loading.svg" data-src="/2023/03/15/blog12/%E5%9B%9B%E5%B1%82.jpg" class title="四层">

<ol>
<li><p>应用层:应用层是TCP&#x2F;IP协议的第一层，是直接为应用进程提供服务的</p>
<ol>
<li>对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用了SMTP协议、万维网应用使用了HTTP协议、远程登录服务应用使用了有TELNET协议</li>
<li>应用层还能加密、解密、格式化数据</li>
<li>应用层可以建立或解除与其他节点的联系，这样可以充分节省网络资源</li>
</ol>
</li>
<li><p>传输层:作为TCP&#x2F;IP协议的第二层，传输层在整个TCP&#x2F;IP协议中起到了中流砥柱的作用。且在传输层中，TCP和UDP也同样起到了中流砥柱的作用</p>
</li>
<li><p>网络层:网络层在TCP&#x2F;IP协议中的位于第三层。在TCP&#x2F;IP协议中网络层可以进行网络连接的建立和终止以及IP地址的寻找等功能</p>
</li>
<li><p>数据链路层:在TCP&#x2F;IP协议中，数据链路层位于第四层。由于数据链路层兼并了物理层和数据链路层所以，数据链路层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路</p>
</li>
</ol>
<p><code>TCP/IP四层模型相比于OSI七层模型而言，更加简单高效，而且成本更低</code></p>
<h3 id="TCP-x2F-IP四层中的协议"><a href="#TCP-x2F-IP四层中的协议" class="headerlink" title="TCP&#x2F;IP四层中的协议"></a>TCP&#x2F;IP四层中的协议</h3><img lazyload src="/images/loading.svg" data-src="/2023/03/15/blog12/%E5%8D%8F%E8%AE%AE.jpg" class title="协议">
<ol>
<li>应用层常见协议:FTP(文件传输协议)、HTTP(超文本传输协议)、NFS(网络文件传输协议)、DNS(域名解析协议)</li>
<li>运输层常见协议:TCP(传输控制协议)、UDP(用户数据报协议)</li>
<li>网络层常见协议:IP(因特网互联协议)、ICMP(因特网控制报文协议)、IGMP(因特网管理协议)、ARP(地址解析协议)、RARP(反向地址解析)<br> 如果实在OSI七层模型中，RAP协议和RARP协议都属于数据链路层</li>
<li>网络接口层常见协议:PDN</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>鼠鼠接下来会按照分层结构来梳理每个协议的一些知识点和常见面试问题，继续加油叭</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层相关协议</title>
    <url>/2023/03/16/blog13/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=16435049&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于应用层，协议有很多，但比较需要知道的，在我看来就俩个，HTTP和DNS协议，这篇文章就来介绍一下这俩协议叭，特别是HTTP协议，需要特别牢记</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>网络服务与最终用户的一个接口。这一层为用户的应用程序提供网络服务<br>应用层协议:HTTP(超文本传输协议)、DNS(域名解析协议)、SMTP(电子邮件传输协议)、FTP(文件上传协议)<br>这里就讲一下DNS和HTTP吧，<strong>HTTP超级重要!</strong></p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="什么是DNS"><a href="#什么是DNS" class="headerlink" title="什么是DNS"></a>什么是DNS</h3><p>DNS又叫做域名解析协议<br>域名: </p>
<ol>
<li>域名是一种帮助用户在互联网上寻找路径的为数不多识别码。就比如您的电话号码，您的客户可以通过电话号码联系到你。同样的，您的客户也可以通过域名访问您的企业网站寻找到您。简单来说，域名就是您在网络上的电话号码，例如:<code>www.baidu.com</code>就是一个域名，当我们在浏览器输入这个域名后，就可以获取该域名对应的服务器上的资源了</li>
<li>DNS中的域名都是用句点来分隔的,比如<code>www.baidu.com</code>,这里的句点代表了不同层次之间的界限,在域名中,越靠右的位置表示其层级越高</li>
</ol>
<p><code>域名又可以被称为URL</code></p>
<ol>
<li>通常，识别主机的两种方式为:<ol>
<li>通过主机名，也就是域名(<a class="link" href="http://www.baidu.com/">www.baidu.com <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)</li>
<li>通过IP地址<br><code>主机名方便人们记忆，IP地址的定长性和层次结构有利于路由识别</code></li>
</ol>
</li>
<li>为了同时满足上述两种需求，我们需要进行<strong>主机名</strong>到<strong>IP地址</strong>的转换，也就是<strong>将主机名映射为IP地址</strong><br><code>DNS则是提供主机名到IP地址的映射服务</code></li>
<li>DNS是一个由分层的DNS服务器实现的<strong>分布式数据库</strong><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>分布式层次式数据库 </summary>
              <div class="content">
              <p>分布式:指DNS服务器分布在全世界<br>层次式:指DNS服务器是按照层次方式组织的，按层次可以将DNS服务器分为三类</p><ol><li>根DNS服务器</li><li>顶级域DNS服务器</li><li>权威DNS服务器<br><code>根DNS服务器在最顶层，下一层为顶级域，最后是权威</code></li></ol><p>例如<code>www.baidu.com</code>中,<code>com</code>就是顶级域DNS服务器，<code>baidu</code>就是权威DNS服务器，<code>www</code>代表万维网<br><img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/DNS.jpg" class title="DNS"><br>根域的 DNS 服务器信息保存在互联网中所有的DNS服务器中，这样一来，任何DNS服务器就都可以找到并访问根DNS服务器了</p>
              </div>
            </details></li>
<li>DNS协议是一个使得主机能够查询分布式数据库的<strong>应用层协议</strong></li>
</ol>
<h3 id="DNS域名解析的工作流程"><a href="#DNS域名解析的工作流程" class="headerlink" title="DNS域名解析的工作流程"></a>DNS域名解析的工作流程</h3><p>DNS域名解析有两种方式:</p>
<ol>
<li>迭代查询</li>
<li>递归查询<br>接下来以主机为(Cis.ploy.edu)解析<code>www.baidu.com</code>获取其IP地址为例<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>迭代查询 </summary>
              <div class="content">
              <ol><li>首先,主机名为(Cis.ploy.edu)的主机向<strong>本地DNS服务器</strong>发送一个包含了(Cis.ploy.edu)主机名的DNS请求报文</li><li><strong>本地DNS服务器</strong>先查看自己有无对应的映射，如果有就直接返回，没有就执行下面的操作</li><li>本地DNS服务器将请求报文转发到<strong>根DNS服务器</strong></li><li><strong>根DNS服务器</strong>根据域名的最后一位(本例子中为com,还有其他的后缀例如cn,edu等等，这里不多说)向本地DNS服务器返回<strong>负责com的顶级域DNS服务器的IP地址列表</strong></li><li><strong>本地DNS服务器</strong>收到回应报文后，就会向<strong>顶级域DNS服务器</strong>IP地址之一发送查询报文</li><li><strong>顶级域DNS服务器</strong>根据<code>baidu.com</code>返回一个<strong>权威DNS服务器</strong>的IP地址给<strong>本地DNS服务器</strong></li><li><strong>本地DNS服务器</strong>根据返回的<strong>权威DNS服务器</strong>IP地址，发送查询报文</li><li><strong>权威DNS服务器</strong>接收到查询报文后，将<code>www.baidu.com</code>的IP地址作为响应发回给<strong>本地DNS服务器</strong></li><li><strong>本地DNS服务器</strong>将该映射记录在自己的缓存表后，将该IP地址返回给主机</li></ol>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>递归查询 </summary>
              <div class="content">
              <ol><li>首先,主机名为(Cis.ploy.edu)的主机向<strong>本地DNS服务器</strong>发送一个包含了(Cis.ploy.edu)主机名的DNS请求报文</li><li><strong>本地DNS服务器</strong>先查看自己有无对应的映射，如果有就直接返回，没有就执行下面的操作</li><li>本地DNS服务器将请求报文转发到<strong>根DNS服务器</strong></li><li><strong>根DNS服务器</strong>根据最后一位后缀(com)，向对应的<strong>顶级域DNS服务器</strong>发送查询报文</li><li><strong>顶级域DNS服务器</strong>又向<strong>权威DNS服务器</strong>发送查询报文</li><li><strong>权威DNS服务器</strong>将查询结果(IP地址)返回给<strong>顶级域DNS服务器</strong></li><li><strong>顶级域DNS服务器</strong>将接收到的响应报文转发给<strong>根DNS服务器</strong></li><li><strong>根DNS服务器</strong>将收到的响应报文转发给<strong>本地DNS服务器</strong></li><li><strong>本地DNS服务器</strong>将该映射记录在自己的缓存表后，将该IP地址返回给主机</li></ol>
              </div>
            </details></li>
</ol>
<h3 id="其他应用层协议使用DNS的过程"><a href="#其他应用层协议使用DNS的过程" class="headerlink" title="其他应用层协议使用DNS的过程"></a>其他应用层协议使用DNS的过程</h3><ol>
<li>同一台用户主机上运行着DNS应用的客户端</li>
<li>浏览器从URL(域名)中抽取主机名，将此主机名传送到DNS应用的客户端</li>
<li>DNS客户端向DNS服务端发送一个包含主机名的请求</li>
<li>经过上述的DNS解析过程，DNS客户端接收到一个回答报文，报文中含有主机名对应的IP地址</li>
<li>浏览器接收到IP地址后，其向位于IP地址<strong>80端口的HTTP服务器，HTTPS的端口为443</strong>进程发起一个TCP连接</li>
</ol>
<h3 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h3><p>指<strong>本地DNS服务器</strong>将某个服务器返回的响应信息进行缓存。如果本地DNS服务器缓存了一对<strong>主机名~IP地址</strong>的映射，那么当<strong>本地DNS</strong>服务器再一次遇到相同的主机名的查询请求时，就可以直接返回对应的IP地址了<br><code>由于主机名和IP地址的映射不是永久的，DNS服务器在一段时间后将丢弃缓存信息</code></p>
<h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p><strong>DNS劫持</strong>就是通过劫持了DNS服务器，通过某些手段取得某域名的解析记录控制权，进而修改此域名的解析结果，导致对该域名的访问由源IP地址转入到修改后的指定IP，其结果就是对特定的网址不能进行访问或者访问的是家的网址，从而实现窃取资料或者破坏原有正常服务器的目的。<br><code>DNS劫持通过修改DNS服务器上的数据返回给用户一个错误的查询结果来实现的</code></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h3><p>HTTP又被叫做<strong>超文本传输协议</strong>，是一个简单的<strong>请求-响应</strong>协议，它通常<strong>运行在TCP之上</strong>(基于TCP&#x2F;IP协议之上的应用层协议)<br><code>它指定了客户端(或者服务端)可能发送给服务端什么样的消息以及得到什么样的响应</code></p>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>超文本 </summary>
              <div class="content">
              <p>先来理解一下什么是<br>文本:在互联网早期，人们发送的消息还都是文字，但在现在，文本已经从单纯的文字，演变成了可以包含”图片，视频，压缩包等等”，这些在HTTP眼中都是<strong>文本</strong><br>超文本:超文本就是指<strong>超出了文本的的文本</strong>，听起来有点绕，但其实就是文字，视频，压缩包的混合体，最关键的是<strong>超链接</strong>，有了<strong>超链接</strong>，就可以完成从一个超文本跳转到另外一个超文本</p><p>HTML就是最常见的<strong>超文本</strong>，它本身只是纯文字文件，但内部用很多标签定义了图片、视频等的链接，在经过浏览器的解释，呈现给我们的就是一个文字、有画面的网页了</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>传输 </summary>
              <div class="content">
              <p>所谓传输，就相当于把一个东西从一个地方搬到另外一个地方，A搬到B或者B搬到A<br>在HTTP中，传输的数据就是超文本的，同样的，其传输过程中是允许有<strong>中转</strong>的，只需要它们都遵守HTTP协议的要求，不打扰基本数据的传输，那么就可以在数据上进行添加其他内容</p>
              </div>
            </details>
<p>HTTP是一个<strong>双向协议</strong><br><code>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</code><br>为什么是两点呢？因为HTTP不光用于<strong>客户端-服务端</strong>，还应用在<strong>服务端-服务端</strong></p>
<h3 id="HTTP的工作原理"><a href="#HTTP的工作原理" class="headerlink" title="HTTP的工作原理"></a>HTTP的工作原理</h3><p><code>HTTP协议定于Web客户端如何从Web服务端请求Web页面，以及Web服务端如何把Web页面传送给客户端</code><br>HTTP协议采用了请求&#x2F;响应模型<br>客户端向服务器发送一个<strong>请求报文</strong>，请求报文包含<strong>请求的方法，URL,协议版本，请求头部和请求数据</strong><br>客户端以一个<strong>状态行</strong>作为响应，响应的内容包括<strong>协议的版本，成功或者错误的代码，服务器信息，响应头部和响应数据</strong></p>
<h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/HTTP1.jpg" class title="HTTP1">
<ol>
<li><p>请求行:请求行由<strong>请求方法，URL,协议版本</strong>三个字段组成，每个字段之间用<strong>空格</strong>隔开，最后面需要有一个换行符</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>常见的请求方法 </summary>
              <div class="content">
              <ol><li>GET:获取资源，可以用来获取URL指定的资源，经过服务器解析后返回响应内容;如果请求的资源是文本,那就原样返回服务器上的文本资源，如果是像CGI(Common Gateway Interface，通用网关接口)那样的程序，则返回经过执行后的输出结果</li><li>POST:传输实体，向指定的URL提交数据进行处理，数据包含在<strong>请求体</strong>中，其可以导致<strong>新资源的创建或者旧资源的更改</strong></li><li>HEAD:获得报文首部，类似于GET，不过返回的不是资源，而是返回响应报文的首部，大多数情况下用来<strong>确认URL的有效性以及资源的更新日期等等</strong></li><li>PUT:上传文件，就和FTP协议的文件上传一样，要求在请求报文的请求体中包含文件内容，然后保存到请求URL指定的位置<br><code>但鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的Web网站不使用该方法</code></li><li>DELETE:删除文件，与PUT相反，从请求URL中删除指定的文件<br><code>由于HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的Web网站也不使用 DELETE 方法</code></li><li>OPTIONS:询问支持的方法，查询针对请求URL指定的资源支持的方法<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>GET和POST都是安全且幂等的嘛 </summary>           <div class="content">           <p>先讲一下什么是<strong>安全</strong>，什么是<strong>幂等</strong><br><strong>安全</strong>:在HTTP协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源<br><strong>幂等</strong>:所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的</p><p>那么很明显<strong>GET</strong>方法就是<strong>安全且幂等</strong>的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是<strong>安全</strong>的，且每次的结果都是相同的<br><strong>POST</strong>因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的</p>           </div>         </details></li></ol>
              </div>
            </details>
<p>URL:中文名是<strong>统一资源定位符</strong><br>常见的版本号有:<strong>HTTP&#x2F;1.0 HTTP&#x2F;1.1 HTTP&#x2F;2.0 HTTP&#x2F;3.0</strong>,后面会介绍它们之间的差别 </p>
</li>
<li><p>请求头部:请求头部有多个，每个请求头部代表一个要求，并且每个请求头部需要用换行隔开，格式为“属性名:属性值”，服务端据此获取客户端的信息</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>常见的请求头 </summary>
              <div class="content">
              <ol><li>Host:客户端发送请求时，用来指定服务器的域名,有了Host，就可以将请求发给同一台服务器上的不同网站<img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/Host.jpg" class title="Host"></li><li>Content-Length:客户端发送请求时，这个字段就是表明这次请求的数据长度，就是告诉服务器此次请求包的长度为xxx字节，在xxx字节后的数据是另外一个请求包</li><li>Connection:最常见用于客户端要求服务端使用<strong>TCP长连接</strong>，以便其他请求复用，<code>HTTP/1.1</code>版本的默认连接都是持久连接，但为了兼容老版本的HTTP(HTTP&#x2F;1.0)，需要指定<code>Connection</code>首部字段的值为<code>Keep-Alive</code></li><li>Accept:用于客户端向服务器发送请求时，告知服务器自己能够接受什么类型的数据<br><code>Accept:*/*     代表客户端可以接收所有类型的数据</code></li><li>Accept-Encoding:用于客户端向服务端发送请求时，告知服务端自己可以接受哪些<strong>压缩方式</strong><br><code>Accept-Encoding:gzip       代表客户端可以接受用gzip压缩的数据</code></li></ol>
              </div>
            </details></li>
<li><p>一行空行，这个是必须的，<strong>请求头部和请求体之间必须有这行</strong></p>
</li>
<li><p>请求体:请求的数据，例如POST的时候，就要将一些数据放入请求体</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/HTTP2.jpg" class title="HTTP2"></li>
</ol>
<h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/HTTP3.jpg" class title="HTTP3">
<ol>
<li>状态行:由<strong>协议版本，状态码，状态码描述</strong>构成<ol>
<li>协议版本和请求包里请求行的协议版本一致</li>
<li>状态码:它以“清晰明确”的语言告诉客户端本次请求的处理结果<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>常见状态码 </summary>
              <div class="content">
              <ol><li>1XX:类状态码属于提示信息,是协议处理中的一种中间状态,实际用到的比较少,例如<ol><li>101:协议转变</li></ol></li><li>2XX:表示客户端请求成功，是我们最喜欢看到的状态码<ol><li>200:服务器成功返回所有资源，除非请求为<strong>HEAD</strong>，不然返回的内容都在响应体里</li><li>204:服务器成功解析请求，但是并没有返回任何资源，也就是说响应体里面没有数据</li><li>206:服务器成功解析请求，但只返回了一部分资源，应用于HTTP分块下载或断电传输</li></ol></li><li>3XX:表示资源的重定向，需要客户端进行一些别的操作才能请求成功<ol><li>301:表示请求的资源<strong>永久</strong>转移到了另外的服务器上，以后想要访问该资源请更改URL，一般浏览器都会自动转移到目标资源新的服务器上</li><li>302:表示请求的资源<strong>暂时</strong>转移到了别的服务器上，需要暂时用另外的URL<br><strong>301</strong>和<strong>302</strong>都会在响应头里使用字段<code>Location</code>，指明后续要跳转的<code>URL</code>，浏览器会自动重定向新的URL</li></ol></li><li>4XX:表示客户端发送的请求报文出错，服务端无法解析<ol><li>400:客户端出错，但只是个笼统的错误</li><li>403:表示<strong>服务端的资源</strong>禁止访问，这并不是客户端的请求报文出错，也就是<strong>服务器拒绝请求</strong></li><li>404:表示客户端请求的资源不存在或者未找到，无法返回给客户端</li></ol></li><li>5XX:表示服务端出错，客户端请求报文没错，但是服务端处理的时候遇到了问题<ol><li>500:服务端出错，但只是个笼统的错误</li><li>501:表示<strong>客户端的请求</strong>还不支持</li><li>502:服务器作为网关出错，表示服务端自身正常，但是访问后端的服务器发送了错误</li><li>503:服务器现在很忙，暂时无法响应，也就是<strong>服务器过载</strong>或者<strong>服务器在更新</strong></li><li>504:服务器作为网关，超时了</li></ol></li></ol>
              </div>
            </details></li>
</ol>
</li>
<li>响应头部:响应报文头，也是由多个属性组成，和请求头部格式一样，只是里面属性内容不同<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>常见的响应报文头 </summary>
              <div class="content">
              <ol><li>Content-Length:服务端在返回数据的时候，会包含<code>Content-Length</code>,这个字段就是表明这次回应的数据长度，就是告诉浏览器此次响应包的长度为xxx字节，在xxx字节后的数据是另外一个响应包</li><li>Content-Type:用于服务器回应的时候，告诉客户端，本次数据是什么格式<br><code>Content-Type: text/html; charset=utf-8     //告诉客户端，本次数据是网页，并且编码为UTF-8</code></li><li>Content-Encoding:说明数据压缩的方式。表示服务器返回的数据是用什么压缩格式的，告知客户端需要用这个方式去解压</li></ol>
              </div>
            </details></li>
<li>一行空行，这个是必须的，和请求报文一样</li>
<li>响应正文:响应报文体，即我们真正要的“干货”<img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/HTTP4.jpg" class title="HTTP4"></li>
</ol>
<h3 id="HTTP请求和响应的步骤"><a href="#HTTP请求和响应的步骤" class="headerlink" title="HTTP请求和响应的步骤"></a>HTTP请求和响应的步骤</h3><ol>
<li>客户端连接到Web服务器:<br>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口(默认为80)建立一个TCP套接字连接，例如:<code>http://www.baidu.com </code></li>
<li>发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的<strong>请求报文</strong></li>
<li>服务器接收请求并返回HTTP响应<br>Web服务器解析请求，定位请求资源。服务器将资源副本写到TCP套接字，发送<strong>响应报文</strong>，由客户端读取。</li>
<li>释放连接TCP连接<br><strong>若Connection模式为Close，则服务器主动关闭TCP连接</strong>，客户端被动关闭连接，释放TCP连接；<br><strong>若Connection模式为Keep-Alive，则该连接会保持一段时间，在该时间内可以继续接收该请求</strong></li>
<li>客户端浏览器解析HTML内容<br>客户端浏览器首先解析<strong>响应报文</strong>的状态行，查看表明请求是否成功的<strong>状态码</strong>。然后解析每一个响应头，响应头告知以下若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>在浏览器地址栏键入一个网址后，按下回车键会经历什么 </summary>
              <div class="content">
              <ol><li>浏览器向DNS服务器请求解析该地址的域名所对应的IP地址</li><li>解析出IP地址后，根据该IP地址和默认端口号80，和服务器建立TCP连接</li><li><strong>浏览器发出读取文件(URL中域名后面部分对应的文件)的HTTP请求，该请求报文作为TCP三次握手的第三次握手报文的数据发给服务端</strong></li><li>服务端对浏览器请求做出响应，并把对应的HTML文本发送给浏览器</li><li>释放TCP连接</li><li>浏览器将该HTML文本显示内容在屏幕上</li></ol><p><code>只能从客户端开始建立连接而开始通信，服务端在没有接收到请求之前不会发送响应，当然这是在HTTP/1.0的情况下</code></p>
              </div>
            </details></li>
</ol>
<h3 id="HTTP特性"><a href="#HTTP特性" class="headerlink" title="HTTP特性"></a>HTTP特性</h3><p>HTTP最突出的优点就是<strong>简单，灵活，易于扩展，应用广泛(跨语言、跨平台)，环境成熟</strong></p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>简单 </summary>
              <div class="content">
              <p>HTTP 基本的报文格式就是<code>header + body</code>，头部信息也是<code>key-value</code>简单文本的形式，易于理解，降低了学习和使用的门槛</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>灵活和易于扩展 </summary>
              <div class="content">
              <ol><li>HTTP协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充</li><li>同时<code>HTTP</code>由于是工作在应用层(OSI 第七层)，则<strong>它下层可以随意变化</strong></li><li><code>HTTPS</code>也就是在<code>HTTP</code>与<code>TCP</code>层之间增加了<code>SSL/TLS 安全传输层</code>，<code>HTTP/3</code>甚至把<code>TCP</code>层换成了基于 <code>UDP</code>的<code>QUIC</code></li></ol>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>应用广泛(跨语言、跨平台) </summary>
              <div class="content">
              <p>互联网发展至今,<code>HTTP</code>的应用范围非常的广泛，从台式机的浏览器到手机上的各种 APP,从看新闻、刷贴吧到购物、理财、吃鸡,<code>HTTP</code>的应用片地开花,同时天然具有<strong>跨平台</strong>的优越性</p>
              </div>
            </details>

<p>当然了，HTTP也有缺点，分别是优缺点为一体的<strong>无状态</strong>和<strong>明文传输</strong>，以及HTTP最大的缺点<strong>不安全</strong></p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>无状态 </summary>
              <div class="content">
              <ol><li><p>作为优点:因为服务器没有记忆功能，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能把更多的CPU和内存用来对外提供服务</p></li><li><p>作为缺点:正是因为服务器无记忆功能，他就无法支持需要多个步骤的事务操作，在完成有关联性的操作时会非常麻烦，例如登录-&gt;添加购物车-&gt;下单-&gt;结算-&gt;支付，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要问一遍身份信息，这样会使得用户体验极差</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>解决方案 </summary>           <div class="content">           <p>解决这个问题的方案有很多种，最简单最容易理解的就是<strong>Cookie</strong>技术<br><strong>Cookie</strong>技术通过在请求和响应报文中的头部写入<strong>Cookie</strong>信息来控制客户端的状态，简单来说就是:<br><code>在客户端第一次请求后，服务器会下发一个装有客户信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能认得了</code><br><img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/Cookie.jpg" class title="Cookie"></p>           </div>         </details></li></ol>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>明文传输 </summary>
              <div class="content">
              <ol><li>作为优点:明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性</li><li>作为缺点:但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，<strong>那你号没了!</strong></li></ol>
              </div>
            </details>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>不安全 </summary>
              <div class="content">
              <p>HTTP 比较严重的缺点就是不安全:</p><ol><li>通信使用明文(不加密)，内容可能会被窃听。比如，账号信息容易泄漏，那你号没了</li><li>不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了</li><li>无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了</li></ol>
              </div>
            </details>
<p>解决办法:HTTPS</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>因为HTTP一般是<strong>明文传输</strong>，很容易被攻击者窃听到重要信息，鉴于此，HTTPS应运而生</p>
<ol>
<li>HTTPS与HTTP有很大的不同在于HTTPS是以<strong>安全为目标</strong>的HTTP通道，在HTTP的基础上通过<strong>传输加密</strong>和<strong>身份确认</strong>保证了传输过程的安全性</li>
<li>HTTPS在HTTP的基础上增加了<strong>SSL层</strong>，也就是说<br><code>HTTPS=HTTP+SSL</code><img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/HTTPS.jpg" class title="HTTPS"></li>
<li>HTTP默认端口为<strong>80</strong>，HTTPS默认端口为<strong>443</strong></li>
<li>HTTP建立连接比较简单，只需要TCP三次握手，而HTTPS不光需要TCP三次握手，还需要SSL&#x2F;TLS的握手后，才能进行加密传输</li>
<li>HTTPS 协议需要向**CA(证书权威机构)**申请数字证书，来保证服务器的身份是可信的</li>
</ol>
<h4 id="HTTPS如何保证安全的"><a href="#HTTPS如何保证安全的" class="headerlink" title="HTTPS如何保证安全的?"></a>HTTPS如何保证安全的?</h4><p>HTTPS通过<strong>对称加密</strong>和<strong>非对称加密</strong>以及<strong>数字证书</strong>来保证安全性</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>对称加密 </summary>
              <div class="content">
              <p>即双方用同一种加密算法，生成的是密钥，此时<strong>密钥即可以用来加密，也可以用来解密</strong></p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>非对称加密 </summary>
              <div class="content">
              <p>非对称加密即有两把钥匙，一把<strong>公钥</strong>，一把<strong>私钥</strong>，公钥加密的信息只有私钥可以解开，私钥加密的消息也只有公钥可以解开，公钥是公开的，谁都能获取，但是私钥只有自己有，其他人是无法获取的</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>数字证书 </summary>
              <div class="content">
              <p>数字证书由CA(证书权威机构)颁发，就是一个包含公钥，身份信息以及数字签名值的一个文件</p>
              </div>
            </details>
<h4 id="HTTPS建立连接的过程"><a href="#HTTPS建立连接的过程" class="headerlink" title="HTTPS建立连接的过程"></a>HTTPS建立连接的过程</h4><p>我们知道HTTPS&#x3D;HTTP+SSL，所以一开始还是需要TCP三次握手的，最重要的是后面的SSL&#x2F;TLS协议</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>加密流程 </summary>
              <div class="content">
              <ol><li>客户端会先随机生成一个数字<strong>A1</strong>，然后将<strong>A1</strong>包含在请求中发送给服务端，该请求中还包括了<strong>客户端支持什么加密算法</strong></li><li>服务端收到请求后，也会随机生成一个数字<strong>A2</strong>，并且会向CA申请一个数字证书，并将使用<strong>非对称加密算法</strong>生成的<strong>公钥</strong>放入数字证书，一起放入的还有随机数<strong>A2</strong>和<strong>根据客户端支持的加密算法之一选择的加密算法</strong></li><li>客户端接收到服务端传送过来的数字证书后，会对证书进行检查,检查无误后进行下一步<img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.jpg" class title="数字证书"></li><li>客户端生成一个随机数<strong>A3</strong>，并且用<strong>私钥</strong>加密，然后用<strong>选择的加密算法</strong>对<strong>随机数A1,A2,A3</strong>进行加密，此时生成的是<strong>密钥</strong>，为<strong>非对称加密</strong>，将随机数<strong>A3</strong>发给服务端</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么要三个随机数 </summary>           <div class="content">           <p>因为这些随机数都是<strong>伪随机</strong>，当3个<strong>伪随机</strong>的数字组合在一起，就很接近<strong>真随机</strong>了</p>           </div>         </details></li></ol><ol start="6"><li>服务端用自己的<strong>公钥</strong>将<strong>A3</strong>解密出来，随后也就可以用<strong>加密算法</strong>来加密<strong>A1,A2,A3</strong>来生成密钥</li><li>向客户端发生最后的信息：<ol><li>加密通信算法改变通知，表示随后的信息都将用<strong>会话密钥</strong>加密通信</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验</li></ol></li><li>此后，服务端和客户端通信都可以用<strong>密钥</strong>进行加密<br><code>就算黑客拿到了前两个随机数A1,A2，但是没办法获取A3，因为只有服务端有私钥</code><img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/%E5%8A%A0%E5%AF%86.jpg" class title="加密">
              </li></ol></div>
            </details>

<h3 id="HTTP的演变"><a href="#HTTP的演变" class="headerlink" title="HTTP的演变"></a>HTTP的演变</h3><p>最开始创建的HTTP，也就是HTTP&#x2F;1.0已经很少用了，大部分都是用HTTP&#x2F;1.1的，也有的使用HTTP&#x2F;2.0，或者最新的HTTP&#x2F;3.0</p>
<h4 id="HTTP-x2F-1-0"><a href="#HTTP-x2F-1-0" class="headerlink" title="HTTP&#x2F;1.0"></a>HTTP&#x2F;1.0</h4><p>作为最初始的版本，无疑是存在很多漏洞的，比如上面提到过的明文传输，无状态等等，这些缺点随着时代的发展都慢慢消失了，但除此之外，我们还需要知道HTTP&#x2F;1.0相对于其他版本的HTTP的不足之处在哪里，这样才能更好地去理解HTTP<br>HTTP&#x2F;1.0的缺陷:</p>
<ol>
<li>无连接:HTTP&#x2F;1.0是无连接、无状态的应用层协议，无状态已经说过了，什么是无连接呢?<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>无连接 </summary>
              <div class="content">
              <p>即每次请求都需要建立连接，需要使用<strong>Keep-Alive</strong>参数建立<strong>长连接</strong><br>无法复用连接，每次发送请求都需要进行TCP连接(三次握手)，TCP的连接和释放都是比较费事的，这样频繁连接就会导致网络利用率低</p>
              </div>
            </details> </li>
<li>队头阻塞:因为HTTP&#x2F;1.0规定下一个请求必须在之前一个<strong>请求响应</strong>到达之后才能发送，假设前一个请求一直没有被响应，那么接下来的请求就都会被阻塞</li>
</ol>
<p>为了解决这些问题，HTTP&#x2F;1.1就出世了</p>
<h4 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h4><ol>
<li>相比于HTTP&#x2F;1.0，HTTP1.1提出了<strong>长连接</strong>的通信方式，也叫做<strong>持久连接</strong>，这种方式的好处就是减少了TCP创建和销毁的所造成的额外开销，减轻了服务端的负载压力，其特点就是:<br><code>只要有一方没有明确提出断开连接的要求，就会一直连接下去</code><img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/%E7%9F%AD%E8%BF%9E%E6%8E%A5%E5%92%8C%E9%95%BF%E8%BF%9E%E6%8E%A5.jpg" class title="连接"></li>
<li>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能</li>
</ol>
<p><code>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间</code><br>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送<code>A请求</code>，然后等待服务器做出回应，收到后再发出<code>B请求</code>。管道机制则是允许浏览器同时发出<code>A请求</code>和<code>B请求</code>，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。要是 前面的回应特别慢，后面就会有许多请求排队等着。也就是说并没有解决掉<strong>队头阻塞</strong>的问题</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/%E7%AE%A1%E9%81%93%E4%BC%A0%E8%BE%93.jpg" class title="管道传输">
<p>但这还是会出现<strong>队头阻塞</strong>的问题，因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.jpg" class title="队头阻塞">

<p>同样的，HTTP&#x2F;1.1在性能上还是不足的，原因如下:</p>
<ol>
<li><code>请求/响应头部(Header)</code>未经压缩就发送，首部信息越多延迟越大,只能压缩Body的部分</li>
<li>发送冗长的首部,每次互相发送相同的首部造成的浪费较多</li>
<li>服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞</li>
<li>没有请求优先级控制</li>
<li>请求只能从客户端开始，服务器只能被动响应</li>
</ol>
<h4 id="HTTP-x2F-2-0"><a href="#HTTP-x2F-2-0" class="headerlink" title="HTTP&#x2F;2.0"></a>HTTP&#x2F;2.0</h4><p>HTTP&#x2F;2.0是基于HTTPS的，所以HTTP&#x2F;2.0就解决了HTTP不安全的问题</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>头部压缩 </summary>
              <div class="content">
              <p>HTTP&#x2F;2 会压缩头(Header)如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的分<br>这就是所谓的<strong>HPACK算法</strong>:在客户端和服务器同时维护一张<strong>头信息表</strong>，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>二进制格式 </summary>
              <div class="content">
              <p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了二进制格式<br>头信息和数据体都是二进制，并且统称为帧(frame):<strong>头信息帧</strong>和<strong>数据帧</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/%E6%8A%A5%E6%96%87.jpg" class title="报文"><br>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong></p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>数据流 </summary>
              <div class="content">
              <ol><li><strong>HTTP&#x2F;2.0</strong>的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应</li><li>每个请求或回应的所有数据包，称为一个<strong>数据流(Stream)</strong></li><li><strong>每个数据流都标记着一个独一无二的编号</strong>，其中规定<strong>客户端</strong>发出的数据流编号为<strong>奇数</strong>，<strong>服务器</strong>发出的数据流编号为<strong>偶数</strong></li><li>客户端还可以指定数据流的优先级。<strong>优先级高的请求，服务器就先响应该请求</strong><img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/%E6%95%B0%E6%8D%AE%E6%B5%81.jpg" class title="数据流"></li></ol>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>多路复用 </summary>
              <div class="content">
              <p><strong>HTTP&#x2F;2.0</strong>是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应<br><code>移除了 HTTP/1.1 中的串行请求</code>，不需要排队等待，也就不会再出现<strong>队头阻塞</strong>问题，降低了延迟，大幅度提高了连接的利用率</p><p>举例来说，在一个 TCP 连接里，服务器收到了客户端<strong>A</strong>和<strong>B</strong>的两个请求，如果发现<strong>A</strong>处理过程非常耗时，于是就回应<strong>A</strong>请求已经处理好的部分，接着回应<strong>B</strong>请求，完成后，再回应<strong>A</strong>请求剩下的部分<br><img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8.jpg" class title="多路复用"></p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>服务器推送 </summary>
              <div class="content">
              <p>HTTP&#x2F;2 还在一定程度上改善了传统的<strong>请求 - 应答</strong>工作模式，服务不再是被动地响应，也可以主动向客户端发送消息</p><p>举例来说，在浏览器刚请求<strong>HTML</strong>的时候，就提前把可能会用到的<strong>JS、CSS文件等静态资源主动发给客户端</strong>，减少延时的等待，也就是服务器推送(Server Push，也叫 Cache Push)</p>
              </div>
            </details>

<p>HTTP&#x2F;2.0也还是有问题的，因为是多路复用的缘故，<strong>多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的</strong><br>所以一旦发生<strong>丢包</strong>现象，就会触发TCP的<strong>超时重传(后面会专门写一篇文章关于TCP的)机制</strong>，这样在一个TCP连接中的所有HTTP请求就必须等待<strong>丢失的包重传</strong></p>
<ol>
<li>HTTP&#x2F;1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li>
<li>HTTP&#x2F;2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求<br>这些都是TCP传输层的问题，所以HTTP&#x2F;3.0就在TCP传输层上作了改动</li>
</ol>
<h4 id="HTTP-x2F-3-0"><a href="#HTTP-x2F-3-0" class="headerlink" title="HTTP&#x2F;3.0"></a>HTTP&#x2F;3.0</h4><p>HTTP&#x2F;3.0把<strong>HTTP下层的TCP协议该成了UDP</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/HTTP5.jpg" class title="HTTP5">
<p>UDP 发生是不管顺序，也不管丢包的，所以不会出现 <strong>HTTP&#x2F;1.1 的队头阻塞 和 HTTP&#x2F;2 的一个丢包全部重传问题</strong><br>大家都知道 UDP 是不可靠传输的(为什么是不可靠，后面会和TCP一块将)，但基于<strong>UDP的QUIC协议</strong>可以实现类似<strong>TCP的可靠性传输</strong><br><strong>QUIC</strong>有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响<br><strong>TL3</strong>升级成了最新的1.3版本，头部压缩算法也升级成了<strong>QPack</strong><br><strong>HTTPS</strong>要建立一个连接，要花费<strong>6</strong>次交互，先是<strong>建立三次握手</strong>，然后是<strong>TLS&#x2F;1.3</strong>的三次握手<br>QUIC 直接把以往的<strong>TCP和TLS&#x2F;1.3</strong>的<strong>6</strong>次交互合并成了<strong>3</strong>次，减少了交互次数</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/16/blog13/HTTP6.jpg" class title="HTTP6">
<p>所以,<strong>QUIC</strong>是一个在<strong>UDP 之上的伪 TCP + TLS + HTTP&#x2F;2 的多路复用的协议</strong><br><code>QUIC是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题。所以HTTP/3现在普及的进度非常的缓慢，不知道未来 UDP 是否能够逆袭TCP</code></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>HTTP的知识点还是蛮多的，而且还是面试官很喜欢问的，所以是有必要牢牢掌握的，关于HTTPS的数字证书这一块后面会进行补充的，我感觉我写的不是很完整，我后面再写吧，今天就先到这里吧</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层相关协议</title>
    <url>/2023/03/22/blog14/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=486194136&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天梳理一下传输层的一些知识点,特别是关于<strong>TCP</strong>和<strong>UDP</strong>的,篇幅较长,还请各位看官,<strong>慢慢看</strong></p>
<h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><p>运输层:定义了一些传输数据的协议和端口号,如:</p>
<ol>
<li>TCP(传输控制协议,传输效率低,可靠性强,用于传输可靠性要求高,数据量大的数据)</li>
<li>UDP(用户数据报协议,与TCP特性恰恰相反,用于传输可靠性要求不高,数据量小的数据,例如QQ聊天数据就是通过这种方式传输的)。<br><code>主要是将从下层接受的数据进行分段和传输,达到目的地址后再进行重组。常常把这一层数据叫做段</code><br>我们最主要了解的就是TCP协议和UDP协议,其中TCP协议特别重要!</li>
</ol>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><h3 id="什么是TCP"><a href="#什么是TCP" class="headerlink" title="什么是TCP"></a>什么是TCP</h3><p>TCP协议又叫做<strong>传输控制协议</strong>,是一种<strong>可靠</strong>,<strong>面向连接</strong>,<strong>基于字节流</strong>的协议,是在运输层的,正是因为它的可靠,HTTP&#x2F;HTTPS协议都是依靠TCP协议的,也就是说,只要<code>支持HTTP/HTTPS协议的就一定支持TCP协议</code></p>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>可靠 </summary>
              <div class="content">
              <p>无论的网络链路中出现了怎样的链路变化,<strong>TCP</strong>都可以保证一个报文一定能够到达接收端</p>
              </div>
            </details>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>面向连接 </summary>
              <div class="content">
              <p>一定是<strong>一对一</strong>才能连接,不能像<strong>UDP</strong>协议 可以一个主机同时向多个主机发送消息,也就是一对多是无法做到的</p>
              </div>
            </details>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>基于字节流 </summary>
              <div class="content">
              <p>消息是<strong>没有边界</strong>的,所以无论我们消息有多大都可以进行传输<br>并且消息是<strong>有序的</strong>,当<strong>前一个</strong>消息没有收到的时候,即使它先收到了后面的字节已经收到,那么也不能扔给应用层去处理,同时对<strong>重复</strong>的报文会自动丢弃</p>
              </div>
            </details>
<h3 id="TCP协议头部"><a href="#TCP协议头部" class="headerlink" title="TCP协议头部"></a>TCP协议头部</h3><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/TCP.jpg" class title="TCP">
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>TCP头部字段 </summary>
              <div class="content">
              <details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>16位源端口号 </summary>              <div class="content">              <p>发送方的端口号</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>16位目的端口号 </summary>              <div class="content">              <p>接收方的端口号</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>序列号 </summary>              <div class="content">              <p>在建立连接时由计算机生成的<strong>随机数作为其初始值</strong>,通过<strong>SYN包</strong>传给接收端主机,每发送一次数据,就「累加」一次该「数据字节数」的大小<br><code>用来解决网络包乱序问题</code></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>确认应答号 </summary>              <div class="content">              <p>指下一次<strong>期望</strong>收到的数据的序列号,发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收<br><code>用来解决不丢包的问题</code></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>4位首部长度 </summary>              <div class="content">              <p>标识该TCP头部有多少个<strong>32bit字(4字节)</strong><br><code>因为4位最大能标识15,所以TCP头部最长是60字节,选项最多为40字节,固定头部为20字节,所以最长为60字节</code></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>6位保留 </summary>              <div class="content">              <p>占6位,保留为以后使用,目前应置为0</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>6位标志位 </summary>              <div class="content">              <ol><li>紧急URG:此位置1,表明紧急指针字段有效,他告诉系统此报文中有紧急数据,应该尽快传送</li><li>确认ACK:TCP规定,在建立连接后,所有的传达的报文段都必须把ACK置1</li><li>推送PSH:提示接收端应用程序应该立即从TCP接收缓冲区中读走数据,为接收后续数据腾出空间(如果应用程序不将接收到的数据读走,它们就会一直停留在TCP接收缓冲区中),当我们希望一个请求能在发出后立即就收到对方的响应的时候,就可以将发送报文的PSH置1,这样,接收方在接收到该报文后,不需要等到TCP缓存满了才交付给上层进行处理,而是直接交付到上层</li><li>复位RST:用于复位相应的TCP连接,表示要求对方重新建立连接</li><li>同步SYN:表示请求建立一个连接,置1表示这是一个<strong>连接请求或者连接接收报文</strong></li><li>终止FIN:表示通知对方本端要关闭连接了</li></ol>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>16位窗口大小 </summary>              <div class="content">              <p>是<strong>TCP流量控制的一个手段</strong><br>这里说的窗口,指的是接收通告窗口(Receiver Window,RWND)<br>它告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据,这样对方就可以控制发送数据的速度</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>16位检验和 </summary>              <div class="content">              <p>由发送端填充,接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意,这个校验不仅包括TCP头部,也包括数据部分<br><code>这也是TCP可靠传输的一个重要保障</code></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>16位紧急指针 </summary>              <div class="content">              <p>仅在URG&#x3D;1的时候有意义,它指出本报文段中的紧急数据的字节数(紧急数据结束后就是普通数据),即指出了紧急数据的末尾在报文中的位置<br><code>注意:即使窗口位0时也可以发送紧急数据</code></p>              </div>            </details>
              </div>
            </details>

<h3 id="为什么需要TCP协议"><a href="#为什么需要TCP协议" class="headerlink" title="为什么需要TCP协议"></a>为什么需要TCP协议</h3><p>因为<strong>IP层(网络层)<strong>是</strong>不可靠</strong>的,它不能保证<strong>网络包的交付、网络包的按序交付、网络包中的数据完整性</strong>,那么就只能依靠上层来保证了,而TCP就因此而设计出来,所以TCP是一个可靠的协议,它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的</strong></p>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>什么是TCP连接 </summary>
              <div class="content">
              <p><code>用于保证可靠性和流量控制维护的某些状态信息,这些信息的组合,包括Socket、序列号和窗口大小称为连接</code><br>所以我们可以知道,建立一个<strong>TCP连接</strong>是需要客户端与服务器端达成上述三个信息的共识</p><ol><li>Socket:由IP地址和端口号组成</li><li>序列号:用来解决乱序问题</li><li>窗口大小:用于流量控制</li></ol>
              </div>
            </details>
<details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>TCP四元组 </summary>
              <div class="content">
              <ol><li>源端口</li><li>目的端口</li><li>源IP地址</li><li>目的IP地址<br><code>TCP四元组可以唯一确定一个连接</code><br>源地址和目的地址的字段(32位)是在IP头部中,作用是通过<strong>IP协议</strong>发送报文给对方主机<br>源端口和目的端口的字段(16位)是在TCP头部中,作用是告诉<strong>TCP协议</strong>应该把报文发给哪个进程</li></ol><p>所以一个服务器一个端口可以理论上可以监听<code>2^32(客户端IP地址)×2^16(客户端端口)</code>的连接,当然了,这是理论上,而且是IPV4的情况下,原因:</p><ol><li>首先主要是文件描述符限制,<strong>Socket</strong>都是文件,所以首先要通过<strong>ulimit</strong>配置文件描述符的数目</li><li>另一个是内存限制,每个<strong>TCP连接</strong>都要占用一定内存,操作系统是有限的</li></ol>
              </div>
            </details>

<p><strong>TCP</strong>是面向连接的协议,所以使用TCP前必须先建立连接,而建立连接是通过<strong>三次握手而进行的</strong></p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" class title="TCP三次握手">
<p>一开始服务端和客户端都是关闭的(CLOSE状态),<strong>三次握手只能由客户端发起,服务端没办法主动发起连接</strong>,服务端需要<strong>先进入LISTEN状态</strong>,在SOcket中可以利用listen()去主动监听某个端口</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>三次握手详解 </summary>
              <div class="content">
              <ol><li>第一次握手:由客户端率先发起,客户端发送一个<strong>请求连接报文</strong>给客户端<br>该请求报文中,需要将<strong>SYN标志位置为1</strong>,代表请求连接,Seq Num是该报文的序号,我们假设为X,是计算机随机生成的,客户端发送完请求连接报文后,进入<strong>SYN_SENT状态</strong><br><code>这一次握手的请求报文不能包含数据</code></li><li>第二次握手:服务接收到客户端的<strong>请求连接报文</strong>后,会进行第二次握手,此次握手由服务端发送<strong>确认报文</strong><br>该确认报文中,需要将<strong>SYN标志位置为1</strong>,代表连接请求,<strong>ACK位置为1</strong>,表示服务端收到了客户端的请求连接,<strong>确认应答号Ack Num</strong>&#x3D;X+1,代表希望下次收到数据包的序列号,同时这个报文也会随机生产一个序列号,我们假设为Y,服务端接收到请求报文后,就会从<strong>LISTEN状态</strong>转变为<strong>SYN_RCVD状态</strong>,一直持续到第三次握手结束<br><code>这一次的确认报文也不会携带任何数据</code></li><li>第三次握手:客户端接收到服务端发过来的确认报文后,会进入<strong>ESTABLISHED状态</strong>,然后也会发送一个确认报文给服务端<br>确认报文中,需要将<strong>ACK置为1</strong>,这里就不需要将<strong>SYN置为1</strong>了,同时,<strong>Ack Num&#x3D;Y+1</strong><br>服务端接收到客户端发送的确认报文后,状态也从<strong>SYN_RCVD</strong>转变成<strong>ESTABLISHED</strong><br><code>这次握手,客户端可以在报文后面附带其他数据,如果有的话</code></li><li>到此为止,服务端就可以与客户端进行通信啦!</li></ol>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么是三次握手?不能是二次或者四次嘛? </summary>
              <div class="content">
              <p>首先我们知道了什么是TCP连接,那么我们就得知道<strong>为什么三次握手才可以初始化Socket、序列号和窗口大小并建立 TCP 连接</strong></p><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>原因一:避免历史连接 </summary>              <div class="content">              <p>首先我们需要知道,网络是错综复杂的,我们没法保证报文的每次传输都能成功被接受到,那么就会出现一个问题,如图<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5.jpg" class title="历史连接"></p><ol><li>假设此时网络拥堵</li><li>当我们先发送了一个序列号为90的请求报文,因为网络拥堵,导致客户端迟迟没有接受到服务端的请求报文,那么此时客户端就会认为请求报文丢失,就会重新发送一个序列号为100的请求报文(这里的序列号都是我们假设的)</li><li>此时序列号为90的<strong>旧请求报文</strong>就会比序列号为100的<strong>新请求报文</strong>先到达服务端,此时服务端就会接收到<strong>旧请求报文</strong>,然后就会返回一个确认序号为<strong>90+1</strong>的确认报文</li><li>客户端接收到服务端发送的确认报文后,由于客户端最后发送的是序列号为100的<strong>新请求报文</strong>,所以客户端希望收到的是确认序列号为<strong>100+1</strong>的确认报文,当客户端收到服务端发来的确认序列号为<strong>90+1</strong>的确认报文后,就会发现这是一个历史连接(序列号过期或超时),那么客户端就会发送<strong>RST置为1</strong>的报文,表示终止这次连接</li></ol><p><code>如果是两次握手,就不能判断当前连接是否是历史连接(因为如果是两次握手,那么第二次握手后会直接进入发送数据状态),三次握手则可以在客户端(发送方)准备发送第三次报文时,客户端因有足够的上下文来判断当前连接是否是历史连接</code><br>所以,TCP三次握手建立连接的最主要原因就是<strong>防止历史连接初始化了连接</strong></p>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>原因二:同步双方初始序列号 </summary>              <div class="content">              <p>TCP 协议的通信双方,都必须维护一个<strong>序列号</strong>,序列号是可靠传输的一个关键因素,它的作用:</p><ol><li>接收方可以去除重复的数据</li><li>接收方可以根据数据包的序列号<strong>按序接收</strong></li><li>可以标识发送出去的数据包中,哪些是已经被对方收到的<br>序列号在<strong>TCP连接</strong>中占据着非常重要的作用,所以当客户端发送携带<strong>初始序列号</strong>的<strong>SYN报文</strong>的时候,需要服务端回一个<strong>ACK应答报文</strong>,表示客户端的<strong>SYN报文</strong>已被服务端成功接收,那当服务端发送<strong>初始序列号</strong>给客户端的时候,依然也要得到客户端的应答回应,这样一来一回,才能<strong>确保双方的初始序列号能被可靠的同步</strong><br><code>这样看来,是需要四次握手(双方发送初始序列号后都需要得到对方的确认)才可以成功连接的,但是我们可以将第二次握手和第三次握手合成一次握手,所以只需要四次握手</code></li></ol><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%BA%8F%E5%88%97%E5%8F%B7.jpg" class title="序列号">两次握手只保证了一方的初始序列号能被对方成功接收,没办法保证双方的初始序列号都能被确认接收              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>原因三:避免资源浪费 </summary>              <div class="content">              <p>如果只有<strong>两次握手</strong>,当客户端的<strong>SYN请求</strong>连接在网络中阻塞,客户端没有接收到<strong>ACK报文</strong>,就会重新发送 <strong>SYN</strong><br><code>由于没有第三次握手,服务器不清楚客户端是否收到了自己发送的建立连接的 ACK 确认信号,所以每收到一个 SYN 就只能先主动建立一个连接</code><br>这样就会出现这样一种情况:如果客户端的SYN阻塞了,重复发送多次SYN报文,那么服务器在收到请求后就会<strong>建立多个冗余的无效链接,造成不必要的资源浪费</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg" class title="两次握手"></p>              </div>            </details>
              </div>
            </details>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>TCP三次握手中报文丢失会如何处理? </summary>
              <div class="content">
              <details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>第一次握手报文丢失 </summary>              <div class="content">              <p>当第一次握手的报文丢失时,客户端会一直没办法收到服务端的确认请求报文,那么此时客户端就会认为请求报文丢失,那么就会重新组织一个请求报文并发送,同样的,当第一次握手报文阻塞的时候,也会如此<br>具体重传几次,要看<code>tcp_syn_retries</code>内核参数,一般默认是5次<br><code>要注意的是,重传的请求连接报文的seq序列号字段还是之前的seq,不会重新生成</code><br>客户端发送完请求报文后会有一个定时器,定时器结束后没收到确认报文就会认为请求报文丢失了捏,定时器时间大多为3秒,6秒,12秒,这也算TCP协议保证可靠的原因之一:超时重传机制</p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>第二次握手报文丢失 </summary>              <div class="content">              <p>第二次握手报文丢失的话,客户端也没办法收到服务端传来的确认报文,那么客户端也<strong>还是会认为是自己的请求报文丢失</strong>,所以就像第一次握手报文丢失一样,会进行重传连接请求<br>但是因为服务端发送的不光是<strong>确认报文</strong>,要知道,这个报文里面<strong>SYN</strong>也置为1了,所以这个报文也表示要建立连接的请求报文,所以当第二次握手报文走丢后,服务端等不到自己请求的回应,所以<strong>也会重传报文</strong></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>第三次握手报文丢失 </summary>              <div class="content">              <p>当客户端接收到第二次握手报文后,客户端就会进入<strong>ESTABLISHED</strong>状态,服务器迟迟得不到ACK报文,但是<strong>ACK报文丢失,ACK报文是不会有重传的(当 ACK 丢失了,就由对方重传对应的报文)</strong><br>所以当到达服务器的超时重传时间后,服务器会认为是第二次握手报文丢失,所以会超时重传第二次报文,当达到最大超时重传次数还没得到ACK报文,服务器就会断开连接</p>              </div>            </details><p><code>每次超时重传的时间是上一次超时重传时间的两倍</code></p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>是不是只要三次握手成功后,客户端就能和服务端成功连接并通信呢? </summary>
              <div class="content">
              <p>并不是这样的,在我们服务端接收到最后一次握手报文的时候,还需要进行一系列的判断来确认是否可以与客户端进行连接<br>在此之前,我们先需要知道,在进行TCP三次握手的时候,Linux会为其维护两个队列:<strong>全连接队列(accept队列)<strong>和</strong>半连接队列(syn队列)</strong></p><div class="tabs" id="tab-first-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#first-tabs-1">半连接队列</a></li><li class="tab"><a class="#first-tabs-2">全连接队列</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-tabs-1"><p>在客户端发起第一次连接的时候,服务端会将其加入<strong>半连接队列</strong>,并且响应客户端的SYN+ACK报文<br><strong>半连接队列</strong>有着最大长度的限制,当超出限制的时候,内核就会丢弃这个连接,并且返回<strong>RST包</strong></p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -natp | grep SYN_RECV | wc -l      //查看半连接队列长度</span><br></pre></td></tr></table></figure></div><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>syn攻击 </summary>              <div class="content">              <p>因为<strong>半连接队列</strong>只要没有收到对应的第三次握手,那么该连接就不会从<strong>半连接队列</strong>中取出,如果有大量的连接没被取出,<strong>半连接队列</strong>很容易达到最大长度<br>假设攻击者短时间伪造不同 IP 地址的 SYN 报文,服务端每接收到一个 SYN 报文,就进入SYN_RCVD 状态,但服务端发送出去的 ACK + SYN 报文,无法得到未知 IP 主机的 ACK 应答,久而久之就会占满服务端的 SYN 接收队列(未连接队列),使得服务器不能为正常用户服务<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/SYN%E6%94%BB%E5%87%BB.jpg" class title="SYN"></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>解决办法 </summary>              <div class="content">              <p>方法一:通过修改 Linux 内核参数,控制<strong>队列大小</strong>和<strong>当队列满时应做什么处理</strong></p><ol><li>当网卡接收数据包的速度大于内核处理的速度时,会有一个队列保存这些数据包<br> 控制该队列的最大值如下参数:net.core.netdev_max_backlog</li><li>SYN_RCVD 状态连接的最大个数:net.ipv4.tcp_max_syn_backlog</li><li>超出处理能时的处理<ol><li>net.ipv4.tcp_abort_on_overflow&#x3D;0:如果全连接队列满了,那么服务端丢弃ack报文</li><li>net.ipv4.tcp_abort_on_overflow&#x3D;1:如果全连接队列满了,那么服务端会向客户端发送RST报文,终止这个握手连接</li></ol></li></ol><p>方法二:启动cookie<br>当应用程序处理速度过慢的时候,会导致<strong>全连接队列</strong>达到最大值,当遭受SYN攻击的时候会导致<strong>半连接队列</strong>达到最大值,此时可以用过设置<code>net.ipv4.tcp_syncookies = 1</code>的方法来开启cookie,开启cookie的流程如图:<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/cookie.jpg" class title="cookie"></p><ol><li>当<strong>SYN 队列</strong>满之后,后续服务器收到 SYN 包,不进入<strong>SYN 队列</strong></li><li>计算出一个<strong>cookie</strong>值,再以<strong>SYN + ACK</strong>中的<strong>序列号</strong>返回客户端,服务端接收到客户端的应答报文,服务器会检查这个<strong>ACK包</strong>的合法性。如果合法,直接放入到<strong>Accept 队列</strong></li><li>最后应用通过调用<strong>accpet()<strong>socket接口,从</strong>Accept 队列</strong>取出的连接</li></ol><p>方法三:减少第二次握手报文重传次数<br>因为我们在收到syn攻击时,服务端会重传syn+ack报文到最大次数,才会断开连接。针对syn攻击的场景,我们可以减少ack+syn报文的重传次数,使处于syn_recv状态的它们更快断开连接<br><code>修改重传次数:/proc/sys/net/ipv4/tcp_synack_retries</code></p>              </div>            </details></div><div class="tab-pane" id="first-tabs-2"><p>等到客户端返回对第二次握手的确认报文时,服务端将该连接从<strong>半连接队列</strong>中取出,并新建一个新的连接,加入到<strong>全连接队列</strong>中,等待进程调用accept()函数的时候,将该连接从**全连接队列取出</p><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ss      //判断全连接队列的情况</span><br></pre></td></tr></table></figure></div></div></div></div><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E8%BF%9E%E6%8E%A5.jpg" class title="连接"><p>所以一个连接进行三次握手后服务端也不一定能和客户端进行网络通信<br>当<strong>全连接队列</strong>已满的时候,若服务端成功接收到第三次握手的ack报文,判断<code>tcp_abort_on_overflow</code>的值</p><ol><li>若tcp_abort_on_overflow&#x3D;0,服务端就会扔掉客户端发送的ack报文,之后一段时间服务端会重新发送第二次握手的报文,如果客户端连接一直排队不上等待超时则会报超时异常</li><li>若tcp_abort_on_overflow&#x3D;1,服务端会发送一个<strong>reset包</strong>给客户端,表示废除这个握手过程和这个连接
              </li></ol></div>
            </details>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -napt   //Linux下查看TCP状态</span><br></pre></td></tr></table></figure></div>

<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>当客户端和服务端发送完消息后,需要断开连接,当然有时候会根据HTTP头部来判断是否需要断开连接还是继续保持连接(HTTP那篇文章有讲哦)</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.jpg" class title="四次挥手">
<p><code>注意,四次挥手和三次握手不一样的是,四次挥手无论是服务端还是客户端都可以主动发起,而三次握手只能由客户端主动发起!!!</code></p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>四次挥手详解 </summary>
              <div class="content">
              <p><code>这里我们假设由客户端主动发起断开连接请求</code></p><ol><li>第一次握手,客户端组织一个<strong>断开连接请求报文</strong>,发给服务端,然后客户端进入<strong>FIN_WAIT_1状态</strong>,一直到接收到第二次挥手报文为止<br>该请求报文中,需要将<strong>FIN置为1</strong>,假设该报文的序号seq为X<br><code>此时挥手的报文是可以附带数据的,所以可能该报文的确认序号不为0,ACK位也不一定为0</code></li><li>第二次握手,服务端接收到<strong>断开连接请求</strong>报文,组织一个确认报文发给客户端,然后进入<strong>CLOSED_WAIT状态</strong><br>该确认报文中,<strong>ACK置为1</strong>,确认序列号为<strong>X+1</strong>,假设该报文的序号seq为Y<br><code>因为第一次挥手的报文也可能会携带一些请求数据要求,所以该报文也可能会携带回应数据</code><br><code>注意,该确认报文中FIN位并不为1,至于为什么后面会说</code></li><li>客户端接收到服务端发来的确认报文后,进入<strong>FIN_WAIT_2状态</strong></li><li>第三次握手,<code>当服务端将剩余的数据发送完毕后</code>,会发送一个<strong>请求断开连接报文</strong>,然后进入<strong>LAST_ACK状态</strong><br>该报文位<strong>请求断开连接报文</strong>,该报文中,<strong>FIN位置为1</strong>,<strong>ACK为0</strong>,序列号假设位Z</li><li>第四次挥手,客户端接收到服务端发送的<strong>请求断开连接报文</strong>,会发送回去一个确认报文,并进入<strong>TIME_WAIT状态</strong>,并等待<strong>2MSL时间后</strong>,进入<strong>CLOSE</strong>状态,服务端接收到确认报文后也会进入<strong>CLOSE状态</strong></li></ol>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么是四次挥手而不是三次挥手? </summary>
              <div class="content">
              <p>当我们第二次挥手后,有人会问为什么握手阶段,可以第二次握手可以发送请求连接,而挥手阶段不能发送请求断开连接呢?<br>其实,断开连接请求可以在任意时刻发送,如果我们请求断开连接的时候,还有一些数据没有发送完毕呢?所以我们必须等最后一个请求被响应(也就是说服务器将所有请求处理了),才能关闭服务器<br><strong>所以挥手的第二次和第三次是不可以合成一次的</strong>,而且两次挥手间会有一定的时间间隔<br><code>当然了,如果第一次挥手后,对方没有任何数据需要传递的话,我们是可以认为第二次挥手报文可以和第三次挥手合成一次</code></p>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么要等待2MSL时间才关闭呢? </summary>
              <div class="content">
              <p>我们先来了解一下什么是<strong>MSL</strong><br><strong>MSL</strong>:<strong>Maximum Segment Lifetime</strong>,<strong>报文最大生存时间</strong>,它是任何报文在网络上存在的最长时间,超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的,而 IP 头中有一个<strong>TTL</strong>字段,是<strong>IP数据报</strong>可以经过的<strong>最大路由数</strong>,每经过一个处理他的路由器此值就<strong>减1</strong>,当此值为 0 则数据报将被丢弃,同时发送<strong>ICMP报文</strong>通知源主机<br><strong>MSL</strong>与<strong>TTL</strong>的区别:MSL 的单位是时间,而 TTL 是经过路由跳数。<strong>所以 MSL 应该要大于等于 TTL 消耗为 0 的时间,以确保报文已被自然消亡</strong></p><p>那么为要等2MSL时间呢?<br>这是因为,<strong>第四次挥手报文</strong>可能会丢失,如果被动关闭方没有收到断开连接的<strong>最后的ACK报文(第四次挥手报文)</strong>,就会触发超时重发 Fin 报文,另一方接收到 FIN 后,会重发 ACK 给被动关闭方, 一来一去正好 2 个 MSL<br><code>在Linux下,一个MSL大概为30s,所以2MSL位1min,也就是说Linux停留在TIME_WAIT的时间为固定的60s</code></p>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么要有TIME_WAIT状态?TIME_WAIT状态过短会怎么样? </summary>
              <div class="content">
              <p>主要有两个原因</p><div class="tabs" id="tab-second-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#second-tabs-1">原因一:防止旧连接的数据包</a></li><li class="tab"><a class="#second-tabs-2">原因二:保证连接正确关闭</a></li></ul><div class="tab-content"><div class="tab-pane active" id="second-tabs-1"><p>如图<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE.jpg" class title="历史数据"></p><ol><li>如上图黄色框框服务端在关闭连接之前发送的<strong>SEQ &#x3D; 301</strong>报文,被网络延迟了</li><li>这时有相同端口的<strong>TCP 连接被复用后</strong>,被延迟的<strong>SEQ &#x3D; 301</strong>抵达了客户端(图上画错哩),那么客户端是有可能正常接收这个过期的报文,这就会产生数据错乱等严重的问题</li></ol><p><code>所以,TCP 就设计出了这么一个机制,经过 2MSL 这个时间,足以让两个方向上的数据包都被丢弃,使得原来连接的数据包在网络中都自然消失,再出现的数据包一定都是新建立连接所产生的</code></p></div><div class="tab-pane" id="second-tabs-2"><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E6%96%AD%E5%BC%80.jpg" class title="断开">1. 如上图红色框框客户端四次挥手的最后一个ACK报文如果在网络中被丢失了,此时如果客户端**TIME_WAIT**过短或没有,则就直接进入了**CLOSE**状态了,那么服务端则会一直处在**LAST_ACK**状态<ol start="2"><li>当客户端发起建立连接的<strong>SYN请求</strong>报文后,服务端会发送<strong>RST报文</strong>给客户端,连接建立的过程就会被终止</li></ol></div></div></div>所以当TIME_WAIT为2MSL的时候,就会出现以下两种情况:1. 服务端正常收到四次挥手的最后一个**ACK 报文**,则服务端正常关闭连接<ol start="2"><li>服务端没有收到四次挥手的最后一个<strong>ACK 报文</strong>时,则会重发<strong>FIN关闭连接报文</strong>并等待新的<strong>ACK报文</strong></li></ol>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>TIME_WAIT状态过多的危害 </summary>
              <div class="content">
              <p>如果服务器有处于<strong>TIME_WAIT</strong>状态的<strong>TCP</strong>,则说明是由服务器方主动发起的断开请求<br>TIME_WAIT过多的危害:</p><ol><li>对内存资源占用</li><li>对端口资源的占用,一个TCP连接至少消耗一个本地端口,这个危害就很大了,因为端口资源有限,<code>当服务端TIME_WAIT过多而导致占用了所有的端口资源,则会导致无法创建新的连接</code></li></ol>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>CLOSE_WAIT状态过多的原因以及解决办法 </summary>
              <div class="content">
              <p><strong>CLOSE_WAIT</strong>状态是在TCP四次挥手的时候服务器<strong>收到FIN但是没有发送自己的FIN时出现的</strong><br>服务器出现大量<strong>CLOSE_WAIT</strong>状态的原因有两种</p><div class="tabs" id="tab-third-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#third-tabs-1">原因一</a></li><li class="tab"><a class="#third-tabs-2">原因二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="third-tabs-1"><ol><li>服务器内部业务处理占用了过多时间,都没能处理完业务,或者还有数据需要发送</li><li>服务器的业务逻辑有问题,没有执行close()方法</li></ol></div><div class="tab-pane" id="third-tabs-2"><p>服务器的父进程派生出子进程,子进程继承了socket,收到FIN的时候子进程处理但父进程没有处理该信号,导致socket的引用不为0无法回收<br>这里有必要说一下调用close()关闭连接的一些注意点:</p><ol><li>如果有多个进程共享一个socket,close每被调用一次,<strong>计数-1</strong>,直到所有<strong>计数为0</strong>的时候,也就是所有进程都调用了colse,socket才会被释放</li><li>在多进程中如果一个进程调用了shutdown()后,其他进程就无法进行通信</li></ol></div></div></div><p>解决办法:</p><ol><li>停止应用程序</li><li>修改代码BUG</li></ol>
              </div>
            </details>

<h3 id="TCP如何保证可靠"><a href="#TCP如何保证可靠" class="headerlink" title="TCP如何保证可靠"></a>TCP如何保证可靠</h3><p>我们知道,TCP协议是<strong>可靠</strong>,<strong>面向连接</strong>,<strong>字节流</strong>的协议,最主要的是可靠,面向连接上面已经说了,现在来说一下为什么说TCP是可靠的,TCP又是如何保证可靠的呢?</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>校验和 </summary>
              <div class="content">
              <p>校验和是实现数据在传输过程中出错而实现的一种计算方法<br>计算方法:在数据传输的过程中,将发送的数据段都当做一个16位的整数。将这些整数加起来。并且前面的进位不能丢弃,补在后面,最后取反,得到校验和<br><strong>发送方</strong>:在发送数据之前计算检验和,并进行校验和的填充<br><strong>接收放</strong>:收到数据后,对数据以同样的方式进行计算,求出校验和,与发送方的进行比对<br>如果不一致,则说明数据在传输过程中出现错误,那么<strong>数据就不一定能传输成功</strong></p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>确认应答和序列号 </summary>
              <div class="content">
              <p>看了上面的连接过程,我们直到三次握手为什么要三次的原因之一就是需要确认双方的初始序列号,而不光是三握手和挥手阶段,<strong>TCP</strong>传输数据的时候,都需要有确认应答机制来确保请求成功被接受<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94.jpg" class title="确认应答"><br>但是网络情况错综复杂,我们没办法保证每个请求都能被接受到,那么当一个请求没办法被服务端接收到的时候,我们就需要重新发送这个请求,这也是TCP实现可靠的方法之一</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>超时重传和快速重传 </summary>
              <div class="content">
              <p>其实这个概念我们在上面讲TCP三次握手和四次挥手的时候就有提及过,当握手&#x2F;挥手过程中一个报文丢失了就会重新发送一个新的报文</p><div class="tabs" id="tab-forth-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#forth-tabs-1">超时重传</a></li><li class="tab"><a class="#forth-tabs-2">快速重传</a></li><li class="tab"><a class="#forth-tabs-3">SACK和D-SACK</a></li></ul><div class="tab-content"><div class="tab-pane active" id="forth-tabs-1"><p>超时重传有两种情况:</p><ol><li>数据包丢失</li><li>确认应答包丢失<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0.jpg" class title="超时重传">在上图我们可以看到,无论是**数据包丢失**或者是**确认应答包**丢失,都是当客户端接收不到想要的确认应答包才进行超时重传的<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>超时重传设置的时间 </summary>           <div class="content">           <p>在此之前,我们来了解一下什么叫<strong>RRT</strong><br><strong>RRT</strong>:又叫做往返时间(Round-Trip Time),从下图可以知道,RRT就是一个包的<strong>往返时间</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/RRT.jpg" class title="RRT"></p><p>我们设置超时重传的时间一般叫做RTO(Retransmission Timeout 超时重传时间),我们的RTO不能设置的太长或者太短<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/RTO.jpg" class title="RTO"></p><ol><li>当我们的<strong>RTO</strong>设置地太长(比RRT还长),当我们发送的包或者确认应答包丢失了,我们等待的时间比正常一个包来往的时间还长,也就是如果这个包丢了,我们要等好久才重发,这明显是不利于网络传输的性能的</li><li>当我们的<strong>RTO</strong>设置地太短(比RRT还短),当我们发的包无论有没有丢失都会重发,因为客户端在<strong>RTO</strong>时间内是没办法收到一个来往需要<strong>RRT</strong>的数据包的,所以就会进行重传,会增加网络拥塞,导致更多的超时,更多的超时导致更多的重发</li></ol><p><code>所以我们需要合理地设置RTO</code><br>从上面可知,我们的RTO需要<strong>略大于RRT</strong>但是<strong>不能过大</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%A4%A7%E4%BA%8E.jpg" class title="大于"><br>当然了,因为网络是波动的,所以每个报文地<strong>RRT</strong>不是固定的,所以我们设置的<strong>RTO</strong>也不是固定的,而是<strong>动态变化</strong>的</p>           </div>         </details></li></ol></div><div class="tab-pane" id="forth-tabs-2"><p>快速重传和超时重传有点不太一样,这是因为超时重传会带来一点微妙的问题,比如:</p><ol><li>当一个报文段丢失时,会等待一定的RTO然后才重传,增加了<strong>端到端</strong>的时延</li><li>当一个报文段丢失时,在其等待超时的过程中,可能会出现这种情况:<br>其后的报文段<strong>已经被接收端接收</strong>但却迟迟<strong>得不到确认</strong>(这是因为TCP采用的是累计确认机制),发送端会认为也丢失了,从而引起不必要的重传,既浪费资源也浪费时间</li></ol><details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>TCP累计确认机制 </summary>              <div class="content">              <p>也就是当接收端接收到比期望序列号大的报文时,便会重复发送最近一次确认的报文段的确认信号,我们称之为<strong>冗余ACK(duplicate ACK)</strong><br>举个例子:</p><ol><li>当我们发送序列号为1的报文时,接收端如果成功接收便会返回确认报文,确认报文中的确认序列号(ack)为2,也就是期待下次收到的序列号</li><li>当客户端发送序列号为2的报文丢失了,然后发送了序列号为3的报文,此时接收方收到了序列号为3的报文,但是由于该报文的序列号不是自己期待收到的序列号为2的报文,于是又会发送一个ack为2的报文<br><code>这就是冗余ACK</code></li></ol>              </div>            </details><p>超时重传是在<strong>RTO时间内没有收到期望的确认应答报文</strong>而触发的机制,而快速重传是<strong>客户端连续收到三个相同确认应答包</strong>(其实是4个,不过第一个是正常的ACK确认报文,后面连续三个都是冗余ACK报文)而触发的机制</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.jpg" class title="快速重传"><p>在上图,发送方发出了 1,2,3,4,5 份数据</p><ol><li>第一份<strong>Seq1</strong>先送到了,于是就<strong>Ack</strong>回<strong>2</strong></li><li>结果<strong>Seq2</strong>因为某些原因没收到,<strong>Seq3</strong>到达了,于是还是<strong>Ack</strong>回<strong>2</strong></li><li>后面的<strong>Seq4</strong>和<strong>Seq5</strong>都到了,但还是<strong>Ack</strong>回<strong>2</strong>,因为<strong>Seq2</strong>还是没有收到</li><li>发送端收到了三个<strong>Ack &#x3D; 2</strong>的确认,知道了<strong>Seq2</strong>还没有收到,就会在定时器过期之前,重传丢失的<strong>Seq2</strong></li><li>最后,接收到收到了<strong>Seq2</strong>,此时因为<strong>Seq3,Seq4,Seq5</strong>都收到了,于是<strong>Ack</strong>回<strong>6</strong></li></ol><p>所以,快速重传的工作方式是当收到三个相同的 ACK 报文时,会在<strong>定时器过期之前</strong>,重传丢失的报文段</p><p>快速重传机制只解决了一个问题,就是超时时间的问题,但是它依然面临着另外一个问题。就是重传的时候,是重传之前的一个,还是重传所有的问题</p><p>比如对于上面的例子,是重传<strong>Seq2</strong>呢?还是重传<strong>Seq2、Seq3、Seq4、Seq5</strong>呢?因为发送端并不清楚这连续的三个 <strong>Ack 2</strong>是谁传回来的</p><p>根据 TCP 不同的实现,以上两种情况都是有可能的<br><code>可见,这是一把双刃剑</code></p></div><div class="tab-pane" id="forth-tabs-3"><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>SACK </summary>              <div class="content">              <p>SACK,又叫做(Selective Acknowledgment 选择性确认),也是一种重传方式<br>这种方式需要在 TCP 头部<strong>选项</strong>字段里加一个<strong>SACK</strong>的东西,它可以将<strong>缓存的地图</strong>发送给发送方,这样发送方就可以知道<strong>哪些数据收到了</strong>,<strong>哪些数据</strong>没收到,知道了这些信息,就可以<strong>只重传丢失的数据</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/SACK.jpg" class title="SACK"><br>当发送方<strong>200~299</strong>的报文丢失后,会收到连续四个<strong>ack为200</strong>的确认应答报文,第一个是正常报文,接下来连续三个是<strong>冗余报文</strong>,其中<strong>SACK都是从300</strong>开始,那么发送发就知道是<strong>200~299</strong>的报文丢失了而导致没被接受到<br><code>如果要支持 SACK,必须双方都要支持。在 Linux 下,可以通过 net.ipv4.tcp_sack 参数打开这个功能(Linux 2.4 后默认打开)</code></p>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>D-SACK </summary>              <div class="content">              <p><strong>D-SACK</strong>是利用SACK来告诉发送方有<strong>哪些数据被重复接收了</strong><br>例如:</p><ol><li><p>ACK确认应答丢失</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/ACK%E4%B8%A2%E5%8C%85.jpg" class title="ACK丢包"> 1. **接收方**发给**发送方**的两个**ACK确认应答**都丢失了,所以发送方超时后,重传第一个数据包(3000 ~ 3499) 2. 于是**接收方**发现数据是重复收到的,于是回了一个**SACK = 3000~3500**,告诉**发送方**3000~3500的数据早已被接收了,**因为 ACK 都到了 4000 了,已经意味着 4000 之前的所有数据都已收到,所以这个 SACK 就代表着 D-SACK** 3. 这样**发送方**就知道了,数据没有丢,是**接收方**的 ACK 确认报文丢了</li><li><p>网络延时</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F.jpg" class title="网络延迟"> 1. 数据包(1000~1499) 被网络延迟了,导致**发送方**没有收到**ACK1500**的确认报文。 2. 而后面报文到达的三个相同的 ACK 确认报文,就触发了快速重传机制,但是在重传后,被延迟的数据包(1000~1499)又到了**接收方** 3. 所以**接收方**回了一个 SACK=1000~1500,因为 ACK 已经到了 3000,所以这个**SACK 是 D-SACK**,表示收到了重复的包 4. 这样发送方就知道快速重传触发的原因不是发出去的包丢了,也不是因为回应的 ACK 包丢了,而是因为网络延迟了<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>D-SACK的好处 </summary>           <div class="content">           <ol><li><strong>发送方</strong>可以知道是哪部分数据丢失,可以只重传这一部分数据</li><li><strong>发送方</strong>可以知道重传的原因,是因为自己的发送报文丢失还是因为请求报文丢失</li><li>可以知道是不是<strong>发送方</strong>的数据包被网络延迟了</li><li>可以知道网络中是不是把<strong>发送方</strong>的数据包给复制了<br><code>在 Linux 下可以通过 net.ipv4.tcp_dsack 参数开启/关闭这个功能(Linux 2.4 后默认打开)</code></li></ol>           </div>         </details></li></ol>              </div>            </details></div></div></div>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>流量控制 </summary>
              <div class="content">
              <p>我们知道,当<strong>接收方</strong>接收到数据后,需要对数据进行处理,<strong>接收方</strong>处理请求的是需要一定时间的,虽然单个请求处理时间会很短,但是当请求数量数以百万计的时候,所耗费的时间是很大的,如果此时<strong>发送方</strong>还继续发送数据的话,<strong>接收方</strong>是处理不过来的(不要啊,”被大大的数据塞满”这种事情,我不接受啊!(艾伦坐)),这样显然是不好的,所以我们需要控制<strong>发送方</strong>的发送速度,而依据就是<strong>接收方</strong>处理速度,这就是TCP可靠的原因之一,<strong>流量控制</strong></p><details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>流量控制的机制:滑动窗口 </summary>              <div class="content">              <p>TCP用来实现<strong>流量控制</strong>的方法就是依靠<strong>滑动窗口</strong>,在此之前,我们还是一样需要知道什么是<strong>窗口</strong>,为什么要有<strong>窗口</strong>,<strong>窗口</strong>的出现是解决了什么问题<br><code>知其然,我们还需要知其所以然</code></p><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>什么是窗口 </summary>              <div class="content">              <p>窗口实际上是<strong>操作系统开辟的一块缓冲区</strong>, <strong>发送方</strong>发送数据就会将数据存放在缓冲区里面,如果<strong>发送方</strong>收到<strong>接收方</strong>回应的确认应答,这个数据就会从缓冲区里面删除,如果没收到就需要保留在缓冲区,TCP头部字段中<strong>有一个16位的窗口大小</strong></p>              </div>            </details><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么引入窗口,解决了什么问题 </summary>              <div class="content">              <p>我们都知道,TCP是运用应答机制来确保数据的传达从而实现TCP的可靠,<strong>每次请求都需要收到确认才会进行下一次的请求</strong><br><code>就好像你和喜欢的人聊天一样,她不回你你就不敢继续往下聊了,因为你喜欢她,你害怕你多说一句她就会觉得你烦,只有等她回你&quot;嗯&quot;,&quot;哈哈&quot;,&quot;对&quot;的时候,你才能继续往下聊,真惨啊~</code><br>但是!你为什么要这样卑微?自卑让你弯下身段,派大星要你站起来!<br>我们要先爱自己,她不理老子,老子照样给你发消息,至于发多少那要看哥对你喜欢的程度以及你能接受多少的程度了</p><p>TCP也是这样认为的,所以它开辟了一个叫做<strong>窗口</strong>的东西,<strong>窗口的大小</strong>就是<strong>无需等待确认应答,而可以继续发送数据的最大值</strong></p><p>假设<strong>窗口大小</strong>为3,也就是说<strong>发送方</strong>可以<strong>连续发送</strong>3个TCP段而不需要等待回应,并且中途若有 ACK 丢失,可以通过<strong>下一个确认应答进行确认</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%AA%97%E5%8F%A3.jpg" class title="窗口"></p>              </div>            </details><p>知道了窗口的概念,现在我们来看看TCP是如何<strong>利用窗口来达到流量控制</strong>的目的</p><p>TCP头部有一个<strong>16位的窗口大小</strong>字段<br><code>这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据,而不会导致接收端处理不过来</code><br>所以,通常窗口的大小是由接收方的决定的,<strong>发送方发送的数据大小不能超过接收方的窗口大小</strong>,否则接收方就无法正常接收到数据</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>发送方的滑动窗口 </summary>              <div class="content">              <img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B9.jpg" class title="发送方"><p>如上图所示(实际上不一定是这样的)<br>当我们将<strong>可用窗口</strong>的数据(也就是46~51)全部发送出去后,<strong>可用窗口</strong>的大小就会变为0,表明在没有收到ACK确认前是没办法继续发送数据了<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B91.jpg" class title="发送方1"></p><p>当<strong>发送方</strong>收到之前发送的数据(32~36)的ACK时,<strong>如果发送窗口大小没有变化的话</strong>,整个发送窗口往<strong>右移</strong>5个字节,也就是已经确认收到的字节,那么此时,<strong>52-56</strong>这5个字节也就又变成了<strong>可用窗口</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B92.jpg" class title="发送方2"></p><p>在程序中,TCP是这样表示这<strong>四个部分</strong>的<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%8F%91%E9%80%81%E6%96%B93.jpg" class title="发送方3"></p><ol><li><strong>SND.WND</strong>:表示发送窗口的大小(大小是由接收方指定的)</li><li><strong>SND.UNA</strong>:是一个绝对指针,它指向的是已发送但未收到确认的第一个字节的序列号,也就是<strong>发送窗口</strong>的第一个字节</li><li><strong>SND.NXT</strong>:也是一个绝对指针,它指向未发送但可发送范围的第一个字节的序列号,也就是<strong>可用窗口</strong>的第一个字节。</li><li>指向 #4 的第一个字节是个相对指针,它需要 SND.UNA 指针加上 SND.WND 大小的偏移量,就可以指向 #4 的第一个字节了<br>那么可用窗口大小的计算就可以是:<br><code>可用窗口大小 = SND.WND -(SND.NXT - SND.UNA)</code></li></ol>              </div>            </details><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>接收方的滑动窗口 </summary>              <div class="content">              <img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E6%8E%A5%E6%94%B6%E6%96%B9.jpg" class title="接收方"><ol><li><strong>RCV.WND</strong>:表示接收窗口的大小,它会通告给发送方</li><li><strong>RCV.NXT</strong>:是一个指针,它指向期望从发送方发送来的下一个数据字节的序列号,也就是 #3 的第一个字节</li><li>指向 #4 的第一个字节是个<strong>相对指针</strong>,它需要<strong>RCV.NXT</strong>指针加上<strong>RCV.WND</strong>大小的偏移量,就可以指向 #4 的第一个字节了</li></ol>              </div>            </details><p><code>接收方的滑动窗口大小和发送方的滑动窗口并不是相等的,而是约等的,是因为传输过程存在延迟</code><br>我们举个栗子来讲一下<strong>TCP利用滑动窗口来做到流量控制的过程</strong></p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>举个栗子 </summary>              <div class="content">              <p>我们依旧假设客户端为发送方,服务器为接收方(因为TCP连接也可以是服务端与服务端的连接,所以这边只是假设)</p><ol><li>双方通过<strong>三次握手</strong>建立连接,在三次握手的过程中,客户端会通过报文中的<strong>窗口大小字段</strong>告知服务端,服务端也会将自己的窗口大小设置成一样的,这边假设为<strong>400</strong>个字节吧</li><li>我们假设客户端有<strong>1000字节</strong>的代发数据,每个TCP包为<strong>100个字节</strong></li><li>因为客户端的窗口为400字节,代表可以<strong>连续发送</strong>400个字节的数据,在这里就是可以连续发送4个TCP包而无需等待应答,此时客户端的<strong>SND.WND&#x3D;400</strong>,<strong>SND.NEXT&#x3D;0</strong>,<strong>SND.UNA&#x3D;0</strong></li><li>因为此时客户端的可用窗口为400,所以可以发送400个字节,每发送一个TCP包,<strong>SND.NEXT</strong>都要+100,所以发送完序列号<strong>1&#96;100</strong>的TCP包后,<strong>SND.NEXT</strong>指向101字节,<strong>SND.UNA</strong>是不变的,因为还没有接收到确认报文</li><li>就这样,当发送方的<strong>可用窗口</strong>变为0的时候,也就是<strong>SND.NEXT</strong>指向401的时候,发送方就不能继续发送数据了</li><li>在服务端的角度来看的话(服务端也有发送窗口,这里我们就先关注接收窗口),<strong>RCV.WND&#x3D;400</strong>,<strong>RCV.NEXT&#x3D;0</strong>,当服务端收到第一个报文,也就是序列号为<strong>1~100</strong>的报文时,<strong>RCV.NEXT&#x3D;101</strong>(下一个期望收到的序列,也就是应答报文的ack),整个接收窗口向后移动100个字节</li><li>发送方接收到客户端发送来的应答报文后,根据ack来确认报文送达,<strong>SND.UNA</strong>往右移动100个字节,此时<strong>可用窗口大小就&#x3D;400-(401-101)&#x3D;100</strong>,相当于发送窗口右移100个字节,这也是为什么说是<strong>滑动窗口</strong></li></ol><p><code>这个栗子里,我们假设接收窗口和发送窗口是不变的,在是我们知道窗口实际上是一块操作系统内存缓冲区,而大小是会被操作系统调整的</code></p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>操作系统如何影响接收窗口和发送窗口? </summary>              <div class="content">              <p>还是看看下面两个例子(客户端作为发送方,服务端作为接收方,发送窗口和接收窗口初始大小为<strong>360</strong>)</p><div class="tabs" id="tab-fifth-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#fifth-tabs-1">栗子一</a></li><li class="tab"><a class="#fifth-tabs-2">栗子二</a></li></ul><div class="tab-content"><div class="tab-pane active" id="fifth-tabs-1"><ol><li>客户端作为发送方,服务端作为接收方,发送窗口和接收窗口初始大小为<strong>360</strong></li><li>服务端非常的繁忙,当收到客户端的数据时,应用层不能及时读取数据<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%9C%BA%E6%99%AF1.jpg" class title="场景1"></li><li>客户端发送<strong>140字节</strong>数据后,<strong>可用窗口</strong>变为<strong>220</strong>(360 - 140)</li><li>服务端收到<strong>140字节</strong>数据,但是<strong>服务端非常繁忙</strong>,应用进程只读取了<strong>40个字节</strong>,还有<strong>100字节</strong>占用着缓冲区,于是接收窗口收缩到了<strong>260</strong>(360 - 100),最后发送确认信息时,将<strong>窗口大小</strong>发送给客户端</li><li>客户端收到确认和窗口通告报文后,<strong>发送窗口</strong>减少为<strong>260</strong></li><li>客户端发送 180 字节数据,此时<strong>可用窗口</strong>减少到<strong>80</strong></li><li>服务端收到 180 字节数据,但是<strong>应用程序没有读取任何数据</strong>,这 180 字节直接就<strong>留在了缓冲区</strong>,于是接收窗口收缩到了<strong>80</strong>(260 - 180),并在发送确认信息时,通过窗口大小给客户端</li><li>客户端收到确认和窗口通告报文后,发送窗口减少为 80</li><li>客户端发送 80 字节数据后,<strong>可用窗口</strong>耗尽</li><li>服务端收到 80 字节数据,但是<strong>应用程序依然没有读取任何数据</strong>,这<strong>80字节</strong>留在了缓冲区,于是接收窗口收缩到了<strong>0</strong>,并在发送确认信息时,通过窗口大小给客户端</li><li>客户端收到确认和窗口通告报文后,发送窗口减少为<strong>0</strong><br>可见最后窗口都收缩为 0 了,也就是发生了窗口关闭<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>窗口关闭 </summary>           <div class="content">           <p>窗口关闭指的是:如果窗口大小为<strong>0</strong>时,就会阻止发送方给接收方传递数据,直到窗口变为<strong>非0</strong>为止<br>窗口关闭的潜在危害:<strong>死锁</strong><br>我们假设这样一个情况</p><ol><li><strong>接收端</strong>因为来不及处理数据,所以数据填满了接收窗口(也就是缓冲区),发送确认报文的时候,报文里的窗口大小就为0,<strong>发送端</strong>接收到消息后,将自己的发送窗口也变为0,此时<strong>发送端</strong>将无法发送消息</li><li>等<strong>接收端</strong>处理完数据后,会向对方发送一个<strong>窗口非0</strong>的ACK报文</li><li>这个时候,这个ACK报文在网络中走丢了,那么<strong>发送方</strong>就永远接受不到<strong>接收窗口非0</strong>的这个消息,所以<strong>发送方</strong>的发送窗口就一直为0,一直没办法发送数据了<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%AA%97%E5%8F%A3%E5%85%B3%E9%97%AD.jpg" class title="窗口关闭"></li></ol><p>解决办法:<br>TCP 为每个连接设有一个持续定时器,<strong>只要 TCP 连接一方收到对方的零窗口通知,就启动持续计时器</strong>,如果<strong>持续计时器超时</strong>,就会发送<strong>窗口探测(Window probe)报文</strong>(这个即使接收窗口为0也可以接收到),而对方在确认这个探测报文时,给出自己现在的接收窗口大小:</p><ol><li>如果接收窗口仍然为 0,那么收到这个报文的一方就会重新启动持续计时器</li><li>如果接收窗口不是 0,那么死锁的局面就可以被打破了<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%AA%97%E5%8F%A3%E6%8E%A2%E6%B5%8B.jpg" class title="窗口探测"></li></ol><p>窗口探查探测的次数一般为 3 此次,每次次大约 30-60 秒(不同的实现可能会不一样)。如果 3 次过后接收窗口还是 0 的话,有的 TCP 实现就会发<strong>RST报文</strong>来中断连接</p>           </div>         </details></li></ol></div><div class="tab-pane" id="fifth-tabs-2"><p>当服务端系统资源非常紧张的时候,操心系统可能会直接减少了接收缓冲区大小,这时应用程序又无法及时读取缓存数据,那么这时候就有严重的事情发生了,会出现数据包丢失的现象</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%9C%BA%E6%99%AF2.jpg" class title="场景2"><ol><li>客户端发送 140 字节的数据,于是<strong>可用窗口</strong>减少到了220</li><li>服务端因为现在非常的繁忙,<strong>操作系统于是就把接收缓存减少了100字节</strong>,又因为应用程序没有读取任何数据,所以140字节留在了缓冲区中,于是<strong>接收窗口</strong>大小从360收缩成了<strong>120</strong>,最后发送确认信息时,通告窗口大小给对方</li><li>假设此时客户端因为还没有收到服务端的通告窗口报文,所以不知道此时接收窗口收缩成了<strong>120</strong>,客户端只会看自己的可用窗口还有<strong>220</strong>,所以客户端就发送了<strong>180字节数据</strong>,于是可用窗口减少到<strong>40</strong></li><li>服务端收到了<strong>180字节数据</strong>时,发现数据大小超过了接收窗口的大小,于是就把数据包丢失了</li><li>此时客户端收到<strong>第2步服务端发送的确认报文和通告窗口报文</strong>,尝试减少发送窗口到 100,把窗口的右端向左收缩了 80,此时<strong>可用窗口的大小</strong>就会出现诡异的负值<br><code>所以,如果发生了先减少缓存,再收缩窗口,就会出现丢包的现象</code><br><strong>为了防止这种情况发生,TCP 规定是不允许同时减少缓存又收缩窗口的,而是采用先收缩窗口,过段时间在减少缓存,这样就可以避免了丢包情况</strong></li></ol></div></div></div>              </div>            </details>              </div>            </details>              </div>            </details>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>拥塞控制 </summary>
              <div class="content">
              <p><strong>拥塞控制</strong>也是TCP实现可靠的重要手段之一,和<strong>流量控制</strong>不同的是,<strong>拥塞避免</strong>是争对网络传输而做出的一系列举措</p><p>网络错综复杂,当网络特别拥挤阻塞的时候,我们会经常出现<strong>数据包丢失、时延</strong>等问题,这样就会要用<strong>超时重传</strong>来解决,但是一重传就会导致网络的负担更重,于是会导致更大的延迟以及更多的丢包,这个情况就会进入恶性循环被不断地放大,这显然是不利于网络传输的</p><p>所以TCP只好牺牲自我,来降低发送量,啊!TCP可真是无私啊~<br>那么,为了在<strong>发送方</strong>调节所发送的数据量,我们需要通过<strong>拥塞窗口</strong>来控制</p><details class="orange" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>拥塞窗口是什么?和发送窗口有什么关系? </summary>              <div class="content">              <p><strong>拥塞窗口cwnd</strong>是发送方维护的一个的<strong>状态变量</strong>,它会根据网络的拥塞程度<strong>动态变化</strong>的</p><p>我们在前面提到过<strong>发送窗口swnd</strong>和<strong>接收窗口rwnd</strong>是<strong>约等于</strong>的关系,那么由于引入了<strong>拥塞窗口</strong>的概念后,此时发送窗口的值是<strong>swnd &#x3D; min(cwnd, rwnd)</strong></p><p>拥塞窗口(cwnd)的变化规则:</p><ol><li>只要网络中没有出现拥塞,<strong>cwnd就会增大</strong></li><li>一旦网络中出现拥塞,<strong>cwnd就会减小</strong></li></ol><p>如何知道网络出现拥塞呢?<br>其实只要<strong>发送方</strong>没有在规定时间内接收到<strong>ACK应答报文</strong>,<strong>也就是发生了超时重传,就会认为网络出现了用拥塞</strong></p>              </div>            </details><details class="orange" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>拥塞控制算法 </summary>              <div class="content">              <ol><li>慢开始(慢启动):当我们的TCP在三次握手建立连接后,首先就是<strong>慢启动</strong>过程,顾名思义,就是一点点慢慢地增加<strong>拥塞窗口</strong>的大小,<code>TCP规定,只要发送方收到一个ACK确认报文,cwnd就加一</code><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>慢启动 </summary>           <div class="content">           <p>我们假设cwnd和swnd一样,一开始初始为1</p><ol><li>发送一个MSS大小的数据,等接收到一个ACK后,cwnd+1(cwnd&#x3D;2),于是下一次就可以发送两个MSS大小的数据了</li><li>发送两个MSS大小的数据,会接收到两个ACK,cwnd+2(cwnd&#x3D;4),下一次就可以发送四个了</li><li>发送四个MSS大小的数据,会接收到四个ACK,cwnd+4(cwnd&#x3D;8),下一次就可以发送八个了<br>…<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E6%85%A2%E5%90%AF%E5%8A%A8.jpg" class title="慢启动"></li></ol>           </div>         </details></li></ol><p>会发现,这一阶段的cwnd是以2为次方的指数增长,学过数学的都知道<strong>指数爆炸</strong>吧,也就是越到后面变化的越夸张,所以我们也不能一直这样下去,需要设定一个<strong>阈值</strong>,当<strong>cwnd小于阈值</strong>的时候,使用<strong>慢启动算法</strong>,等<strong>大于阈值</strong>的时候,就需要用到<strong>拥塞避免</strong>算法<br>2. 拥塞避免:该算法就是为了防止<strong>指数爆炸</strong>的情况,其实也是一个cwnd增加的算法,不过该算法是<strong>线性增加</strong>的</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.jpg" class title="拥塞避免"><p>就这么一直增长着后,网络就会慢慢进入了拥塞的状况了,于是就会出现丢包现象,这时就需要对丢失的数据包进行重传<br><code>当触发了重传机制的时候,就会进入拥塞发生算法</code><br>3. 拥塞发生:</p><div class="tabs" id="tab-sixth-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#sixth-tabs-1">超时重传</a></li><li class="tab"><a class="#sixth-tabs-2">快速恢复</a></li></ul><div class="tab-content"><div class="tab-pane active" id="sixth-tabs-1"><p>当发送方经过一定时间(RTO)也没有收到ACK报文时,也就是<strong>超时</strong>了,就会使用<strong>拥塞发生算法</strong>,我们需要将<strong>原本慢启动的阈值</strong>变成cwnd的一半(cwnd&#x2F;2),然后重新从<strong>慢启动</strong>开始,如下所示:<br><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A01.jpg" class title="超时重传1"></p></div><div class="tab-pane" id="sixth-tabs-2"><p>使用<strong>超时重传</strong>的话,需要重新从<strong>慢启动</strong>开始,这很让人不甘心,在上面我们说过,如果在<strong>RTO时间</strong>内,接收到连续四个相同的ACK的话,就可以使用<strong>快速重传</strong>,同样的,当我们收到四个相同的ACK时候,我们会选择另一种<strong>拥塞发生</strong>算法:<strong>快速回复</strong><br>TCP认为这种情况不严重,因为大部分没丢,只丢了一小部分,则<strong>阈值</strong>和<strong>cwnd</strong>变化如下:</p><ol><li><strong>cwnd &#x3D; cwnd&#x2F;2 ,也就是设置为原来的一半</strong></li><li><strong>阈值 &#x3D; cwnd</strong></li></ol><p>进入快速恢复算法<br>算法如下:</p><ol><li>拥塞窗口 cwnd &#x3D; 阈值 + 3(3 的意思是确认有 3 个数据包被收到了)</li><li>重传丢失的数据包</li><li>如果再收到重复的 ACK,那么 cwnd 增加 1</li><li>如果收到新数据的 ACK 后,设置 cwnd 为 阈值,接着就进入了拥塞避免算法<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D.jpg" class title="快速恢复"></li></ol></div></div></div><p>整个过程如下:</p><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.jpg" class title="拥塞控制">              </div>            </details>
              </div>
            </details>

<h3 id="TCP的拆包和粘包问题"><a href="#TCP的拆包和粘包问题" class="headerlink" title="TCP的拆包和粘包问题"></a>TCP的拆包和粘包问题</h3><p>粘包:因为我们知道TCP是基于<strong>数据流</strong>的协议,发送端为了将多个发给接收端的包,更有效的发给对方,使用了优化方法(<strong>Nagle 算法</strong>),将多次间隔较小且数据量小的数据,合并成一个大的数据块,然后进行封包<br>这样做虽然提高了效率,但是接收端就<strong>难于分辨出完整的数据包</strong>了,因为面向流的通信是<strong>无消息保护边界的</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/%E7%B2%98%E5%8C%85.jpg" class title="粘包">

<p>假设客户端发送了两个数据包D1和D2，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p>
<ol>
<li>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，没有粘包和拆包</li>
<li>服务端一次接受到了两个数据包，<strong>D1和D2粘合</strong>在一起，称之为<strong>TCP粘包</strong></li>
<li>服务端分两次读取到了数据包，第一次读取到了<strong>完整的D1包和D2包的部分内容</strong>，第二次读取到了<strong>D2包的剩余内容</strong>，这称之为<strong>TCP拆包</strong></li>
<li>服务端分两次读取到了数据包，第一次读取到了<strong>D1包的部分内容D1_1</strong>，第二次读取到了<strong>D1包的剩余部分内容 D1_2 和完整的 D2 包</strong></li>
</ol>
<details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>导致出现粘包和拆包的原因 </summary>
              <div class="content">
              <ol><li>发送端等待缓冲区满才进行发送，造成粘包</li><li>接收方来不及接收缓冲区内的数据，会将一个数据包拆除几个小的数据包，造成拆包</li><li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li></ol>
              </div>
            </details>
<details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>解决粘包和拆包的办法 </summary>
              <div class="content">
              <ol><li><strong>发送定长包</strong>:如果每个消息的大小都是一样的，如果不够长就通过<strong>补充空格</strong>的方式来使其与其他数据包大小一致，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息</li><li><strong>包头加上包体长度</strong>:包头是定长的 4 个字节，说明了包体的长度。接收方先接收包头长度，依据包头长度来接收包体</li><li>在数据包之间设置边界，如添加特殊符号 \r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界</li><li>使用更加复杂的应用层协议</li></ol>
              </div>
            </details>

<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><h3 id="什么是UDP"><a href="#什么是UDP" class="headerlink" title="什么是UDP"></a>什么是UDP</h3><p><strong>UDP协议</strong>与<strong>TCP</strong>协议不同在，UDP协议是<strong>无连接</strong>，<strong>尽最大可能交付</strong>，<strong>面向报文</strong>的<strong>不可靠协议</strong></p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>无连接 </summary>
              <div class="content">
              <p>即发送数据之前不需要建立连接（当然，发送数据结束时也没有连接可释放），因此减少了开销和发送数据之前的时延</p>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>尽最大可能交付 </summary>
              <div class="content">
              <p>即不保证可靠交付，因此主机不需要维护复杂的连接状态表</p>
              </div>
            </details>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>面向报文 </summary>
              <div class="content">
              <p>发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不分拆，而是保留这些报文的边界。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文</p>
              </div>
            </details>

<h3 id="UDP头部"><a href="#UDP头部" class="headerlink" title="UDP头部"></a>UDP头部</h3><img lazyload src="/images/loading.svg" data-src="/2023/03/22/blog14/UDP.jpg" class title="UDP">
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>UDP头部字段 </summary>
              <div class="content">
              <ol><li>目标和源端口：主要是告诉 UDP 协议应该把报文发给哪个进程</li><li>包长度：该字段保存了 UDP 首部的长度跟数据的长度之和</li><li>校验和：校验和是为了提供可靠的 UDP 首部和数据而设计</li></ol>
              </div>
            </details>

<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><ol>
<li><p>连接</p>
<ol>
<li>TCP 是<strong>面向连接</strong>的传输层协议，传输数据前先要<strong>建立连接</strong></li>
<li>UDP 是<strong>不需要连接</strong>，<strong>即刻</strong>传输数据</li>
</ol>
</li>
<li><p>服务对象</p>
<ol>
<li>TCP 是<strong>一对一</strong>的两点服务，即一条连接只有两个端点</li>
<li>UDP 支持<strong>一对一、一对多、多对多</strong>的交互通信</li>
</ol>
</li>
<li><p>可靠性</p>
<ol>
<li>TCP 是<strong>可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达</strong></li>
<li>UDP 是<strong>尽最大努力交付</strong>，不保证可靠交付数据</li>
</ol>
</li>
<li><p>拥塞控制、流量控制</p>
<ol>
<li>TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。</li>
<li>UDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。</li>
</ol>
</li>
<li><p>首部开销</p>
<ol>
<li>TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。</li>
<li>UDP 首部只有 8 个字节，并且是固定不变的，开销较小</li>
</ol>
<p> 这也是为什么TCP头部有一个<strong>首部长度</strong>字段而UDP没有的原因，而UDP有<strong>包长度</strong>字段而TCP没有的原因也很简单:</p>
<ol>
<li>TCP数据长度&#x3D;IP总长度–IP首部长度-TCP首部长度(TCP有该字段)<br> <code>其中 IP 总长度 和 IP 首部长度，在 IP 首部格式是已知的</code></li>
<li>当然，UDP也可以通过该公式计算，但是!<strong>为了网络设备硬件设计和处理方便，首部长度需要是 4字节的整数倍</strong>,如果去掉了<strong>包长度</strong>，那首部长度就不是4字节的整数倍了</li>
</ol>
</li>
</ol>
<h2 id="TCP和UDP的应用场景"><a href="#TCP和UDP的应用场景" class="headerlink" title="TCP和UDP的应用场景"></a>TCP和UDP的应用场景</h2><ol>
<li>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：<ol>
<li>FTP 文件传输</li>
<li>HTTP &#x2F; HTTPS</li>
</ol>
</li>
<li>由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：<ol>
<li>包总量较少的通信，如 DNS 、SNMP 等</li>
<li>视频、音频等多媒体通信</li>
<li>广播通信</li>
</ol>
</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章花了我3天的时间来写，你别说，TCP要记的东西真的好多，不光是因为这个，也因为我最近写笔试写麻了，要不容易熬到周六了，周末还有一个腾讯的海笔，下周周五晚上直接两个笔试，我也只能选一个，大概率选阿里吧，大厂虐我千百遍，我待大厂如初恋捏，即使他们都是海笔，好像赶紧找一个实习啊，一点也不想去学校安排的那个破实习</p>
<p>明天周六啦!新海诚的电影上线啦!我明天要一个人去看!一个人怎么了，也没什么不好的嘛哈哈~<br>晚安，垃圾世界~</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下常用命令</title>
    <url>/2023/04/05/blog16/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1426022018&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>看了很多面经,看到面试官好像还蛮喜欢问一些Linux下的命令,以及一些笔试题都会考这个,而说实话我记得的Linux命令实在是不多,所以这篇文章就拿来记录一下学过和没学过的Linux命令吧,也方便以后不懂就直接看这篇文章</p>
<h2 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h2><p>在终端,我们的命令千奇百怪,但它们都遵循着一个规律,那就是都由3部分组成,如下:<br>command [-options] [parameter]<br>说明:</p>
<ol>
<li>command: 命令名,相应功能的英文单词或单词的缩写</li>
<li>-options: 选项,可用来对命令进行控制,也可以省略</li>
<li>parameter: 传给命令的<strong>参数</strong>,可以是<strong>零个,一个或者多个</strong><br><code>[]代表可有也可以没有</code></li>
</ol>
<h3 id="查阅命令帮助信息"><a href="#查阅命令帮助信息" class="headerlink" title="查阅命令帮助信息"></a>查阅命令帮助信息</h3><ol>
<li>-help:显示command命令的帮助信息</li>
<li>-man:<ol>
<li>查阅command命令的使用手册</li>
<li>包含了绝大部分<strong>命令</strong>,<strong>函数</strong>的使用方法</li>
</ol>
</li>
</ol>
<p>使用man时的操作</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/05/blog16/man.jpg" class title="man">

<h3 id="Linux常用命令-1"><a href="#Linux常用命令-1" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h3><ol>
<li><p>查看当前文件夹的内容</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ls [选项] [想要查看的文件夹的相对路径或者绝对路径]</span><br><span class="line"></span><br><span class="line">常用选项:</span><br><span class="line">1. -a:显示指定目录下所有子目录与文件,包括隐藏文件</span><br><span class="line">2. -l:以列表方式显示文件的详细信息</span><br><span class="line">3. -h:配合 -l 以人性化的方式显示文件大小</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查看当前文件夹的<strong>绝对路径</strong></p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure></div></li>
<li><p>切换文件夹</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cd [想要切换的文件夹的相对路径]</span><br><span class="line"></span><br><span class="line">1. cd </span><br><span class="line">    :切换到当前用户的主目录(/home/用户目录)</span><br><span class="line">2. cd ~</span><br><span class="line">    :切换到当前用户的主目录(/home/用户目录)</span><br><span class="line">3. cd .</span><br><span class="line">    :保持在当前目录不变</span><br><span class="line">4. cd ..</span><br><span class="line">    :切换到上级目录</span><br><span class="line"></span><br><span class="line">相对路径和绝对路径</span><br><span class="line">相对路径:在输入路径时,最前面不是 / 或者 ~,表示相对 当前目录 所在的目录位置</span><br><span class="line">绝对路径:在输入路径时,最前面是 / 或者 ~,表示从 根目录/家目录 开始的具体目录位置</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建一个文件</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">touch 文件名</span><br><span class="line"></span><br><span class="line">如果文件不存在,则创建一个空白的文件</span><br><span class="line">如果文件存在,则修改该文件的末次修改日期</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>创建一个空目录&#x2F;删除一个空目录</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir [选项] [路径]目录名</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">1. -p: 层级创建</span><br><span class="line">2. -v:显示创建顺序</span><br><span class="line">新建的文件夹名称不能与当前目录已有的目录或者文件同名</span><br><span class="line"></span><br><span class="line">rmdir [-p] [路径]目录名</span><br><span class="line">-p: 当子目录被删除后如果父目录也变成空目录的话,就连带父目录一起删除</span><br><span class="line">删除空目录 不能删除非空目录,不能删除文件</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>删除文件或者文件夹</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">rm [-选项] [文件名/文件夹名]</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">1. -r:递归地删除目录下的文件,删除文件夹的时候必须有这个选项</span><br><span class="line">2. -f:强制删除,忽略不存在的文件,无需提示</span><br><span class="line"></span><br><span class="line">rm命令不可逆,所以需要谨慎使用</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>将一个<strong>文件或者目录</strong>复制到另外一个<strong>文件或者目录</strong>下</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cp [选项] [想要复制的源文件的相对路径或者绝对路径] [目的文件或者文件夹的绝对路径或者相对路径]</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">1. -f或者--force:强行复制文件或目录, 不论目的文件或目录是否已经存在</span><br><span class="line">2. -i或者--interactive:覆盖文件之前先询问用户</span><br><span class="line">3. -r:若给出的源文件是目录文件,则 cp 将递归复制该目录下的所有子目录和文件,目标文件必须为一个目录名</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>移动文件,也可以给文件重命名</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mv [选项] [源文件的相对路径或者绝对路径] [目标文件的相对路径或者绝对路径]</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">1. -f:强制的意思,如果目标文件已经存在,不会询问而直接覆盖</span><br><span class="line">2. -i: 若目标文件(destination)已经存在时,就会询问是否覆盖</span><br><span class="line"></span><br><span class="line">如果是要移动文件,则目标文件不需要写文件名,表明路径就可以</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>查看文件内容、创建文件、文件合并、追加文件内容等功能</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">cat [选项] 文件名</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">1. -b:对非空输出行进行编号</span><br><span class="line">2. -n:对输出的所有行进行编号</span><br><span class="line"></span><br><span class="line">cat会一次显示所有的内容,适合查看内容较少的文本文件</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>搜索文本文件内容</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">grep [选项] &#x27;想要查找的字符串&#x27; 文件名</span><br><span class="line"></span><br><span class="line">允许对文本文件进行 模式查找,所谓模式查找,又被称为正则表达式</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">1. -a:将binary(二进制)文件以text文件的方式查找数据</span><br><span class="line">2. -c:计算找到 &#x27;想要查找的字符串&#x27; 的次数</span><br><span class="line">3. -i:忽略大小写的区别,即把大小写视为相同</span><br><span class="line">4. -v:反向选择,即显示出没有 &#x27;想要查找的字符串&#x27; 内容的那一行</span><br></pre></td></tr></table></figure></div></li>
<li><p>用来在指定目录下查找文件</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">find [路径] [选项] 操作</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">1. -name :后面的操作为在指定目录下想要查找的文件的名字</span><br><span class="line">2. -size :后面的操作为在指定目录下,文件大小大于某个值的文件,其中操作这一块就为(+一个值)</span><br><span class="line">    例如: -size +100k,表示查找文件大小大于100k的文件</span><br><span class="line">3. -ctime :查询指定目录下,在过去n天内被修改过的文件,其中操作处为n</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>修改用户对文件的权限</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">chmod [选项] 文件名</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">1. -r :赋予读取权限</span><br><span class="line">2. -w :赋予写入权限</span><br><span class="line">3. -x :赋予执行权限</span><br><span class="line">4. 777 :赋予可读、可写、可执行权限(读:4,写:2,执行:1)</span><br><span class="line"></span><br><span class="line">权限说明:(例:-rw-r--r-x 的权限为645)</span><br><span class="line"></span><br><span class="line">权限显示位一共为10位,分为四段,从第二位算起,每三个一组</span><br><span class="line">第1位代表文件类型(-表示为普通文件)</span><br><span class="line">第2-4位代表文件所属用户拥有的权限(rw-:4+2=6)</span><br><span class="line">第5-7位代表该用户所属组拥有的权限(-r--:4)</span><br><span class="line">第8-10位代表其他用户拥有的权限(r-x:4+1=5)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>用来列出系统中当前正在运行的那些进程,类似于 windows 的任务管理器</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ps [选项]</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">1. -A :列出所有的进程 </span><br><span class="line">2. -ef :查看全格式的全部进程 </span><br><span class="line">3. -w :显示加宽,可以显示较多的资讯</span><br><span class="line">4. -au :显示较详细的资讯</span><br><span class="line">5. -aux :显示所有包含其他使用者的进程</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>显示路由表、实际的网络连接以及每一个网络接口设备的状态信息</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">netstat [选项]</span><br><span class="line"></span><br><span class="line">选项:</span><br><span class="line">1. -a或者-all :显示所有连线中的Socket</span><br><span class="line">2. -A&lt;网络类型&gt;或--&lt;网络类型&gt;:列出该网络类型连线中的相关地址</span><br><span class="line">3. -c或--continuous:持续列出网络状态</span><br><span class="line">4. -C或--cache:显示路由器配置的快取信息</span><br><span class="line">5. -e或--extend:显示网络其他相关信息</span><br><span class="line">6. -l或--listening:显示监控中的服务器的Socket</span><br><span class="line"></span><br><span class="line">例如:</span><br><span class="line">1. netstat -a      # 列出所有端口</span><br><span class="line">2. netstat -at     # 列出所有TCP端口</span><br><span class="line">3. netstat -au    # 列出所有UDP端口</span><br><span class="line">4. netstat -ax    # 列出所有unix端口</span><br><span class="line">5. netstat -atnlp    # 直接使用ip地址列出所有处理监听状态的TCP端口,且加上程序名</span><br><span class="line"></span><br><span class="line">netstat的功能很强大,这里不方便详细说明,可以去网上查找更详细的资料</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="vim-x2F-vi-的常用命令"><a href="#vim-x2F-vi-的常用命令" class="headerlink" title="vim&#x2F;vi 的常用命令"></a>vim&#x2F;vi 的常用命令</h2><img lazyload src="/images/loading.svg" data-src="/2023/04/05/blog16/vi.jpg" class title="vi">

<h3 id="vim-x2F-vi-的使用"><a href="#vim-x2F-vi-的使用" class="headerlink" title="vim&#x2F;vi 的使用"></a>vim&#x2F;vi 的使用</h3><p>基本上 vi&#x2F;vim 共分为三种模式,分别是</p>
<ol>
<li>命令模式(Command mode)</li>
<li>输入模式(Insert mode)</li>
<li>底线命令模式(Lastline mode)</li>
</ol>
<p>它们的转换关系如下</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/05/blog16/%E8%BD%AC%E6%8D%A2.jpg" class title="转换">

<ol>
<li><p>命令模式<br>用户刚刚启动 vi&#x2F;vim,便进入了命令模式。此状态下敲击键盘动作会被Vim识别为命令,而非输入字符。比如我们此时按下i,并不会输入一个字符,i被当作了一个命令<br>常用的几个命令:</p>
</li>
<li><p>i :切换到输入模式,以输入字符。</p>
</li>
<li><p>x :删除当前光标所在处的字符。</p>
</li>
<li><p>: :切换到底线命令模式,以在最底一行输入命令。<br><code>若想要编辑文本:启动Vim,进入了命令模式,按下i,切换到输入模式</code></p>
<a class="button  regular" href="http://t.csdn.cn/rMiZG" title="更多命令模式下的操作">更多命令模式下的操作</a>
</li>
<li><p>输入模式<br><code>在命令模式下按下 i 就进入了输入模式</code><br>在输入模式中,可以使用以下按键:</p>
</li>
<li><p>字符按键以及Shift组合:输入字符</p>
</li>
<li><p>ENTER:回车键,换行</p>
</li>
<li><p>BACK SPACE:退格键,删除光标前一个字符</p>
</li>
<li><p>DEL:删除键,删除光标后一个字符</p>
</li>
<li><p>方向键:在文本中移动光标</p>
</li>
<li><p>HOME&#x2F;END:移动光标到行首&#x2F;行尾</p>
</li>
<li><p>Page Up&#x2F;Page Down:&#x2F;下翻页</p>
</li>
<li><p>Insert:切换光标为输入&#x2F;替换模式,光标将变成竖线&#x2F;下划线</p>
</li>
<li><p>ESC:退出输入模式,切换到命令模式</p>
</li>
<li><p>底线命令模式<br><code>在命令模式下按下:(英文冒号)就进入了底线命令模式</code><br>底线命令模式可以输入单个或多个字符的命令,可用的命令非常多。</p>
</li>
</ol>
<p>在底线命令模式中,基本的命令有(已经省略了冒号):</p>
<ol>
<li>q 退出程序</li>
<li>w 保存文件</li>
</ol>
<p><code>在后面加上!号代表强制操作</code><br>按ESC键可随时退出底线命令模式</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章是在我看到很多面经都有问到类似的问题才觉得应该整理一下一些命令，当然了，命令那么多，我自然没办法一次性记下来，以后遇到一些常用的命令还会继续在这篇文章上加上去的</p>
<p>原本是打算在动车上写的，但是动车上没有插座，我怕写一半没电了就没写了，说起来，在动车上还遇到一群旅游回来的川美学生，其中有一位漂亮的小姐姐还来找我要薯片吃哈哈，算是这辈子第一次被女生给主动搭话?</p>
<p>跑来重庆搞IOS开发，说实话，我对客户端属实兴趣不大，但相对于学校的什么粤嵌什么的，我还是觉得自己找个实习比较好，我也不知道自己这次的选择对不对，但是每个选择都只能等以后来判断，所以现在只能一条路走到底，当然了，既然选择了来实习，自然就要做到最好，况且公司福利不错，就是重新学一门知识，我还得保持每天刷题以及看会八股，对我来说也挺有挑战的，万一期间找到我更想去的实习又该怎么办呢？期末考试也还要跑回学校，提前一周去吧至少得，不然我觉得可能会挂科…还要想想找房子的事情，哎，算是开始从学生转变为一个初入社会的毛头小子了，只能慢慢适应啦</p>
<p>说起来，我可能不适合在重庆送外卖或者跑滴滴，今晚为了省钱，从地铁站走回住的地方，跟着导航走，我都能走1h，也就3km，太绕了，而且我总感觉不像是在城市里一样，走的路都没什么人，还有一段上山的路…太恐怖了，以后要是送外卖肯定会一直超时被罚钱的…</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>IP层(网络层)相关协议</title>
    <url>/2023/03/29/blog15/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=65800&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这周大概也就这一篇文章吧,已经月底了,什么时候才能找到实习呀(悲)!</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层在TCP&#x2F;IP协议中的位于第三层。在TCP&#x2F;IP协议中网络层可以进行网络连接的建立和终止以及IP地址的寻找等功能,因为在网络层中<strong>IP协议</strong>是最重要的协议,所以我们一般又把网络层叫做”IP层”,当然了,网络层除了<strong>IP协议</strong>,自然也有其他协议,例如<strong>ICMP协议</strong>,<strong>ARP协议</strong>,<strong>RARP协议</strong>等等,这里就主要讲一下<strong>IP协议</strong>、<strong>ICMP协议</strong>和<strong>ARP协议吧</strong></p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>在去了解IP协议之前,我们得先需要知道什么是<strong>IP地址</strong></p>
<p><strong>IP地址</strong>是指<strong>互联网协议地址</strong>,又称为<strong>网络协议地址</strong>。IP地址是IP协议提供的一种统一的地址格式,<strong>它为互联网上的每一个网络和每一台主机分配一个逻辑地址(不是真实的)</strong>,以此来屏蔽物理地址(MAC地址)的差异</p>
<p>IPv4地址是一个<strong>32位</strong>的二进制数(4个字节),通常被分割为4个<strong>8位二进制数</strong>,IP 地址在计算机是以二进制的方式处理的</p>
<p>而人类为了方便记忆采用了点分十进制的标记方式,也就是将<strong>32位IP地址</strong>以<strong>每8位</strong>为组,共分为4组,每组以「.」隔开,再将每组转换成十进制</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/IP.jpg" class title="IP">
<p><code>所以,IP地址最多有2^32=4294967296,大约是43亿,也就是说可以有43亿台计算机联入互联网中</code></p>
<p>但实际上,IP地址并不是根据主机数来分配的,而是根据<strong>网卡</strong>来分配的,而一个网卡其实可以分配多个IP地址,而一台路由器或者服务器往往有着2个以上的网卡,也就是说他们一般有2个以上的IP地址</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E7%BD%91%E5%8D%A1.jpg" class title="网卡">

<h3 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h3><p>一开始,IP地址还是很富足的,所以科学家们根据<strong>网络号+主机号</strong>对IP地址进行了一个分类<br>分别为A类,B类,C类,D类,E类</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.jpg" class title="IP地址分类">

<p>它们每个类对应的IP地址范围</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/IP%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4.jpg" class title="IP地址范围">

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>如何计算最大主机数 </summary>
              <div class="content">
              <p>想要计算最大主机数,我们必须知道,<strong>IP地址被分成网络号+主机号</strong>,所以,要根据IP地址分类来计算,例如<br>B类地址,在B类地址中我们知道,<strong>网络号为前16个字节,最前面两个字节必须为10</strong>,所以剩下16位就是主机号,所以理论上来说,B类地址最多可以有2^16,但实际上我们还需要<strong>减2</strong>,所以实际上就只有(2^16-2)个主机</p><p>为什么要减2呢?<br>这是因为有两个特殊的IP地址,是不允许作为某一个主机的IP地址的,分别就是:<strong>主机号全为0</strong>和<strong>主机号全为1</strong>的两个IP地址,就拿B类地址来说,<strong>xxx.xxx.0.0</strong>和<strong>xxx.xxx.255.255</strong>就是这中特殊的地址<br>一般来说:<br><strong>主机号全为1</strong>的IP地址一般是用于广播的IP地址,是指某个网络下的所有主机<br><strong>主机号全为0</strong>的IP地址用来指定某个网络</p><p><code>所以再给某一网络的主机分配IP地址的时候,这两个特殊地址是不会分配的</code></p><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>广播地址的作用 </summary>              <div class="content">              <p><code>广播地址用于在同一个链路中相互连接的主机之间发送数据包</code><br>广播地址分为<strong>本地广播</strong>和<strong>直接广播</strong></p><ol><li>本地广播: 在本网络内广播的叫做<strong>本地广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的情况下,广播地址是 192.168.0.255 。<strong>因为这个广播地址的 IP 包会被路由器屏蔽</strong>,所以不会到达 192.168.0.0&#x2F;24 以外的其他链路上</li><li>直接广播: 在不同网络之间的广播叫做<strong>直接广播</strong>。例如网络地址为 192.168.0.0&#x2F;24 的主机向 192.168.1.255&#x2F;24 的目标地址发送 IP 包。收到这个包的路由器,将数据转发给192.168.1.0&#x2F;24,从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包(<code>由于直接广播有一定的安全问题,多数情况下会在路由器上设置为不转发</code>)<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E5%B9%BF%E6%92%AD.jpg" class title="广播"></li></ol>              </div>            </details>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>什么是D、E类地址 </summary>
              <div class="content">
              <p>因为D、E类地址是<strong>没有主机号</strong>的,所以不可用于当作主机的IP地址<br>D类地址一般用于<strong>多播</strong><br>E类地址是预留的分类,暂时没用</p><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>多播 </summary>              <div class="content">              <p>多播和广播不同,多播<strong>用于将包发送给特定组内的所有主机</strong>,多播有时候也叫做<strong>组播</strong><br>举个例子,当我们在上课的时候,老师喊“上课,起立”的时候,我们整个班级所有人都会起立,而这就是<strong>广播</strong>,是给全班所有人听的,当老师喊“第一排坐下”的时候,只有第一排坐下了,其他人还是站着的,而这就是<strong>多播</strong>,是给指定某一特定的人群听的</p><p><code>由于广播无法穿透路由,若想给其他网段发送同样的包,就可以使用可以穿透路由的多播(组播)</code><br><img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E7%BB%84%E6%92%AD.jpg" class title="组播"></p><p>多播使用的 D 类地址,其前四位是 1110 就表示是多播地址,而剩下的 28 位是多播的组编号。<br>从 224.0.0.0 ~ 239.255.255.255 都是多播的可用范围,其划分为以下三类</p><ol><li>224.0.0.0 ~ 224.0.0.255 为<strong>预留的组播地址</strong>,只能在局域网中,路由器是不会进行转发的</li><li>224.0.1.0 ~ 238.255.255.255  为<strong>用户可用的组播地址</strong>,可以用于<strong>Internet</strong>上</li><li>239.0.0.0 ~ 239.255.255.255 为<strong>本地管理组播地址</strong>,可供内部网在内部使用,<strong>仅在特定的本地范围内有效</strong></li></ol>              </div>            </details>
              </div>
            </details>

<p>这样分类有优点,也有缺点</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优点 </summary>
              <div class="content">
              <p>不管是路由器还是主机解析到一个 IP 地址时候,我们判断其 IP 地址的首位是否为 0,为0则为A类地址,那么就能很快的找出网络地址和主机地址,其他类同理,如果第一位为1,就判断第二位是否为0,是就为B类地址,以此类推<br><img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E4%BC%98%E7%82%B9.jpg" class title="优点"></p><p>所以,这种分类地址的优点就是<strong>简单明了、选路(基于网络地址)简单</strong></p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>缺点 </summary>
              <div class="content">
              <p>缺点一:<br><strong>同一网络下没有地址层次</strong>,比如一个公司里用了 B 类地址,但是可能需要根据生产环境、测试环境、开发环境来划分地址层次,而这种 IP 分类是没有地址层次划分的功能,所以这就<strong>缺少地址的灵活性</strong><br>缺点二:<br>这样分类与现实不匹配<br>C类地址最大容纳的主机也才254个,其实是很少了,一个稍微大点的网吧都不够<br>B类地址最大容纳的主机有2^16-2个,将近6万个,这就又太多了,6万多台机器放到一个网络下面,恐怕也就BAT这种大厂能做到了吧</p>
              </div>
            </details>

<p>在这种分类方法下,实际上是由<strong>公用IP地址</strong>和<strong>私用IP地址</strong>之分的</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E7%A7%81%E6%9C%89IP.jpg" class title="私有">
<p>平时我们办公室、家里、学校用的 IP 地址,一般都是<strong>私有 IP 地址</strong>。因为这些地址允许组织内部的 IT 人员自己管理、自己分配,而且<strong>可以重复</strong>。因此,你学校的某个私有 IP 地址和我学校的可以是一样的</p>
<p>就像每个小区都有自己的楼编号和门牌号,你小区家可以叫  1 栋 101 号,我小区家也可以叫 1 栋 101,没有任何问题。但一旦出了小区,就需要带上中山路 666 号（公网 IP 地址）,是国家统一分配的,不能两个小区都叫中山路 666</p>
<p>所以,公有 IP 地址是有个组织统一分配的,假设你要开一个博客网站,那么你就需要去申请购买一个公有 IP,这样全世界的人才能访问。并且公有 IP 地址基本上要在整个互联网范围内保持唯一</p>
<h3 id="CIDR无分类地址"><a href="#CIDR无分类地址" class="headerlink" title="CIDR无分类地址"></a>CIDR无分类地址</h3><p>为了解决IP地址分类的缺点,后面科学家们就提出了<strong>CIDR无分类地址</strong><br><code>这种方式不再有分类地址的概念,32 比特的 IP 地址被划分为两部分,前面是网络号,后面是主机号</code></p>
<p>而这要如何区分网络号和主机号呢?<br>科学家们是这样做的,将IP地址表示为(<strong>a.b.c.d&#x2F;x</strong>),其中,x表示<strong>前x位为网络号</strong>,范围为0~32,这就使得IP地址更加灵活,例如下面</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/CIDR.jpg" class title="CIDR">
<p>上图中的<strong>子网掩码</strong>也是用来划分<strong>网络号和主机号</strong>的另外一种方式,掩码的意思就是掩盖掉主机号,剩余的就是网络号<br>只要将子网掩码和IP地址<strong>相与</strong>一下,得到的结果就是<strong>网络号</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81.jpg" class title="子网掩码">

<p>知道了IP地址的分类方法,有没有想过科学家为什么要将IP地址分为<strong>网络号+主机号</strong>呢?</p>
<details class="orange" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么要分网络号和主机号 </summary>
              <div class="content">
              <p>因为两台计算机要通讯,首先要判断是否处于同一个广播域内,即网络地址是否相同。如果网络地址相同,表明接受方在本网络上,那么可以把数据包直接发送到目标主机</p><p>路由器寻址工作中,也就是通过这样的方式来找到对应的网络号的,进而把数据包转发给对应的网络内<br><img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E7%BD%91%E7%BB%9C%E5%8F%B7.jpg" class title="网络号"></p>
              </div>
            </details>

<p>在上面我们知道<strong>子网掩码</strong>可以划分网络号和主机号,但其实还可以用来<strong>划分子网</strong>,当然了,这就要用到IP地址中的地址分类了<br><code>子网划分实际上是将主机地址分为两个部分:子网网络地址和子网主机地址</code><br>大概是这样</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86.jpg" class title="子网划分">
<ol>
<li>未做子网划分的 ip 地址:网络地址＋主机地址</li>
<li>做子网划分后的 ip 地址:网络地址＋(子网网络地址＋子网主机地址)</li>
</ol>
<p>我们以C类地址为例,将C类地址进行子网划分,假设IP地址为192.168.1.0,子网掩码为255.255.255.192</p>
<p>C 类地址中<strong>前24位是网络号</strong>,<strong>最后8位是主机号</strong>,根据子网掩码可知<strong>从8位主机号中借用2位作为子网号</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E5%AD%90%E7%BD%91%E5%88%92%E5%88%861.jpg" class title="子网划分1">
<p>所以子网就有四个,分别为00,01,10,11</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E5%AD%90%E7%BD%91.jpg" class title="子网">

<h3 id="IP地址与路由控制"><a href="#IP地址与路由控制" class="headerlink" title="IP地址与路由控制"></a>IP地址与路由控制</h3><p>IP地址的<strong>网络地址</strong>这一部分是用于进行<strong>路由控制</strong><br><code>路由控制表中记录着网络地址与下一步应该发送至路由器的地址,在主机和路由器上都会有各自的路由器控制表</code><br>当我们发送IP数据包的时候,会先检查IP数据包中的首部中的<strong>目标地址</strong>,然后在路由控制表中查找该目标地址对应的<strong>下一跳</strong>的地址,也就是下一次IP数据包的转发应该给哪个路由器或者说是主机(我们在网络中发送数据的时候是不可能一次性直接到目标主机,而是需要数据包在网络中进行跳转)</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/%E8%B7%AF%E7%94%B1%E6%8E%A7%E5%88%B6.jpg" class title="路由控制">

<ol>
<li><p>主机 A 要发送一个IP包,其源地址是 10.1.1.30 和目标地址是 10.1.2.10,由于没有在主机 A 的路由表找到与目标地址 10.1.2.10 的网络地址匹配的条目,于是把数据包转发到默认路由(路由器1)(<strong>一般为0.0.0.0</strong>)</p>
</li>
<li><p>路由器1收到IP包后,也在路由器1的路由表匹配与目标地址相同的网络地址记录,发现匹配到了,于是就把 IP 数据包转发到了 10.1.0.2 这台路由器2</p>
</li>
<li><p>路由器2收到后,同样对比自身的路由表,发现匹配到了,于是把IP包从路由器2的 10.1.2.1 这个接口出去,最终经过交换机把 IP 数据包转发到了目标主机</p>
</li>
</ol>
<p><code>如果路由控制表中存在多条相同网络地址的记录,就选择相同位数最多的网络地址,也就是最长匹配</code></p>
<h3 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h3><p>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址</p>
<p>计算机使用一个特殊的IP地址<strong>127.0.0.1</strong>作为环回地址,与该地址具有相同意义的是一个叫做<strong>localhost</strong>的主机名</p>
<p><code>使用这个 IP 或主机名时,数据包不会流向网络</code></p>
<p>介绍完了IP地址,接下来看看IP协议吧</p>
<h2 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h2><p><strong>IP协议</strong>是为计算机网络相互连接进行通信而设计地协议,<code>在因特网上,它是能使连接到网上的所有计算机网络实现相互通信的一套规则</code>,规定了计算机在因特网上进行通信时应当遵守的规则。</p>
<p>IP协议实际上是一套由<strong>软件程序</strong>组成的协议软件,它把<strong>各种不同的帧(不同的厂家生产的网络系统和设备所传输的数据的基本单位的不同)<strong>统一转化位</strong>IP数据报</strong>格式,这种转换时因特网的一个<strong>最重要</strong>的特点,使得所有各种机器都能在因特网上相互通信,<strong>即具有”开放性”的特点</strong>。因此,IP协议也可以叫做<strong>因特网协议</strong></p>
<h3 id="IP首部"><a href="#IP首部" class="headerlink" title="IP首部"></a>IP首部</h3><img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/IP%E9%A6%96%E9%83%A8.jpg" class title="IP首部">
<details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>首部详解 </summary>
              <div class="content">
              <p>IP数据包首部固定长度为20字节,不包括可变长度(最大40字节)</p><ol><li>版本号: 4位,用于标识IP协议版本,IPv4是0100,IPv6是0110,也就是二进制下的4和6</li><li>首部长度: 4位,用于标识首部的长度,单位为4字节,所以首部长度最大值为:(2^4 - 1) * 4 &#x3D; 60字节,但一般只推荐使用20字节的固定长度,类似于<strong>TCP协议头部的首部长度字段</strong></li><li>区分服务: 8位,用于标识IP包的优先级,但现在并未使用</li><li>总长度: 标识IP数据报(包含数据)的总长度,最大为:2^16 -1 &#x3D; 65535字节</li><li>标识: 16位,用于标识IP数据报,如果因为数据链路层帧数据段长度限制(也就是MTU,支持的最大传输单元),IP数据报需要进行分片发送,则每个分片的IP数据报标识都是一致的</li><li>标志: 3位,但目前只有2位有意义,最低位为MF,MF&#x3D;1代表后面还有分片的数据报,MF&#x3D;0代表当前数据报已是最后的数据报;次低位为DF,DF&#x3D;1代表不能分片,DF&#x3D;0代表可以分片</li><li>片位移: 13位,代表某个分片在原始数据中的相对位置</li><li>生存时间: 8位,以前代表IP数据报最大的生存时间,现在标识IP数据报可以经过的路由器数</li><li>协议: 8位,<strong>代表上层传输层协议的类型</strong>,1代表ICMP,2代表IGMP,6代表TCP,17代表UDP</li><li>首部检验和: 16位,用于验证数据完整性,和TCP的检验和首部字段功能一样</li><li>源IP地址: 32位,代表数据包是从哪个IP地址对应的主机上发出的</li><li>目的IP地址: 32位,代表该数据包最后应该到哪个IP地址对应的主机上</li></ol>
              </div>
            </details>

<p>其实IP协议我感觉没什么好讲的,最主要的是一些与IP协议相关的重要且常见的技术</p>
<h2 id="IP协议相关的技术"><a href="#IP协议相关的技术" class="headerlink" title="IP协议相关的技术"></a>IP协议相关的技术</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>点击下面按钮观看哦,这个之前写过的</p>
<a class="button  regular" href="https://qx-gg.github.io/2023/03/16/blog13" title="DNS">DNS</a>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>在传输一个<strong>IP数据报</strong>的时候,确定了<strong>源IP地址</strong>和<strong>目标IP地址</strong>后,就会通过<strong>主机路由表</strong>确定 IP 数据包下一跳。然而,网络层的下一层是数据链路层,所以我们还要知道<strong>下一跳的MAC地址</strong></p>
<p>由于主机的路由表中可以找到下一条的 IP 地址,所以可以通过<strong>ARP协议</strong>,求得下一跳的 MAC 地址</p>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>ARP如何知道对方的MAC地址? </summary>
              <div class="content">
              <p>ARP 是借助<strong>ARP 请求</strong>与<strong>ARP 响应</strong>两种类型的包确定 MAC 地址的<br><img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/ARP.jpg" class title="ARP"></p><ol><li><p>主机会通过广播发送 ARP 请求,这个包中包含了想要知道的 MAC 地址的主机 IP 地址</p></li><li><p>当同个链路中的所有设备收到 ARP 请求时,会去拆开 ARP 请求包里的内容,如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致,那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机</p></li><li><p>操作系统通常会把第一次通过 ARP 获取的 MAC 地址缓存起来(也就是保存在ARP缓存表中),以便下次直接从缓存中找到对应 IP 地址的 MAC 地址</p></li><li><p>不过,MAC 地址的缓存是有一定期限的,超过这个期限,缓存的内容将被清除</p></li></ol>
              </div>
            </details>
<h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><p>和ARP刚好相反,它是已知 MAC 地址求 IP 地址,例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到<br>通常这需要架设一台<strong>RARP服务器</strong>,在这个服务器上注册设备的<strong>MAC 地址及其 IP 地址</strong>。然后再将这个设备接入到网络,接着:</p>
<ol>
<li>该设备会发送一条「我的 MAC 地址是XXXX,请告诉我,我的IP地址应该是什么」的请求信息</li>
<li>RARP 服务器接到这个消息后返回「MAC地址为 XXXX 的设备,IP地址为 XXXX」的信息给这个设备</li>
</ol>
<p>最后,设备就根据从 RARP 服务器所收到的应答信息设置自己的 IP 地址</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/RARP.jpg" class title="RARP">

<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>我们的电脑通常都是通过<strong>DHCP</strong>动态获取IP地址，大大省去了配 IP 信息繁琐的过程<br>我们来看看一台新的电脑练到互联网上的时候要如何知道自己的IP地址<br><code>先说明一点，DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号</code><br>过程:</p>
<ol>
<li>客户端首先发起<strong>DHCP发现报文(DHCP DISCOVER)<strong>的IP数据报，由于</strong>客户端没有IP地址，也不知道DHCP服务器的地址</strong>，所以使用的是<strong>UDP广播通信</strong>，其使用的广播目的地址是<strong>255.255.255.255(端口 67)</strong> 并且使用 **0.0.0.0(端口 68)**作为源 IP 地址。DHCP 客户端将该 IP 数据报传递给链路层，链路层然后将帧广播到所有的网络中设备</li>
<li>互联网上所有的DHCP服务器都会收到这个报文，用<strong>DHCP提供报文(DHCP OFFER)<strong>向客户端做出响应。该报文仍然使用IP广播地址255.255.255.255(目的IP地址)，源IP地址就是自己的IP地址，该报文信息携带服务器提供可</strong>租约的IP地址、子网掩码、默认网关、DNS服务器以及IP地址租用期</strong>，注意，每个DHCP都会发送一个报文</li>
<li>客户端收到一个或多个服务器的<strong>DHCP提供报文</strong>后，从中选择一个服务器，并向选中的服务器发送**DHCP请求报文(DHCP REQUEST)**进行响应，回显配置的参数</li>
<li>最后，服务端用<strong>DHCP ACK报文</strong>对 DHCP 请求报文进行响应，应答所要求的参数<br><code>一旦客户端收到 DHCP ACK 后，交互便完成了，并且客户端能够在租用期内使用 DHCP 服务器分配的 IP 地址</code></li>
</ol>
<p>如果租约的<strong>DHCP IP地址</strong>快过期后，客户端会向服务器发送 DHCP 请求报文:</p>
<ol>
<li><p>服务器如果同意继续租用，则用 DHCP ACK 报文进行应答，客户端就会延长租期</p>
</li>
<li><p>服务器如果不同意继续租用，则用 DHCP NACK 报文，客户端就要停止使用租约的 IP 地址<br><code>整个过程中,都是使用UDP广播通信</code></p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>DHCP中继代理 </summary>
              <div class="content">
              <p>因为路由器不会转发广播报文，所以UDP广播报文不会被不同网络下的DHCP接收到，而为了解决这个问题，DHCP中继代理就出现了<br>有了 DHCP 中继代理以后，<strong>对不同网段的 IP 地址分配也可以由一个 DHCP 服务器统一进行管理</strong><br><img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/DHCP.jpg" class title="DHCP"></p><ol><li>DHCP 客户端会向 DHCP 中继代理发送 DHCP 请求包，而 DHCP 中继代理在收到这个广播包以后，再以<strong>单播</strong>的形式发给 DHCP 服务器</li><li>服务器端收到该包以后再向 DHCP 中继代理返回应答，并由 DHCP 中继代理将此包转发给 DHCP 客户端<br><code>因此，DHCP 服务器即使不在同一个链路上也可以实现统一分配和管理IP地址</code></li></ol>
              </div>
            </details></li>
</ol>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>因为<strong>IP协议</strong>并不是一个可靠的协议，它不保证数据能够被送达，虽然IP头部有检验和的字段，但这只能保证数据不被更改，但不能保证数据不会再传输过程中丢失，所以，保证数据送达的工作应该由其他模块来实现，其中一个重要的模块就是<strong>TCMP协议(互联网控制报文协议)</strong></p>
<h4 id="ICMP头部"><a href="#ICMP头部" class="headerlink" title="ICMP头部"></a>ICMP头部</h4><p>ICMP 报文是封装在 IP 包里面</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/ICMP%E5%A4%B4%E9%83%A8.jpg" class title="ICMP头部">
<p>其中类型有以下几种</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/ICMP%E7%B1%BB%E5%9E%8B.jpg" class title="ICMP类型">
<h4 id="ICMP协议功能"><a href="#ICMP协议功能" class="headerlink" title="ICMP协议功能"></a>ICMP协议功能</h4><p>ICMP 主要的功能包括:确认<strong>IP包</strong>是否成功送达目标地址、报告发送过程中<strong>IP包</strong>被废弃的原因和改善网络设置等</p>
<p>在 IP 通信中如果某个 IP 包因为某种原因未能达到目标地址，那么这个具体的原因将由 ICMP 负责通知</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/ICMP.jpg" class title="ICMP">

<p>如上图例子，主机 A 向主机 B 发送了数据包，由于某种原因，途中的路由器 2 未能发现主机 B 的存在，这时，路由器 2 就会向主机 A 发送一个 ICMP 目标不可达数据包，说明发往主机 B 的包未能成功</p>
<p>ICMP 的这种通知消息会使用 IP 进行发送 </p>
<p>因此，从路由器 2 返回的 ICMP 包会按照往常的路由控制先经过路由器 1 再转发给主机 A 。收到该 ICMP 包的主机 A 则分解 ICMP 的首部和数据域以后得知具体发生问题的原因</p>
<h4 id="ICMP类型"><a href="#ICMP类型" class="headerlink" title="ICMP类型"></a>ICMP类型</h4><p>TCMP报文大致分为两类:<strong>查询报文</strong>和<strong>差错报文</strong></p>
<p>查询报文的用途:</p>
<ol>
<li>ping查询</li>
<li>子网掩码查询</li>
<li>时间戳查询</li>
</ol>
<p>差错报文的用途:在数据传送过程发生错误时会产生差错报文</p>
<details class="black" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>查询报文的类型 </summary>
              <div class="content">
              <ol><li>0和8:回送消息，回送消息用于进行通信的主机或路由器之间，判断所发送的数据包是否已经成功到达对端的一种消息，ping 命令就是利用这个消息实现的<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/ICMP%E5%9B%9E%E9%80%81.jpg" class title="ICMP回送">可以向对端主机发送**回送请求**的消息（ICMP Echo Request Message，类型 8），也可以接收对端主机发回来的**回送应答**消息（ICMP Echo Reply Message，类型 0）<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/ICMP%E6%8A%A5%E6%96%87.jpg" class title="ICMP报文">相比原生的 ICMP，这里多了两个字段：</li><li>标识符：用以区分是哪个应用程序发 ICMP 包，比如用进程 PID 作为标识符</li><li>序号：序列号从 0 开始，每发送一次新的回送请求就会加 1， 可以用来确认网络包是否有丢失</li></ol><p>在选项数据中，ping 还会存放发送请求的时间值，来计算往返时间，说明路程的长短</p>
              </div>
            </details>
<h4 id="TCMP的应用之一—ping"><a href="#TCMP的应用之一—ping" class="headerlink" title="TCMP的应用之一—ping"></a>TCMP的应用之一—ping</h4><p>举个例子来看看ping是如何工作的吧<br>同个子网下的主机 A 和 主机 B，主机 A 执行ping 主机 B 后</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/ping.jpg" class title="ping">
<ol>
<li><p>ping 命令执行的时候，源主机首先会构建一个 ICMP 回送请求消息数据包,其中ICMP数据包内包含多个字段，最重要的两个为:</p>
</li>
<li><p>第一个是类型，对于回送请求消息而言该字段为 8</p>
</li>
<li><p>另外一个是序号，主要用于区分连续 ping 的时候发出的多个数据包<br>每发出一个请求数据包，序号会自动加 1。为了能够计算往返时间 RTT，它会在报文的数据部分插入发送时间</p>
</li>
<li><p>然后，由ICMP协议将这个数据包连同地址 192.168.1.2 一起交给 IP 层。IP 层将以 192.168.1.2 作为目的地址，本机 IP 地址作为源地址，协议字段设置为 1 表示是 ICMP 协议，在加上一些其他控制信息，构建一个 IP 数据包</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/IP%E6%95%B0%E6%8D%AE%E5%8C%85.jpg" class title="IP数据包">
</li>
<li><p>接下来就是在数据链路层加入<strong>MAC头</strong>。如果在本地 ARP 映射表中查找出 IP 地址 192.168.1.2 所对应的 MAC 地址，则可以直接使用；如果没有，则需要发送 ARP 协议查询 MAC 地址，获得 MAC 地址后，由数据链路层构建一个数据帧，目的地址是 IP 层传过来的目的IP地址对应的 MAC 地址，源地址则是本机的 MAC 地址；还要附加上一些控制信息，依据以太网的介质访问规则，将它们传送出去</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/MAC.jpg" class title="MAC"></li>
<li><p>主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。</p>
</li>
<li><p>接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。</p>
</li>
<li><p>主机 B 会构建一个 ICMP 回送响应消息数据包，回送响应数据包的类型字段为 0，序号为接收到的请求数据包中的序号，然后再发送出去给主机 A</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/29/blog15/ICMP%E5%93%8D%E5%BA%94.jpg" class title="ICMP响应"></li>
</ol>
<p>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达；如果接收到了 ICMP 回送响应消息，则说明目标主机可达。</p>
<p>此时，源主机会检查，用当前时刻减去该数据包最初从源主机上发出的时刻，就是 ICMP 数据包的<strong>时间延迟</strong></p>
<p>当然，在不同网段的传输还涉及了路由器之间的跳转，网关之间的转发，但是这对ICMP报文来讲没有任何影响，而这就是ping的整个过程</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最近一直在关于ChatGPT的视频，不得不感慨可能我要见证一个新的时代的发生了，有可能会被叫做第四次工业革命呢，不知道对我国的影响是如何的，AI真的很强，搞得我对AI也有兴趣了，历史的潮流中，我们只能做到不要淹死在里面，未来会怎么样，尽请期待吧</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>实习日记1</title>
    <url>/2023/04/15/blog17/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=5251447&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是来到公司的第一个星期，由于我是一个新来的，再加上之前完全没有接触过IOS开发，所以只能从零开始学习关于IOS开发的一些知识</p>
<h2 id="Swift语言"><a href="#Swift语言" class="headerlink" title="Swift语言"></a>Swift语言</h2><p>Swift语言是苹果公司开发的一门语言，适用于IOS编程，其特点就是简单易懂，我个人感觉个Golang语言很像，好在之前学过一段时间的Golang，所以现在学这个也并不是特别吃力，但是我也不能说就掌握了这门语言，所以还需要多写代码来让自己熟悉</p>
<h2 id="UIkit"><a href="#UIkit" class="headerlink" title="UIkit"></a>UIkit</h2><p>UIkit可以很方便IOS开发者进行界面的布局，自己也看了一些视频写了一些demo，因为是客户端开发，所以我还需要学很多东西，慢慢学吧，UIkit很难用文字来描述清楚，如果想要让大家看懂可能需要写很多很多，而本人自己也并不是特别熟悉，所以我也就不写这种知识点了</p>
<p>来了一周了，体验到了社畜的感觉，每天生活日复一日，倒也不是说多讨厌这种生活，但也绝对说不上喜欢，当然这是我自己的问题，不管公司的事，公司工作氛围挺好的，而且福利也很不错，就是周边吃的有点少，每次午饭都要考虑很久要吃什么，还有就是我在考虑要不要转客户端去，服务端太难找了</p>
<p>现在比较烦恼的事情就是月底学校分散实习好像要答辩，tmd为什么不能线上啊？傻逼学校，屁事一堆，好好实习都不允许，等要毕业了又催着我们不考研的去找工作，什么脑瘫政策</p>
<p>这周实习也没接收什么实质性的工作，所以篇幅很少，就当作一周的一个小总结吧，可以拿来当作一篇随笔看？</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下的“库”和“链接”</title>
    <url>/2023/02/24/blog2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&id=1922888354&auto=1&height=66"></iframe>

<h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><p>1.库是计算机上的一类文件，可以简单地把库当作代码仓库，提供给使用者一些可以直接使用的变量、函数或者类。</p>
<p>2.库是一种特殊的一种程序，编写库的程序和编写普通程序的差别不大，只是库不能单独运行。</p>
<p>3.库分为：静态库和动态库。区别在于静态库在程序的链接阶段被复制到程序中，动态库则没有被复制，而是在程序每次运行的时候由系统动态加载到内存中供程序使用</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/24/blog2/1.jpg" class title="图片1">

<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>库的好处 </summary>
              <div class="content">
              <ol><li>库里面的代码比较保密，不容易被看到</li><li>方便程序的部署和分发</li></ol>
              </div>
            </details>

<h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>1.在Linux下，静态库一般写为：libxxx.a<br>    lib：前缀，是固定的，每个静态库都有；xxx：静态库的名称；.a：固定后缀）<br>2.在Window下，静态库一般为：libxxx.lib，与上面的相比，只有后缀是不同的</p>
<h3 id="静态库的制作"><a href="#静态库的制作" class="headerlink" title="静态库的制作"></a>静态库的制作</h3><ol>
<li>首先需要将写好的程序编译成.o文件，也就是上图中倒数第二步形成的文件</li>
<li>使用ar工具，将.o文件打包<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">g++/gcc -c xxx -o xxx.o</span><br><span class="line">ar rcs libxxx.a xxx.o</span><br><span class="line">(r:将文件插入备存文件中   c:建立备存文件   s:索引)</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="静态库的使用"><a href="#静态库的使用" class="headerlink" title="静态库的使用"></a>静态库的使用</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">g++/gcc xxx -o xxx.out -L 库的路径 -l 库的名称(libxxx.a中的xxx就是库的名称) [-I 头文件的路径](在同个目录下就不需要这一项)</span><br></pre></td></tr></table></figure></div>
<h3 id="做个简单的测试"><a href="#做个简单的测试" class="headerlink" title="做个简单的测试"></a>做个简单的测试</h3><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>head.h </summary>
              <div class="content">
              <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span>&amp; a,<span class="type">int</span> &amp;b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span>;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>add.cpp </summary>
              <div class="content">
              <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>sub.cpp </summary>
              <div class="content">
              <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> &amp;a,<span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>main.cpp </summary>
              <div class="content">
              <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;head.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">10</span>,b=<span class="number">10</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(a,b)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sub</span>(a,b)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<p>1.将add.cpp 和sub.cpp 封装成静态库</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">g++ -c add.cpp -o add.o</span><br><span class="line">g++ -c sub.cpp -o sub.o</span><br><span class="line"></span><br><span class="line">ar rcs libadd.a add.o</span><br><span class="line">ar rcs libsub.a sub.o</span><br></pre></td></tr></table></figure></div>

<p>2.将main.cpp编译成可执行文件（此时main.cpp里面使用到了add.cpp和sub.cpp，所以需要用到libadd.a和libsub.a）</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">g++ main.cpp -o main.out -L ./ -l add -l sub -I ./</span><br><span class="line">./main.out</span><br><span class="line">输出：  20</span><br><span class="line">        0</span><br></pre></td></tr></table></figure></div>
<h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><h3 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h3><ol>
<li>在Linux下，动态库一般为libxxx.so，除了后缀不同，其他是一样的</li>
<li>在Window下，一般为libxxx.dll</li>
</ol>
<h3 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h3><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>gcc得到.o文件，与静态库不同的是，这个过程需要得到的是与位置无关的代码 </summary>
              <div class="content">
              <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc/g++ -c -fpic/-fPIC a.c b.c -o a.o b.o </span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>gcc得到动态库 </summary>
              <div class="content">
              <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">gcc/g++ -shared a.o b.o -o libxxx.so</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>
<h3 id="动态库的使用"><a href="#动态库的使用" class="headerlink" title="动态库的使用"></a>动态库的使用</h3><div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">g++/gcc xxx -o xxx.out -L 库的路径 -l 库的名称(libxxx.so中的xxx就是库的名称) [-I 头文件的路径](在同个目录下就不需要这一项)</span><br></pre></td></tr></table></figure></div>
<p>与静态库不同的是，想要使用动态库，就必须配置环境变量！<br>如何配置环境变量？</p>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>方法一：临时添加 </summary>
              <div class="content">
              <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">在终端输入：</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库的绝对路径</span><br><span class="line">缺点就是每次关闭终端后，临时环境变量就会生效</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>方法二：永久添加 </summary>
              <div class="content">
              <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">在home目录下，打开.bashrc文件，在最后一行添加：</span><br><span class="line">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:动态库的绝对路径</span><br><span class="line">然后把保存退出，输入..bashrc启用</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>
<p>可以用(ldd 可执行文件名)命令查看可执行文件名的依赖关系，需要在可执行文件的目录下使用</p>
<h2 id="动态库与静态库的对比"><a href="#动态库与静态库的对比" class="headerlink" title="动态库与静态库的对比"></a>动态库与静态库的对比</h2><h3 id="程序编译成可执行文件的过程"><a href="#程序编译成可执行文件的过程" class="headerlink" title="程序编译成可执行文件的过程"></a>程序编译成可执行文件的过程</h3><p>共同点：都是在链接阶段与目标代码等链接成可执行文件<br>不同点：静态库在链接阶段的时候，会把库中的代码打包到可执行文件中，相当于把库中的代码复制到可执行文件中；动态库则是当可执行文件代码运行到含动态库代码时，加载动态库。</p>
<h3 id="创建过程"><a href="#创建过程" class="headerlink" title="创建过程"></a>创建过程</h3><p>创建方法不同，具体看上面</p>
<h3 id="库的使用"><a href="#库的使用" class="headerlink" title="库的使用"></a>库的使用</h3><p>使用命令是一样的，但是动态库使用前需要预先设置环境变量</p>
<h3 id="静态库的优缺点"><a href="#静态库的优缺点" class="headerlink" title="静态库的优缺点"></a>静态库的优缺点</h3><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优点 </summary>
              <div class="content">
              <p>a. 静态库链接时打包到可执行程序中的加载速度较快<br>b. 发布程序时不需要提供静态库，移植方便</p>
              </div>
            </details>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>缺点 </summary>
              <div class="content">
              <p>a. 消耗系统资源，浪费内存<br>b. 更新，部署，发布程序时较麻烦</p>
              </div>
            </details>
<h3 id="动态库的优缺点"><a href="#动态库的优缺点" class="headerlink" title="动态库的优缺点"></a>动态库的优缺点</h3><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优点 </summary>
              <div class="content">
              <p>a. 可以实现进程间资源共享（共享库）<br>b. 更新，部署，发布程序时简单<br>c. 可以控制何时加载动态库</p>
              </div>
            </details>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>缺点 </summary>
              <div class="content">
              <p>a. 加载速度比静态库慢<br>b. 发布程序时需要提供依赖的动态库</p>
              </div>
            </details>

<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接分为：软链接和硬链接</p>
<h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>解释 </summary>
              <div class="content">
              <p>软链接又叫做“符号链接“（symbolic  Link），它包含了到原文件的路径信息。<br>（通俗来讲，其作用相当于Window系统下的桌面快捷）</p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>特性 </summary>
              <div class="content">
              <p>a. 软链接有自己的文件属性以及权限<br>b. 可以对不存在的目录和文件创建软链接<br>c. 软链接可以交叉文件系统<br>d. 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）</p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>创建语法 </summary>
              <div class="content">
              <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ln -s 源文件 目标文件</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>解释 </summary>
              <div class="content">
              <p>对源文件起了一个别名。<br>（通俗来讲，就是复制了一个源文件，但是他们是同步更新的，因为inode号相同）</p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>特性 </summary>
              <div class="content">
              <p>a. 只能对已存在的文件进行创建<br>b. 不能对目录进行创建，只能对文件进行创建<br>c. 文件有相同的inode号和data block<br>d. 删除一个硬链接文件并不会影响到其他拥有相同inode号的文件</p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>创建语法 </summary>
              <div class="content">
              <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ln 源文件 目标文件</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<p>今天的笔记就到这里啦，对于库有疑惑的不如自己去创建一个库试一下，对链接有疑惑的可以去去看这篇更通俗易懂的文章：<a class="link" href="http://t.csdn.cn/IYMWT">http://t.csdn.cn/IYMWT <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>午安~</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>关于线程池的构建及理解</title>
    <url>/2023/02/24/blog3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1396023850&auto=1&height=66"></iframe>

<h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h2><p>所谓线程池，顾名思义就是一个关于线程的数据结构；线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和CPU数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来的时候，主线程将通过某种方式选择线程池的某一个子线程来为之服务。</p>
<h2 id="选择方式"><a href="#选择方式" class="headerlink" title="选择方式"></a>选择方式</h2><p>1.主线程使用某种算法主动选择子线程。最简单又最常用的算法是随机算法和Round Robin(轮流选取)算法</p>
<p>2.主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来的时候，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程可以拿到任务的“接管权”，其他子线程只能继续睡眠等待有新的任务的到来</p>
<h2 id="为什么要用线程池，创建线程池的好处是什么？"><a href="#为什么要用线程池，创建线程池的好处是什么？" class="headerlink" title="为什么要用线程池，创建线程池的好处是什么？"></a>为什么要用线程池，创建线程池的好处是什么？</h2><p>首先我们知道，线程是系统调度执行的最小单位，虽然是最小的，但是每次的创建线程或者销毁线程都需要浪费CPU资源，那样的服务器在每次有一个任务到来的时候都通过创建一个新的子线程来处理任务，处理完后就销毁，会浪费很多的CPU资源，所以我们设想预先创建好一些进程，每次有任务到来的时候就唤醒其中一个线程区执行任务，其他线程继续等待，执行完任务的线程并不会销毁，而是睡眠。这样就避免了CPU资源的大量浪费，因为线程已经被创建好了，需要的时候直接拿出来用，不需要转到内核态再去创建，不需要的时候也可以直接睡眠。</p>
<h2 id="线程池里的线程数量应该是多少？"><a href="#线程池里的线程数量应该是多少？" class="headerlink" title="线程池里的线程数量应该是多少？"></a>线程池里的线程数量应该是多少？</h2><p>我们创建线程池的时候不要创建过多的线程，如果创建太多线程，就体现不出线程池的优势了，但是也不能之创建1，2个线程，那样没办法处理高并发的连接，那么线程池里面的线程数量应该是多少呢？</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>线程数量 </summary>
              <div class="content">
              <p>1.线程数量与CPU,IO,并行，并发这些因素都有关</p><p>2.CPU密集型应用：CPU的数目+1</p><p>3.IO密集型应用：2*CPU的数目+1</p><p>4.最佳线程数目&#x3D;（线程等待时间与线程CPU时间之比+1）*CPU数目</p>
              </div>
            </details>

<h2 id="如何设计一个线程池呢？"><a href="#如何设计一个线程池呢？" class="headerlink" title="如何设计一个线程池呢？"></a>如何设计一个线程池呢？</h2><p>线程池有点类似生产者-消费者模型，每次生产者生产出产品（即客户端发来请求任务），都会通知消费者去消费（子线程进行请求任务的处理）</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>设计步骤 </summary>
              <div class="content">
              <p>1.设置一个生产者消费者队列，作为临界资源（全局资源）</p><p>2.初始化n个线程，并让其运行起来，加锁去队列里面取任务进行处理</p><p>3.如果任务队列为空的话，线程就阻塞</p><p>4.当生产者队列有一个任务后，就先对队列加锁，然后使用条件变量去通知阻塞队列中的一个线程来处理</p>
              </div>
            </details>

<p>线程同步机制封装类</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//互斥锁类</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Locker</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数初始化锁</span></span><br><span class="line">    <span class="built_in">Locker</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_init</span>(&amp;mutex,null);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//上锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//解锁</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//析构函数销毁锁</span></span><br><span class="line">    ~<span class="built_in">Locker</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//条件变量类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cond</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数初始化条件变量</span></span><br><span class="line">    <span class="built_in">Cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_intit</span>(&amp;cond,null);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//析构函数摧毁条件变量</span></span><br><span class="line">    ~<span class="built_in">Cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//阻塞函数，调用后线程就会阻塞</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Wait</span><span class="params">(<span class="type">othread_mutex_t</span> *mutex)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_wait</span>(&amp;cond,mutex);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//唤醒一个或者多个线程</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//信号量类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数初始化信号量</span></span><br><span class="line">    <span class="built_in">Sem</span>(<span class="type">int</span> num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sem,<span class="number">0</span>,num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//析构函数摧毁信号量</span></span><br><span class="line">    ~<span class="built_in">Sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用该函数，信号量的值-1，并对信号量加锁，如果信号量=0，则线程阻塞，信号量！=0就会解除阻塞</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//调用该函数，对信号量解锁并且信号量的值+1</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sem);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">sem_t</span> sem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>线程池代码</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//运用模板类，这样可以处理不同的业务</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pthread_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数，不用默认构造,初始化线程池</span></span><br><span class="line">    <span class="built_in">pthread_pool</span>(<span class="type">int</span> num=<span class="number">8</span>,<span class="type">int</span> max_queue=<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~<span class="built_in">pthread_pool</span>();</span><br><span class="line">    <span class="comment">//添加任务函数</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Append</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>  *<span class="title">worker</span><span class="params">(<span class="type">void</span> *arg)</span></span>;<span class="comment">//静态函数（只能操作静态成员），工作函数，不断地从任务队列中取出任务进行处理</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//运行线程池</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_num;    <span class="comment">//线程数量</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">pthread_t</span> *m_pthread;    <span class="comment">//线程池是一个数组，数组的大小就是m_num</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_max_queue;    <span class="comment">//任务队列最多能容纳的任务数量</span></span><br><span class="line"> </span><br><span class="line">    queue&lt;T *&gt; q;    <span class="comment">//任务队列</span></span><br><span class="line">    </span><br><span class="line">    Lock lock;    <span class="comment">//锁</span></span><br><span class="line"> </span><br><span class="line">    Sem sem;    <span class="comment">//信号量来判断任务队列是否有数据需要被线程处理</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">bool</span> stop;    <span class="comment">//判断线程池是否关闭，false开始，true为开启</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用初始化列表来初始化线程池</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">pthread_pool&lt;T&gt;::<span class="built_in">pthread_pool</span>(<span class="type">int</span> num,<span class="type">int</span> max_queue):<span class="built_in">m_num</span>(num),<span class="built_in">m_max_queue</span>(max_queue),<span class="built_in">stop</span>(<span class="literal">false</span>),<span class="built_in">m_pthread</span>(<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((num&lt;=<span class="number">0</span>)||(max_queue&lt;=<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//抛出错误</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    m_pthread=<span class="keyword">new</span> <span class="type">pthread_t</span>[num];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//创建线程，并且设置为线程分离（因为主线程不负责回收子线程资源这个任务）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(m_pthread+i,<span class="literal">NULL</span>,worker,<span class="keyword">this</span>);<span class="comment">//worker函数是一个指针函数，用来处理任务的，因为最后一个参数是要传递给worker的参数，因为线程需要用到线程池中的函数，所以传入this</span></span><br><span class="line">        <span class="built_in">pthread_detach</span>(m_pthread[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//释放线程池资源</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">pthread_pool&lt;T&gt;::~<span class="built_in">pthread_pool</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> []m_pthread;</span><br><span class="line">    stop=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//添加任务函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pthread_pool::Append</span><span class="params">(T* request)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//添加任务前需要给任务队列加锁，防止有线程对任务队列进行操作从而导致预期外的错误</span></span><br><span class="line">    lock.<span class="built_in">Lock</span>();</span><br><span class="line">    <span class="comment">//任务队列里面已经满了</span></span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;m_max_queue)</span><br><span class="line">    &#123;</span><br><span class="line">        lock.<span class="built_in">Unlock</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push_back</span>(requset);</span><br><span class="line">    lock.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="comment">//通过条件变量唤醒一个线程来进行处理任务</span></span><br><span class="line">    sem.<span class="built_in">Post</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//工作函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt;</span><br><span class="line"><span class="type">void</span> pthread_pool&lt;T&gt;::<span class="built_in">worker</span>(<span class="type">void</span> *arg)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_pool *pool=(pthread_pool *)arg;</span><br><span class="line">    pool-&gt;<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//运行线程池</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>&gt;</span><br><span class="line"><span class="type">void</span> pthread_pool&lt;T&gt;::<span class="built_in">run</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stop)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//先调用信号量的Wait，如果信号量为0表示队列里面没有任务，一直阻塞等到信号量值+1</span></span><br><span class="line">        sem.<span class="built_in">Wait</span>();</span><br><span class="line">        <span class="comment">//给任务队列上锁</span></span><br><span class="line">        lock.<span class="built_in">Lock</span>();</span><br><span class="line">        T* request=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        lock.<span class="built_in">Unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    request-&gt;<span class="built_in">process</span>();<span class="comment">//对任务的处理，这就要看传递的任务中的处理函数了，这里就不多说了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>emmmmm，以上就是我对线程池的理解咯，欢迎各位大佬指教呀！</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>WebServer</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title>关于并发线程临界区数据安全的问题</title>
    <url>/2023/02/24/blog4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=440767269&auto=1&height=66"></iframe>

<h2 id="关于并发线程临界区数据安全的问题"><a href="#关于并发线程临界区数据安全的问题" class="headerlink" title="关于并发线程临界区数据安全的问题"></a>关于并发线程临界区数据安全的问题</h2><p>众所周知,线程是共享同个内核的,并且用户区的一些资源也是共享的（除了栈区和.text区）；那这就意味着堆区的数据以及全局变量存储的.bss和.data区都是共享的,那么当多个线程操作共享数据的时候,就会出现问题了<br>如:</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>代码 </summary>
              <div class="content">
              <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用多线程实现卖票的案例</span></span><br><span class="line"><span class="comment">//有三个窗口,一共有100张票,3个窗口并发地卖100张票</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> i=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Sellticket</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">6000</span>);</span><br><span class="line">        cout&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;卖出的票:&quot;</span>&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建3个子线程,子线程用来卖票</span></span><br><span class="line">    <span class="type">pthread_t</span> pthid1,pthid2,pthid3;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pthid1,<span class="literal">NULL</span>,Sellticket,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pthid2,<span class="literal">NULL</span>,Sellticket,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;pthid3,<span class="literal">NULL</span>,Sellticket,<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//回收子线程地资源</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(pthid1,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(pthid2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">pthread_join</span>(pthid3,<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出现线程无法同步地问题</span></span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<p>此时就会出现下面这种情况</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/24/blog4/1.jpg" class title="图片1">

<h3 id="那么为什么会出现这种情况呢？"><a href="#那么为什么会出现这种情况呢？" class="headerlink" title="那么为什么会出现这种情况呢？"></a>那么为什么会出现这种情况呢？</h3><p>我们就以上面的代码为例:</p>
<p>1.假设在程序一开始运行的时候,A线程开始执行卖票,此时A线程就会对临界区的资源进行修改,那么此时A线程就会进行循环卖票(Sellticket),此时CPU的资源正在被A线程占用。<br>2.但是由代码可知,每次一个线程在进入while开始卖票前,都会先睡眠6000us(usleep),虽然这个时间非常短,短到我们人类根本不会察觉到,但也是存在的,所以此时A线程就会进行睡眠从而使得CPU空闲出来,此时就会有B线程抢占到CPU。虽然这种事发生的概率很低,但大家都知道墨菲定律叭,小概率的事情是一定会发生的。<br>3.假设A线程已经卖了99张票了,此时的票就只有一张了(i&#x3D;1),此时A线程要去卖最后一张票了,所以A线程进入while循环里,于是会先睡眠6000us,那么此时小概率事情就发生了,CPU被线程B抢夺过去了。</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>小知识1 </summary>
              <div class="content">
              <p>我们要知道,如果一个线程没执行完之前因为某种异常而导致无法占有CPU的时候,会有一个寄存器会专门记录睡眠前的状态,等该线程获得CPU资源的时候就会根据寄存器的内容而继续之前没执行完的代码</p>
              </div>
            </details>
<p>4.B线程抢到CPU后又会usleep一次,假设此时A线程还在睡！那么此时CPU就会被C线程抢占过去,同理,C线程又又又睡了…<br>5.此时A线程苏醒了,那么A线程就会继续刚刚没执行完的代码,也就是卖票！那么(i–)票卖完了,按道理来说,票已经卖完了,那么就不可能有票可以卖了对吧,此时就出现了一个问题,不过在此之前我们需要先知道</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>小知识2 </summary>
              <div class="content">
              <p>了解汇编指令的执行顺序<br><img lazyload src="/images/loading.svg" data-src="/2023/02/24/blog4/3.jpg" class title="图片3"></p>
              </div>
            </details>
<p>6.所以,全局变量(i),也就是票数已经为0了,此时B线程苏醒了…,<br>7.B线程会先输出当前票数(i),也就是票数为0,但是怎么可能卖出0张票呢对吧,现实中没有就是没有了,所以这就是一个问题。那为什么还会输出-1呢？<br>8.因为此时C线程也拿到CPU了,因为C线程已经进入while循环了,所以不会判断循坏条件(i&gt;0,B线程也没判断),又因为B线程之前执行了一次(i–),所以(i&#x3D;&#x3D;-1),所以才会输出-1。<br>那么这就是出现了数据安全问题了捏。</p>
<h2 id="如何避免出现线程安全的问题呢？"><a href="#如何避免出现线程安全的问题呢？" class="headerlink" title="如何避免出现线程安全的问题呢？"></a>如何避免出现线程安全的问题呢？</h2><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>“自旋”可以理解为“自我旋转”,这里的旋转是指循环,例如while或者for循环；自旋就是不停的循环直到达到退出循环的条件。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/24/blog4/2.jpg" class title="图片2">
<p>简易代码:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">lock_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">&#125;<span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">TestAndSet</span><span class="params">(<span class="type">int</span> *old_flag,<span class="type">int</span> new_flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> old=*old_flag;</span><br><span class="line">    *old_flag=new_flag;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock-&gt;flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">TestAndSet</span>(lock-&gt;flag,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//开始自旋    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock-&gt;flag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如何理解:</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>场景1 </summary>
              <div class="content">
              <p>一开始锁没有线程拿,那么此时锁的flag&#x3D;0,假设有一个线程拿到了锁,会进行加锁(lock),此时TestAndSet函数返回的值为0,不满足循环条件,并且将锁的flag置1。释放锁的时候(unlock),又会将锁的flag置0,表示现在锁没有线程拿。</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>场景2 </summary>
              <div class="content">
              <p>假设有一个线程已经拿到了锁并且没有释放,那么此时锁的flag&#x3D;&#x3D;1,此时另外一个进程想要拿锁,那么就会执行lock函数,也就会执行TestAndSet函数,此时传入的参数为(&amp;1,0),得到的值也只会是0,满足循环条件,那么就会一直循环,直到拿锁的线程把锁释放了,那么此时flag&#x3D;&#x3D;0,传入的参数就变成(&amp;0,0)了,此时就不满足循环条件,也就会跳出循环并且拿到锁</p>
              </div>
            </details>

<p>这是最简单的一种锁,一直自旋,利用 CPU 周期,直到锁可用。在单处理器上,需要抢占式的调度器（即不断通过时钟中断一个线程,运行其他线程）。否则,自旋锁在单 CPU 上无法使用,因为一个自旋的线程永远不会放弃 CPU。</p>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优点 </summary>
              <div class="content">
              <p>有些场景中,同步资源的锁定时间很短,为了这一小段时间去切换线程,线程挂起和恢复现场的花费可能会让系统得不偿失。如果机器有多个CPU核心,能够让两个或以上的线程同时并行执行,我们就可以让后面那个请求锁的线程不放弃CPU的执行时间,看看持有锁的线程是否很快就会释放锁。为了让当前线程“稍等一下”,我们需让当前线程进行自旋,如果在自旋完成后前面锁定同步资源的线程已经释放了锁,那么当前线程就可以不必阻塞而是直接获取同步资源,从而避免切换线程的开销。</p>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>缺点 </summary>
              <div class="content">
              <p>它最大的缺点就在于虽然避免了线程切换的开销,但是它在避免线程切换开销的同时也带来了新的开销,因为它需要不停得去尝试获取锁。如果这把锁一直不能被释放,那么这种尝试只是无用的尝试,会白白浪费处理器资源。也就是说,虽然一开始自旋锁的开销低于线程切换,但是随着时间的增加,这种开销也是水涨船高,后期甚至会超过线程切换的开销,得不偿失。</p>
              </div>
            </details>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>互斥锁与自旋锁不同的点就在于当一个线程拿不到互斥锁的时候,这个线程不会进行自我循环一直等待并且占用CPU资源,而是阻塞,CPU去执行其他线程</p>
<h4 id="互斥锁的一些API"><a href="#互斥锁的一些API" class="headerlink" title="互斥锁的一些API"></a>互斥锁的一些API</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//互斥锁类型</span></span><br><span class="line"><span class="type">pthread_mutex_t</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化互斥锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *restrict mutex,<span class="type">const</span> <span class="type">pthread_mutex_t</span> *attr)</span></span></span><br><span class="line"><span class="function">参数：</span></span><br><span class="line"><span class="function">    <span class="type">pthread_mutex_t</span> *restrict mutex：需要初始化的互斥锁,restrict是C语言修饰符,被修饰的指针,不能由另一个指针进行操作；</span></span><br><span class="line"><span class="function">    <span class="type">pthread_mutex_t</span> *attr：互斥量相关的属性,一般使用<span class="literal">NULL</span>（默认属性）；</span></span><br><span class="line"><span class="function">返回值：</span></span><br><span class="line"><span class="function">    成功返回0,失败返回-1</span></span><br><span class="line"><span class="function"><span class="comment">//摧毁互斥锁</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line">参数:要摧毁的互斥锁</span><br><span class="line">返回值：同上</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加锁,这个函数是阻塞的,如果有一个线程加锁了,那么其他的线程就只能阻塞等待</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span></span><br><span class="line"><span class="function">参数：要加的锁</span></span><br><span class="line"><span class="function">返回值：同上</span></span><br><span class="line"><span class="function"><span class="comment">//尝试加锁</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span></span><br><span class="line"><span class="function">与上面不同的是,如果加锁失败的话是不会阻塞的,而是直接返回</span></span><br><span class="line"><span class="function"><span class="comment">//解锁</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span></span><br></pre></td></tr></table></figure></div>
<p>自旋锁又被叫做“忙等待锁”,互斥锁又叫“无等待锁”,只要用了锁就一定没问题吗？其实并不是这样的,用锁的时候必须注意出现<code>死锁</code>的问题,什么是死锁？</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>所谓死锁,大概意思就是指某个锁一直被一个线程占用而不解锁,那么此时无论哪个线程都无法再继续访问被锁上的资源了,那么这个锁就是死锁</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>出现死锁的情况 </summary>
              <div class="content">
              <p>1.加了锁后忘记释放锁,此时就会出现无论是持有锁的线程还是其他想要访问被锁上的资源的线程都会被阻塞,那么这个锁就是死锁</p><p>2.有时,一个线程需要同时访问两个或者多个不同的共享资源,而每个资源又都由不同的互斥锁来管理。当超过一个线程加锁同一组资源的时候,就有可能发生死锁</p><p>3.类似两个人过独木桥,双方都不愿意让步,那么双方就永远过不去了；举个栗子：A线程拿了A资源的锁,然后又想要访问B资源,B线程拿了B资源的锁,并且它想要访问A资源,那么此时就出现了冲突,如果A线程想要访问B资源,那么就必须等B资源的锁被解开,也就是B线程必须先解开B资源的锁,但是B线程解开B资源的锁的前提条件是先拿到A资源的锁,但是A资源的锁又被A线程拿了,想要解开A资源的锁,就必须先让A线程拿到B资源的锁。如此下去就会陷入一个死循环,那么此时就会出现死锁。</p>
              </div>
            </details>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>互斥锁只要有一个线程拿到,那么其他线程无论是读取还是修改被锁上的数据都没办法做到,只能乖乖阻塞等到解锁,但是实际上呢,如果这个线程只是在对被上锁的资源进行读操作,那么其他线程只是想要读取数据并不会导致出现线程安全问题,所以就出现了<code>读写锁</code></p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>读写锁的特点 </summary>
              <div class="content">
              <p>1.如果有一个线程读数据,则允许其他线程执行读操作,但不允许进行写操作</p><p>2.如果一个线程进行数据的时候,其他线程都不允许进行读,写操作</p><p>3.写是独占的,写的优先级最高</p>
              </div>
            </details>
<h4 id="读写锁的一些API"><a href="#读写锁的一些API" class="headerlink" title="读写锁的一些API"></a>读写锁的一些API</h4><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读写锁的类型</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span></span><br><span class="line">读写锁和互斥锁很像</span><br><span class="line"> </span><br><span class="line"><span class="comment">//初始化读写锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *restrict rwlock,<span class="type">const</span> pthread_rwlock <span class="type">attr_t</span> * restrict attr)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//摧毁读写锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加读锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//加写锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//解锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span></span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h3><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>悲观锁 </summary>
              <div class="content">
              <p>所谓悲观锁,就是很悲观的认为不加锁的话一定会出现线程临界区的数据安全问题,所以在操作临界区的数据前就对数据加锁,像互斥锁,自旋锁,读写锁都属于悲观锁</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>乐观锁 </summary>
              <div class="content">
              <p>但其实我们知道,数据出现问题毕竟属于小概率事件,所以乐观锁就是很乐观的认为不会出现这种数据安全问题,只有等到出现这种问题的时候再进行加锁,像现在很多都是使用乐观锁,就比如群文档,一个人在操作的时候另外一个人也可以对文档进行操作。毕竟如果一个人在操作文档的时候另外一个人没办法操作的话,会降低很多很多效率</p>
              </div>
            </details>

<p>其实不光是锁可以保护临界区数据的安全,也有其他方法,例如<code>条件变量</code>和<code>信号量</code>等,同时在满足<code>互斥</code>的时候,我们也需要满足<code>同步</code>。</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>同步和互斥 </summary>
              <div class="content">
              <p>互斥:像上面说的数据在上锁后就只能被一个线程进行操作,其他线程没办法获取到被上锁的资源,就被叫做<code>互斥</code><br>同步:但我们知道,线程之间虽然是独立运行的,但有时候我们需要多个线程之间互相合作去完成一些事情<br>例子,线程 1 是负责读入数据的,而线程 2 是负责处理数据的,这两个线程是相互合作、相互依赖的。线程 2 在没有收到线程 1 的唤醒通知时,就会一直阻塞等待,当线程 1 读完数据需要把数据传给线程 2 时,线程 1 会唤醒线程 2,并把数据交给线程 2 处理。<br><code>所谓同步,就是并发进程/线程在一些关键点上可能需要互相等待与互通消息,这种相互制约的等待与互通信息称为进程/线程同步。</code></p>
              </div>
            </details>

<p>下一篇我们好好讲一下<code>信号量</code>,因为它不光能满足线程间的互斥,还同时支持线程间的同步,同时也会列出几个模型来帮助大家更好地掌握<code>线程间的同步和互斥</code></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>浙江宇视科技一面</title>
    <url>/2023/02/24/blog5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=36841427&auto=1&height=66"></iframe>

<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>本人从2022-11月末开始在各大招聘网站上面投递简历，即今为止收到了3次面试，前两次面试不想评价，首先就是面试的岗位不是我想去的岗位(甚至和我投递的完全不搭边…)，其次就是问的问题一点技术含量也么没有，全程和我唠嗑(有没有可能，我是说可能，或许我投了传销的岗位?)，直到昨天下午，在图书馆好好学习的我突然被一阵电话铃声吓了一跳，原本也不在意，以为又是来催我买车的( 因为我驾照已经有一年了(狗头 )，等我看到来电地址是浙江杭州的时候，并且号码还很正常，我才意识到确实有人来找我，在脑子里想了很久我是不是欠了某个杭州朋友的钱的时候，电话已经挂了…<br>后来多次拨打过去，才接通并且告知我笔试通过，准备一面…此时的心情怎么说呢？有点激动又有点害怕。冷静下来后意识到<br>“如今面试就在眼前，我必须考虑这会不会是我此生仅有的机会，我相信中国能有现在的地位，老一辈功不可没，重铸华夏人荣光，我辈义不容辞”</p>
<h1 id="面试开始"><a href="#面试开始" class="headerlink" title="面试开始"></a>面试开始</h1><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>自我介绍 </summary>
              <div class="content">
              <p>没什么好说的，可以去看看我的置顶文章捏</p>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>重点介绍一下哪些与岗位相关的项目 </summary>
              <div class="content">
              <p>说真的，我不知道自己面的是什么岗位了，于是就把WebServer,简易RPC框架,简易抖音APP都简单介绍了一下</p>
              </div>
            </details>

<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>介绍一下RPC框架 </summary>
              <div class="content">
              <p>RPC框架实现的是一个函数的远程调用，将函数部署在一个服务器上面，通过另外一个服务器调用该函数</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>答案 </summary>              <div class="content">              <p>答案:RPC（Remote Procedure Call）即远程过程调用，不同于本地调用，RPC是指调用远端机器的函数或方法，且不需要关心底层的调用细节，如网络协议和传输协议等，对于调用者来说，和调用本地方法没有什么区别。</p>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>实现原理是怎样的 </summary>              <div class="content">              <p>实现原理就是:先用protobuf把需要的参数进行序列化，然后通过网络库将数据传输给被调用方，然后被调用方再用protobuf将参数(反)序列化后传入函数里面，获得结果后再用相同的方法传递回去，被调用方会先将函数注册在zookeeper上，然后就可以进行监听事件的发生，如果有请求事件的就会进行处理</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>主要有以下几个步骤: </summary>              <div class="content">              <p>1、建立通信</p><p>首先要解决通讯的问题：即A机器想要调用B机器，首先得建立起通信连接。主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有相关的数据都在这个连接里面进行传输交换。</p><p>通常这个连接可以是按需连接（需要调用的时候就先建立连接，调用结束后就立马断掉），也可以是长连接（客户端和服务器建立起连接之后保持长期持有，不管此时有无数据包的发送，可以配合心跳检测机制定期检测建立的连接是否存活有效），多个远程过程调用共享同一个连接。</p><p>2、服务寻址</p><p>解决寻址的问题：即A机器上的应用A要调用B机器上的应用B，那么此时对于A来说如何告知底层的RPC框架所要调用的服务具体在哪里呢？</p><p>通常情况下我们需要提供B机器（主机名或IP地址）以及特定的端口，然后指定调用的方法或者函数的名称以及入参出参等信息，这样才能完成服务的一个调用。比如基于Web服务协议栈的RPC，就需要提供一个endpoint URI，或者是从UDDI服务上进行查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。</p><p>3、网络传输</p><p>3.1、序列化</p><p>当A机器上的应用发起一个RPC调用时，调用方法和其入参等信息需要通过底层的网络协议如TCP传输到B机器，由于网络协议是基于二进制的，所有我们传输的参数数据都需要先进行序列化（Serialize）或者编组（marshal）成二进制的形式才能在网络中进行传输。然后通过寻址操作和网络传输将序列化或者编组之后的二进制数据发送给B机器。</p><p>3.2、反序列化</p><p>当B机器接收到A机器的应用发来的请求之后，又需要对接收到的参数等信息进行反序列化操作（序列化的逆操作），即将二进制信息恢复为内存中的表达方式，然后再找到对应的方法（寻址的一部分）进行本地调用（一般是通过生成代理Proxy去调用, 通常会有JDK动态代理、CGLIB动态代理、Javassist生成字节码技术等），之后得到调用的返回值。</p><p>4、服务调用</p><p>B机器进行本地调用（通过代理Proxy）之后得到了返回值，此时还需要再把返回值发送回A机器，同样也需要经过序列化操作，然后再经过网络传输将二进制数据发送回A机器，而当A机器接收到这些返回值之后，则再次进行反序列化操作，恢复为内存中的表达方式，最后再交给A机器上的应用进行相关处理（一般是业务逻辑处理操作）。</p><p>通常，经过以上四个步骤之后，一次完整的RPC调用算是完成了，另外可能因为网络抖动等原因需要重试等。</p>              </div>            </details>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>这个调用跟消息收发有什么区别吗? </summary>              <div class="content">              <p>(其实这里不太懂想要问什么)<br>这个调用就和浏览器请求服务器资源和回应，都是通过网络协议进行的</p>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>那我可不可以理解为这个远程调用就是网络消息的收发 </summary>              <div class="content">              <p>可以吧(心虚…因为从开学到现在一直在看那个抖音项目，说实话RPC这方面有一些都忘了，再加上当时很紧张)</p>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>走的是什么协议 </summary>              <div class="content">              <p>TCP协议<br>面试官:TCP协议?<br>(心虚)应该还有HTTP协议，因为我是用的muduo库的(阿西吧!)</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>答案 </summary>              <div class="content">              <p>应该只用到了TCP协议，用来与服务器建立连接</p><p>RPC和HTTP的联系与区别</p><p>联系：都是远程通信的网络协议，任何网络协议都包括语法、语义、时序三个特征。</p><p>区别：</p><p>HTTP协议是应用层协议，更多地用于前后端通信或移动端、PC端与后端通信，其他的常用应用层协议还包括SSH协议、ftp协议。</p><p>RPC是远程过程调用，更多地用于分布式架构中各个服务模块之间的通信，其中的知识涉及socket通信、序列化和反序列化、动态代理、反射调用。如下程序，服务端要发布socket服务+线程池io处理多个客户端连接+反射调用，客户端要动态代理实例化对象，参与网络传输的Bean要实现Serializable接口变为可序列化+IO流序列化&#x2F;反序列化。</p>              </div>            </details>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>HTTP和TCP有什么区别 </summary>              <div class="content">              <p>HTTP是应用层的协议，TCP是传输层的;<br>HTTP协议是一个报文协议，传输的内容包含了请求以及回应,TCP协议是数据流的协议，里面有目的IP地址和源IP地址(我这回答的简直就是依托答辩,回答的时候还口吃了…)</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>HTTP协议与TCP协议的区别 </summary>              <div class="content">              <p>1、TCP对应与传输层、而HTTP对应于应用层，所以HTTP协议是建立在TCP协议之上的；</p><p>2、HTTP底层是利用TCP协议传输的，所以支持http也就一定支持TCP；</p><p>3、TCP是网络传输协议， HTTP是超文本传输协议；</p><pre><code>    TCP是底层协议，定义的是数据传输和连接方式的规范。    HTTP是应用层协议，定义的是传输数据的内容的规范。</code></pre><p>4、HTTP是无状态的短链接，而TCP是有状态的长连接；</p><p>TCP对应于传输层，HTTP对应于应用层，从本质上来说，二者没有可比性。</p>              </div>            </details>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>消息封装的时候先封装哪个协议呢 </summary>              <div class="content">              <p>先封装HTTP协议(面试官不说话，我以为我说错了，立马改口成TCP协议了)<br>答案:先封装HTTP协议，封装消息是从应用层开始，到物理层结束，所以应该先封装应用层的HTTP协议，整个流程如下<br><img lazyload src="/images/loading.svg" data-src="/2023/02/24/blog5/1.jpg" class title="流程"></p>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>消息发出去需要封装几层 </summary>              <div class="content">              <p>先经过TCP,然后IP，然后HTTP,最后经过数据链路层封装成帧，应该是4层…(今晚听录音的时候真想抽死自己)<br>答案:四层，如上图所示</p>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>项目调试过程遇到了什么问题 </summary>              <div class="content">              <p>(努力思考做项目的时候遇到的问题，然后乱七八糟回答了一堆有的没的)</p>              </div>            </details><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>消息通信一般定位的方法有哪些 </summary>              <div class="content">              <p>(第一次没听清，等第二次听清的时候我才发现不是我没听清而是我根本不知道怎么回答，随便说了一下也不知道是什么东西的玩意)</p>              </div>            </details>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>这个项目是用C++写的是吧，那讲一下C++里面数组和链表的区别 </summary>
              <div class="content">
              <p>数组在内存中是连续存放的，链表在链表中是随机存放的<br>数组的插入、删除的时间复杂度为O(n),获取元素的时间复杂度为O(1)<br>链表的插入、删除的时间复杂度为O(1),获取元素的时间复杂度为O(n)<br>补充:<br>数组:（1）数组在内存中连续； (2)使用数组之前，必须事先固定数组长度，不支持动态改变数组大小；(3) 数组元素增加时，有可能会数组越界；(4) 数组元素减少时，会造成内存浪费；（5）数组增删时需要移动其它元素；（6）数组从栈上分配内存，使用方便，但是自由度小<br>链表:（1）链表采用动态内存分配的方式，在内存中不连续 (2)支持动态增加或者删除元素 (3)需要时可以使用malloc或者new来申请内存，不用时使用free或者delete来释放内存；（4）链表从堆上分配内存，自由度大，但是要注意内存泄漏</p><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么数组的查询时间复杂度是O(1)的呢 </summary>              <div class="content">              <p>因为数组可以通过数组下标来访问数组的元素<br>补充:因为数组在内存中是连续的，所以在知道数组首地址的情况就就能知道数组中所有元素的地址，所以要可以不需要从头开始遍历去查找，所以为O(1)</p>              </div>            </details><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>如果数组里面的数据是乱序的，也就是说数组的下标和数组元素之间不存在数学关系的话，那么他的查找效率是怎么样的 </summary>              <div class="content">              <p>还是0(1)吧，数组的下标和元素好像本来就没有什么数学关系</p>              </div>            </details>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>讲一下指针函数和函数指针的区别 </summary>
              <div class="content">
              <p>(寄!)<br>指针函数是指向函数地址的一个指针…函数指针的话不太记得了…</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>函数指针和指针函数的区别 </summary>              <div class="content">              <p>指针函数，简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是一个指针。<br>声明格式为：*类型标识符 函数名(参数表)</p><p>函数指针，其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。<br>声明格式：类型说明符 (*函数名) (参数)</p><p><code>以上都是对普通函数指针的介绍，中在C++中因为类函数的关系，函数指针又会有一些不同的区别</code><br>类成员函数的指针（非静态）<br>指向类成员函数的指针与普通函数指针的区别在于，前者需要匹配函数的参数类型和个数以及返回值类型，还要匹配该函数指针所属的类类型。</p><p>这是因为非静态的成员函数必须被绑定到一个类的对象或者指针上，才能得到被调用对象的this指针，然后才能调用指针所指的成员函数（所有类的对象都有自己数据成员的拷贝，但是成员函数都是共用的，为了区分是谁调用了成员函数，就必须有this指针，this指针是隐式的添加到函数参数列表里去的）<br>类成员函数指针定义:typedef 返回值 (类名::*指针类型名)(参数列表);<br>类成员函数指针赋值:指针类型名  指针名 &#x3D; &amp;类名::成员函数名;<br>类成员函数指针的调用:<br>(类对象.*指针名)(参数列表);<br>(类指针-&gt;*指针名)(参数列表);</p><p>指向类的静态函数的指针<br>类的静态成员函数和普通函数的函数指针的区别在于，他们是不依赖于具体对象的，所有实例化的对象都共享同一个静态成员，所以静态成员也没有this指针的概念。所以，指向类的静态成员函数的指针就是普通的函数指针。</p>              </div>            </details>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>讲一下类和结构体有什么区别 </summary>
              <div class="content">
              <p>在结构体里面所有的数据都是public的，在类里面还存在protect和private<br>类存在构造函数和析构函数<br>类可以通过继承的方法实现多态<br>类里面还会封装对类里面的数据的操作的函数，在结构体里面没办法这样做</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>类和结构体的区别 </summary>              <div class="content">              <ol><li><p>结构体是一种值类型，而类是引用类型。值类型用于存储数据的值，引用类型用于存储对实际数据的引用。</p><p>   那么结构体就是当成值来使用的，类则通过引用来对实际数据操作。</p></li><li><p>结构体使用栈存储（Stack Allocation），而类使用堆存储（Heap Allocation)</p></li></ol><p>栈的空间相对较小.但是存储在栈中的数据访问效率相对较高.</p><p>堆的空间相对较大.但是存储在堆中的数据的访问效率相对较低.</p><ol start="3"><li><p>类是反映现实事物的一种抽象，而结构体的作用只是一种包含了具体不同类别数据的一种包装，结构体不具备类的继承多态特性</p></li><li><p>结构体赋值是 直接赋值的值. 而对象的指针 赋值的是对象的地址</p></li><li><p>Struct变量使用完之后就自动解除内存分配，Class实例有垃圾回收机制来保证内存的回收处理。</p></li><li><p>结构体的构造函数中，必须为结构体所有字段赋值，类的构造函数无此限制</p></li></ol><p>首先,关于隐式构造函数.我们知道,在1个类中如果我们没有为类写任意的构造函数,那么C++编译器在编译的时候会自动的为这个类生成1个无参数的构造函数.我们将这个构造函数称之为隐式构造函数 但是一旦我们为这个类写了任意的1个构造函数的时候,这个隐式的构造函数就不会自动生成了.在结构体中,就不是这样了,在结构体中隐式的构造函数无论如何都存在。所以程序员不能手动的为结构添加1个无参数的构造函数。</p><ol start="7"><li>结构体中声明的字段无法赋予初值，类可以</li></ol>              </div>            </details><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>结构体可以包含一个类吗 </summary>              <div class="content">              <p>应该可以吧</p>              </div>            </details>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>多态是什么意思 </summary>
              <div class="content">
              <p>(啊啊啊我知道多态大概是个什么意思，但是我就是没办法用口语表达出来)额…像是…额…</p><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>多态 </summary>              <div class="content">              <p>一个接口多种方法，即用同一个接口，但是效果不同<br>多态又分为静态多态和动态多态。<br>静态多态是指在编译期就把函数链接起来，此时即可确定调用哪个函数或模板，静态多态是由模板和重载实现的，重载又分为函数重载和运算符重载<br>动态多态是指在程序运行时才能确定函数和实现的链接，此时才能确定调用哪个函数，父类指针或者引用能够指向子类对象，调用子类的函数，所以在编译时是无法确定调用哪个函数<br>动态多态存在的三个必要条件：<br>    1. 继承<br>    2. 重写<br>    3. 父类引用指向子类对象</p>              </div>            </details>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>全局变量和局部变量可以用相同的变量名吗 </summary>
              <div class="content">
              <p>可以<br>答案:局部变量可以与全局变量同名，在函数内引用这个变量时，会用到同名的局部变量，而不会用到全局变量。</p><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>如果使用这个变量的时候是使用哪里的? </summary>              <div class="content">              <p>如果在函数里面的话，会先使用局部变量</p>              </div>            </details><details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>什么情况下使用全局变量呢? </summary>              <div class="content">              <p>(不会)在定义局部变量的函数外就是使用全局变量<br>答案:想要在函数体内使用全局变量而不是同名的局部变量的话，需要使用”::”(作用域解析符)+全局变量名</p>              </div>            </details>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>讲一下C++和GO的区别 </summary>
              <div class="content">
              <p>(没去探究过，只知道GO很简便)GO里面有很多库可以使用，我通过GORM框架和GIN框架实现视频的上传和聊天记录的上传，并且保存在数据库里面</p>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>讲一下进程和线程的区别是什么 </summary>
              <div class="content">
              <p>进程是资源调度(资源分布才对…)的基本单位,线程是CPU执行的基本单位<br>线程是比线程更轻量级的一个东西(?)，一个线程可以包括很多个进程(不是我在说什么啊?这都能说错啊?)<br>线程之间是共享一些数据的，它们通信不需要通过内核，进程通信需要通过内核<br>    <details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>进程与线程的区别与联系 </summary><br>              <div class="content"><br>              <ol><li>拥有资源：进程时资源分配的基本单位，而线程时CPU分配和调度的基本单位。<br>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。（资源分配给进程，同一进程的所有线程共享该进程的所有资源。同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈段，栈段又叫运行时段，用来存放所有局部变量和临时变量。</li><li>调度：线程时实现独立调度的基本单位。在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li><li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。<br>通信：程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC (Inter-Process Communication)。</li></ol><br>              </div><br>            </details></p>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>进程间通信有哪些方法?哪个效率最高 </summary>
              <div class="content">
              <p>方法有管道、信号、消息队列、信号量、共享内存、内存映射；共享内存的效率应该是比较高的</p>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>共享内存具体怎么操作的呢? </summary>
              <div class="content">
              <p>一个进程会先将要共享的文件通过页表映射在物理内存上面，其他进程就可以通过访问物理内存对文件进行修改从而实现进程间通信(奇奇怪怪的)<br>    <details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>共享内存的实现 </summary><br>              <div class="content"><br>              <ol><li>使用shmget()函数创建一个新的共享内存段或者区的一个已有的共享内存段的标识符(就是说有其他进程创建的共享内存段)，这个调用将返回后续调用需要用到的共享内存标识符</li><li>使用shmat()函数来附上共享内存段，即使该段称为调用进程的虚拟内存的一部分</li><li>此时在程序中就可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由shmat()函数的返回值的addr值(一个指向进程的虚拟地址空间中该共享内存段的起点的指针)</li><li>shmdt()函数用来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存</li><li>调用shmctl()来删除共享内存段。只有当所有附加内存段的进程都与之分离之后内存段可会销毁，只有一个进程需要执行这一步</li></ol><br>              </div><br>            </details></p>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>Linux里的死锁一般是怎么造成的? </summary>
              <div class="content">
              <p>一个线程拿了锁没有被释放<br>山羊过独木桥一样，两个线程因为需要对方的锁才能将自己的锁解开，从而出现死锁<br>一个线程持有多把锁，有可能会出现死锁</p>
              </div>
            </details>

<p>总结:依托答辩!!!!今晚听录音写博客的时候都想抽死我自己了，我是什么垃圾啊(哭)，下次一定要比这次更好，但谁知道有没有下次呢。</p>
<p>果然不出我所料，下午就收到感谢信了捏<br>鼠鼠我啊，就是这样的捏~不说了，健身去了</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/24/blog5/%E9%BC%A0%E9%BC%A0.jpg" class title="鼠鼠">
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>实习面经(一面)</tag>
        <tag>浙江宇视科技</tag>
      </tags>
  </entry>
  <entry>
    <title>进程间通信的各种方法以及优缺点</title>
    <url>/2023/02/25/blog6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=507014930&auto=1&height=66"></iframe>

<h2 id="进程间通讯概念"><a href="#进程间通讯概念" class="headerlink" title="进程间通讯概念"></a>进程间通讯概念</h2><ol>
<li>进程是一个独立的资源分配单位，不同的进程(主要指用户进程)之间的资源是独立的，没有关联，无法在一个进程中直接访问另一个进程的资源</li>
<li>但是，进程不是孤立的，不同的进程需要进行信息的交互和状态的传递等等，因此需要进程间通信(IPC,Inter-Process Communication)，</li>
<li>进程间通信的目的<ol>
<li>数据传输:一个进程需要将它的数据发送给另一个进程</li>
<li>通知事件:一个进程需要向另外一个或者一组进程发送信息，通知它(它们)发生了某种事件</li>
<li>资源共享:多个进程之间共享同样的资源。为了做到这一点，需要内核提供<code>互斥</code>和<code>同步</code>机制</li>
<li>进程控制:有些进程希望能完全控制另外一个进程的执行(如Debug进程)，此时控制进程希望能够拦截另一个进程<code>陷入异常</code>，并能够即使知道它的<code>状态改变</code></li>
</ol>
</li>
<li>进程间虽然用户地址空间是独立的，但是它们共享一个内核空间，所以进程想要通信就只能通过内核</li>
</ol>
<h2 id="Linux下进程间的通信方式"><a href="#Linux下进程间的通信方式" class="headerlink" title="Linux下进程间的通信方式"></a>Linux下进程间的通信方式</h2><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>同一主机下的进程间通信方式 </summary>
              <div class="content">
              <ol><li>Unix进程间通信方式<ol><li>管道</li><li>信号</li></ol></li><li>System V进程间通信方式 和 POSTX进程间通信方式<ol><li>消息队列</li><li>共享内存</li><li>信号量</li></ol></li></ol>
              </div>
            </details>

<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>不同主机(网络)进程间通信方式 </summary>
              <div class="content">
              <p>Socket(套接字)</p>
              </div>
            </details>

<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道又分为匿名管道和有名管道，管道是UNIX系统中IPC（进程通信）的最古老的形式，所有UNIX都支持这种通信机制</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ls | wc -l</span><br><span class="line">//中间那个&quot;|&quot;就是在shell脚本下的管道符</span><br></pre></td></tr></table></figure></div>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>管道的特点 </summary>
              <div class="content">
              <ol><li>管道是一个在内核内存中维护的缓冲区，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同</li><li>在Linux下，可以说一切皆是文件，其实内核内存中的这个缓冲区也是一个文件，那么可以操作文件的API，同样也能操控缓冲区</li><li>一个管道是一个字节流，使用管理时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小为多少</li><li>通过管道传递的数据时顺序的，从管道中读取出来的字节的顺序和写入的顺序时完全一样的，就像是队列一样，先进先出</li><li>从管道读取数据是一次性操作，只要读取完，那么读取的数据就会被抛弃而不会留在缓冲区以便有更多的空间来写数据，所以无法使用lseek()函数来随机访问数据</li><li>匿名管道只能在具有公共祖先进程的时候(例如：父进程与子进程通信，两个兄弟进程通信)才能使用，有名管道用于无亲缘关系的进程</li></ol>
              </div>
            </details>

<p>管道的数据结构一般都是:环形队列或者循环队列</p>
<h4 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h4><p>匿名管道也叫无名管道，大部分情况下，我们说的管道都是指匿名管道</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么匿名管道能够通信 </summary>
              <div class="content">
              <p>当我们对一个进程使用fork()创建一个子进程的时候，子进程会复制一份父进程的内核区，不过其中的进程号是不一样的，同时<code>复制的还有文件描述符表</code>，那么子进程的文件描述符表上也就会有关于管道读写端的记录，这样就能操作同一个管道来进行通信了，这也就意味着，<code>必须要采用fork()函数之前先创建好匿名管道</code></p>
              </div>
            </details>

<h5 id="匿名管道的使用"><a href="#匿名管道的使用" class="headerlink" title="匿名管道的使用"></a>匿名管道的使用</h5><ol>
<li>创建管道<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> <span class="comment">//需要包含的头文件</span></span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line">参数:</span><br><span class="line">    pipefd[<span class="number">2</span>]:传出参数，函数调用成功后，pipefd[<span class="number">0</span>]代表读端，pipefd[<span class="number">1</span>]代表写端，都是文件描述符</span><br><span class="line">返回值:</span><br><span class="line">    成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure></div></li>
<li>查看管道缓冲大小命令<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">ulimit -p;</span><br><span class="line">ulimit -p 想要设置的大小(Kbytes)</span><br></pre></td></tr></table></figure></div></li>
<li>查看管道缓冲区大小函数<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="title">fpathconf</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> name)</span></span></span><br><span class="line"><span class="function">参数:</span></span><br><span class="line"><span class="function">    int fd:管道的文件描述符</span></span><br><span class="line"><span class="function">    int name:宏值，通过在终端上输入<span class="string">&quot;man 2 fpathconf&quot;</span>查看</span></span><br></pre></td></tr></table></figure></div></li>
<li>&#96;如果管道是空的，read函数会阻塞;如果管道是满的，write函数会阻塞</li>
</ol>
<h5 id="匿名管道的读写特点和如何将管道设置为非阻塞"><a href="#匿名管道的读写特点和如何将管道设置为非阻塞" class="headerlink" title="匿名管道的读写特点和如何将管道设置为非阻塞"></a>匿名管道的读写特点和如何将管道设置为非阻塞</h5><ol>
<li>使用管道时，需要注意的点:<ol>
<li>当多有指向管道<strong>写端</strong>的文件描述符<strong>都关闭了(管道写端引用计数为0)<strong>，有进程从管道的</strong>读端</strong>读取数据，那么当该进程把管道里面剩余的数据读取完后，再次 read就会返回0，就像如到文件末尾一样</li>
<li>如果有指向管道<strong>写段</strong>的文件描述符<strong>没关闭(管道写段引用计数不为0)<strong>，而持有管道</strong>写端</strong>的进程也而没有往里面写数据，当管道的数据被另外一个进程读取完后，再次read时，管道就会变成<strong>阻塞状态</strong>，直到有进程往管道里面写数据才可以再次返回读取数据</li>
<li>如果有指向管道<strong>读端</strong>的文件描述符<strong>都关闭了(管道读端引用计数为0)<strong>，有进程从管道的写端写入数据时，那么该进程就会收到一个</strong>SIGPIPE信号</strong>，通常会导致进程终止</li>
<li>如果有指向管道<strong>读端</strong>的文件描述符<strong>没有关闭(管道读端引用计数不为0)<strong>，而持有管道读端的进程也没有进行读数据操作，当有别的进程往管道里写入数据时，若管道已经被</strong>写满</strong>的话，此时<strong>管道就会变为阻塞状态直到管道读端读取数据</strong>，若没写满的话就还是能继续写入的</li>
</ol>
</li>
<li>如何将管道设置为非阻塞<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fcntl</span><span class="params">(<span class="type">int</span> fd,<span class="type">int</span> cmd,...)</span></span></span><br></pre></td></tr></table></figure></div>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>例如:将管道的读端设置为非阻塞 </summary>
              <div class="content">
              <ol><li>先获取原本管道读端的flags<br> int flags&#x3D;fcntl(fd[0],F_GETFL)</li><li>修改flags<br> flags|&#x3D;NONBLOCK(非阻塞)</li><li>设置修改后的flags<br> fcntl(fd[0],F_SETFL,flags)</li></ol>
              </div>
            </details></li>
</ol>
<h4 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h4><ol>
<li>有名管道也叫做命名管道、FIFO文件</li>
<li>命名管道(FIFO)不同于匿名之处在于提供了一个路径与之关联，以FIFO的文件形式存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能彼此通过FIFO相互通信，因此，通过FIFO不想管的进程也能交换数据</li>
<li>一旦打开了FIFO，就能在它上面使用与操作匿名管道和其他文件的系统调用一样的I&#x2F;O系统调用API(如read,write,close)。与管道一样，FIFO也有一个写入端和读取端，并且从管道读取数据的顺序与写入顺序是一样的，FIFO(先进先出)名称也由此而来</li>
</ol>
<h5 id="与匿名管道的不同"><a href="#与匿名管道的不同" class="headerlink" title="与匿名管道的不同"></a>与匿名管道的不同</h5><ol>
<li>有名管道能用于无亲缘关系的进程，匿名管道不行</li>
<li>FIFO在文件系统中作为一个特殊文件存在，但FIFO中的内容却存放在<strong>内存</strong>中</li>
<li>当使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后调用</li>
<li>FIFO有名字，所以不相关的进程可以通过名字打开有名管道进行通信</li>
</ol>
<h5 id="有名管道的使用"><a href="#有名管道的使用" class="headerlink" title="有名管道的使用"></a>有名管道的使用</h5><ol>
<li>通过命令创建有名管道<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mkfifo 名字</span><br></pre></td></tr></table></figure></div></li>
<li>通过函数创建有名管道<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">mode_t</span> mode)</span></span></span><br><span class="line"><span class="function">参数:</span></span><br><span class="line"><span class="function">    *pathname:管道名称的路径，可以是绝对路径也可以是相对路径</span></span><br><span class="line"><span class="function">    mode:文件权限，和open()函数里面的mode是一样的</span></span><br></pre></td></tr></table></figure></div></li>
<li>常见的I&#x2F;O函数都可以用于FIFO</li>
</ol>
<h5 id="有名管道的注意事项"><a href="#有名管道的注意事项" class="headerlink" title="有名管道的注意事项"></a>有名管道的注意事项</h5><ol>
<li>一个为<strong>只读</strong>而打开一个管道的进程会阻塞，直到另外一个进程为<strong>只写</strong>打开管道</li>
<li>读管道读数据:<ol>
<li>管道写端全部关闭:<ol>
<li>管道无数据，read会返回0(相当于读到文件末尾)</li>
<li>管道有数据，先将管道剩余数据读取完，再次read会返回0(相当于读到文件末尾)</li>
</ol>
</li>
<li>管道写端没有全部关闭<ol>
<li>管道无数据，写入数据将管道塞满</li>
<li>管道有数据，写入数据将管道塞满</li>
</ol>
</li>
</ol>
</li>
<li>写管道写数据:<ol>
<li>读端全部关闭，收到一个<strong>SIGPIPE</strong>信号，进程异常终止</li>
<li>读端没有全部关闭:<ol>
<li>管道已经满了，write()会阻塞</li>
<li>管道没有满，write()将数据写入</li>
</ol>
</li>
</ol>
</li>
<li>一个进程只能以一种方式打开有名管道(即要么以只读的方式打开FIFO，要么以只写的方式打开FIFO)，因为如果以又能读又能写的方式打开FIFO的话，该进程就会出现自己读取到自己写入的数据，并且因为被读取完的数据会被丢弃，那样想要通信的另外一个进程就无法获得消息</li>
</ol>
<h4 id="管道的优势和劣势"><a href="#管道的优势和劣势" class="headerlink" title="管道的优势和劣势"></a>管道的优势和劣势</h4><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优势 </summary>
              <div class="content">
              <p>简单，我们容易得知管道里的数据已经被另外一个进程读取</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>劣势 </summary>
              <div class="content">
              <p>通信效率低下</p>
              </div>
            </details>

<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是保存在内核中的消息链表，在发送数据时，会分成一个一个独立的数据单元，也就是消息体(数据块)，消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p>
<p><strong>消息这种模型，就好像两个进程发邮件一样，你来一封，我来一封，可以频繁沟通</strong></p>
<h4 id="消息队列的优势和劣势"><a href="#消息队列的优势和劣势" class="headerlink" title="消息队列的优势和劣势"></a>消息队列的优势和劣势</h4><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优势 </summary>
              <div class="content">
              <p>相对于管道，消息队列交换数据的效率明显提高了</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>劣势 </summary>
              <div class="content">
              <ol><li>通信不及时</li><li>附件大小也有限制</li></ol>
              </div>
            </details>

<h3 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h3><p>内存映射(Memory-mapped I&#x2F;O)是将磁盘文件的数据映射到内存，用于通过修改内存就能修改磁盘文件</p>
<h4 id="内存映射的一些API"><a href="#内存映射的一些API" class="headerlink" title="内存映射的一些API"></a>内存映射的一些API</h4><ol>
<li>映射一个文件到内存中，实现文件物理地址和进程虚拟地址的一一对应<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">mmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length,<span class="type">int</span> prot,<span class="type">int</span> flags,<span class="type">int</span> fd,<span class="type">off_t</span> offset)</span></span></span><br><span class="line"><span class="function">参数:</span></span><br><span class="line"><span class="function">    *addr: NULL,由内核指定</span></span><br><span class="line"><span class="function">    length: 要映射的数据的长度，这个长度不能为<span class="number">0</span>,建议使用文件的长度(可以通过 stat()/lseek() 函数获取)</span></span><br><span class="line"><span class="function">    prot:对申请内存映射区的操作权限</span></span><br><span class="line"><span class="function">        PROT_EXEC:可执行权限    PROT_READ:可读权限  PROT_WRITE:写权限   PORT_NONE:没有权限</span></span><br><span class="line"><span class="function">        注意:要操作内存，就必须要有读权限</span></span><br><span class="line"><span class="function">    flags:</span></span><br><span class="line"><span class="function">        MAP_SHARED:映射区的数据会自动和磁盘文件进行同步，若要进程间通信，必须要设置这个选项</span></span><br><span class="line"><span class="function">        MAP_PRIVATE:不同步，会重新创建一个新的文件</span></span><br><span class="line"><span class="function">    fd:需要映射的文件的文件描述符</span></span><br><span class="line"><span class="function">        注意:文件大小不能为<span class="number">0</span>，也就是length不能为<span class="number">0</span>，open()指定的权限不能与prot有冲突</span></span><br><span class="line"><span class="function">                prot指定的权限必须小于open()指定的权限，并且两个都需要有读的权限</span></span><br><span class="line"><span class="function">    offset:偏移量，一般不用，要用的话必须是<span class="number">4</span>K的整数倍</span></span><br><span class="line"><span class="function">返回值:</span></span><br><span class="line"><span class="function">    成功返回创建的内存的首地址，失败则返回MAP_FAILED</span></span><br></pre></td></tr></table></figure></div></li>
<li>释放内存映射<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">munmap</span><span class="params">(<span class="type">void</span> *addr,<span class="type">size_t</span> length)</span></span></span><br><span class="line"><span class="function">参数:</span></span><br><span class="line"><span class="function">    *addr:要释放的内存的首地址，可以通过mmap函数获取</span></span><br><span class="line"><span class="function">    length:要释放的内存的大小，和mmap函数的length参数的值一样</span></span><br><span class="line"><span class="function">返回值:</span></span><br><span class="line"><span class="function">    成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>后面会专门写一篇文章来讲信号的，这里就先不多说了</p>
<h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>消息队列的读写都发生了用户态到内核态的转变，过多的转变其实也很占用CPU资源，为了减少这种转变，共享内存就很好的解决了这一问题</p>
<p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p>
<p><strong>共享内存的机制，就是拿出一块虚拟地址空间来</strong>，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/25/blog6/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98.jpg" class title="共享内存">
<p>共享内存是效率最高的通信方式。</p>
<h4 id="共享内存使用步骤"><a href="#共享内存使用步骤" class="headerlink" title="共享内存使用步骤"></a>共享内存使用步骤</h4><details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>步骤 </summary>
              <div class="content">
              <ol><li>使用shmget()函数创建一个新的共享内存段或者区的一个已有的共享内存段的标识符(就是说有其他进程创建的共享内存段)，这个调用将返回后续调用需要用到的共享内存标识符</li><li>使用shmat()函数来附上共享内存段，即使该段称为调用进程的虚拟内存的一部分</li><li>此时在程序中就可以像对待其他可用内存那样对待这个共享内存段。为引用这块共享内存，程序需要使用由shmat()函数的返回值的addr值(一个指向进程的虚拟地址空间中该共享内存段的起点的指针)</li><li>shmdt()函数用来分离共享内存段。在这个调用之后，进程就无法再引用这块共享内存</li><li>调用shmctl()来删除共享内存段。只有当所有附加内存段的进程都与之分离之后内存段可会销毁，只有一个进程需要执行这一步</li></ol>
              </div>
            </details>
<h4 id="共享内存相关API"><a href="#共享内存相关API" class="headerlink" title="共享内存相关API"></a>共享内存相关API</h4><ol>
<li>创建一个新的共享内存(里面的数据都会被初始化为0)，或者获取一个既有的共享内存的标识<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span></span><br><span class="line"><span class="function">参数:</span></span><br><span class="line"><span class="function">    key_t key:key_t类型是一个整形，通过这个找到或者创建一个共享内存，一般使用<span class="number">16</span>进制并且不为<span class="number">0</span></span></span><br><span class="line"><span class="function">    size: 共享内存的大小</span></span><br><span class="line"><span class="function">    shmflg:属性</span></span><br><span class="line"><span class="function">            <span class="number">1.</span>访问权限</span></span><br><span class="line"><span class="function">            <span class="number">2.</span>附加权限   创建共享内存(IPC_CREAT)</span></span><br><span class="line"><span class="function">                        判断共享内存是否存在,不存在就创建(IPC_EXCL,需要和IPC_CREAT一起使用)</span></span><br><span class="line"><span class="function">返回值:</span></span><br><span class="line"><span class="function">    成功就返回共享内存的引用ID，后面操作共享内存都是通过这个值</span></span><br><span class="line"><span class="function">    失败就返回<span class="number">-1</span></span></span><br></pre></td></tr></table></figure></div></li>
<li>和当前的进程进行关联<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> *<span class="title">shmat</span><span class="params">(<span class="type">int</span> shmid,<span class="type">const</span> <span class="type">void</span> *shmaddr,<span class="type">int</span> shmflg)</span></span></span><br><span class="line"><span class="function">参数:</span></span><br><span class="line"><span class="function">    shmid:共享内存的标识(ID),由shmger返回值获取</span></span><br><span class="line"><span class="function">    shmaddr:申请的共享内存的其实地址，一般指定NULL，由内核来指定</span></span><br><span class="line"><span class="function">    shmflg:对共享内存的操作</span></span><br><span class="line"><span class="function">            读: SHM_REONLY,必须要有读权限</span></span><br><span class="line"><span class="function">            读写: <span class="number">0</span></span></span><br><span class="line"><span class="function">返回值:</span></span><br><span class="line"><span class="function">    成功返回共享内存的起始地址</span></span><br><span class="line"><span class="function">    失败返回<span class="number">-1</span></span></span><br></pre></td></tr></table></figure></div></li>
<li>解除当前进程和共享内存的关联<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span></span></span><br><span class="line"><span class="function">参数:</span></span><br><span class="line"><span class="function">    shmaddr:共享内存的首地址(起始地址)，通过shmat函数获得</span></span><br><span class="line"><span class="function">返回值:</span></span><br><span class="line"><span class="function">    成功返回<span class="number">0</span>，失败返回<span class="number">-1</span></span></span><br></pre></td></tr></table></figure></div></li>
<li>对共享内存进行操作，共享内存要删除才会消失，创建共享内存的进程被终止了对共享内存无影响<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">int</span> <span class="title">shmctl</span><span class="params">(<span class="type">int</span> shmid,<span class="type">int</span> cmd,<span class="keyword">struct</span> shmid_ds *buf)</span></span></span><br><span class="line"><span class="function">参数: </span></span><br><span class="line"><span class="function">    shmid:共享内存的标识号，通过shmget函数获得</span></span><br><span class="line"><span class="function">    cmd:要对共享内存做的操作</span></span><br><span class="line"><span class="function">        IPC_STAT:获取共享内存的当前状态</span></span><br><span class="line"><span class="function">        IPC_SET:设置共享内存的状态</span></span><br><span class="line"><span class="function">        IPC_RMID:标记共享内存被摧毁</span></span><br><span class="line"><span class="function">    struct shmid_ds *buf:需要设置或获取的共享内存的属性信息</span></span><br><span class="line"><span class="function">        若cmd=</span>IPC_STAT,则buf存储数据</span><br><span class="line">        若cmd=IPC_SET,则buf中需要初始化数据，设置到内核中</span><br><span class="line">        若cmd=IPC_RMID,没用，设置为<span class="built_in">NULL</span></span><br><span class="line">        (<span class="keyword">struct</span> shmid_ds:一个结构体，里面有一个成员shm_nattach,记录了该共享内存关联的进程的个数)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
5.根据指定的路径名和int值，生成一个共享内存的key<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">key_t</span> <span class="title">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">int</span> proj_id)</span></span></span><br><span class="line"><span class="function">参数:</span></span><br><span class="line"><span class="function">    pathname:指定一个存在的路径</span></span><br><span class="line"><span class="function">    proj_id:int类型的值，但是系统调用智慧使用其中的一个字节(范围:<span class="number">1</span><span class="number">-255</span>,一般指定一个字符<span class="string">&#x27;a&#x27;</span>)</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>用了共享内存通信方式，带来新的问题，那就是如果多个进程同时修改同一个共享内存，很有可能就冲突了。例如两个进程都同时写一个地址，那先写的那个进程会发现内容被别人覆盖了。</p>
<p>为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，<strong>信号量</strong>就实现了这一保护机制。</p>
<p>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。</p>
<p>信号量表示资源的数量</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>控制信号量的方式有两种原子操作 </summary>
              <div class="content">
              <ol><li>一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ol>
              </div>
            </details>
<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 1。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/25/blog6/%E4%BF%A1%E5%8F%B7%E9%87%8F.jpg" class title="信号量">
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>具体过程 </summary>
              <div class="content">
              <ol><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ol>
              </div>
            </details>

<p>可以发现，信号初始化为 1，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p>
<p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p>
<p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</p>
<p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 0。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/25/blog6/%E4%BF%A1%E5%8F%B7%E9%87%8F1.jpg" class title="信号量">
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>具体过程 </summary>
              <div class="content">
              <ol><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ol>
              </div>
            </details>
<p>可以发现，信号初始化为 0，就代表着是同步信号量，它可以保证进程 A 应在进程 B 之前执行。</p>
<h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p>前面提到的管道、消息队列、内存映射、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要<strong>Socket</strong>通信了。</p>
<p>实际上，Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p>
<h4 id="针对TCP协议的Socket编程模型"><a href="#针对TCP协议的Socket编程模型" class="headerlink" title="针对TCP协议的Socket编程模型"></a>针对TCP协议的Socket编程模型</h4><img lazyload src="/images/loading.svg" data-src="/2023/02/25/blog6/Tcp.jpg" class title="Tcp">

<ol>
<li>服务端和客户端初始化 socket，得到文件描述符；</li>
<li>服务端调用 bind，将绑定在 IP 地址和端口;</li>
<li>服务端调用 listen，进行监听；</li>
<li>服务端调用 accept，等待客户端连接；</li>
<li>客户端调用 connect，向服务器端的地址和端口发起连接请求；</li>
<li>服务端 accept 返回用于传输的 socket 的文件描述符；</li>
<li>客户端调用 write 写入数据；服务端调用 read 读取数据；</li>
<li>客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。</li>
</ol>
<p>这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</p>
<p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket。</p>
<p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p>
<h4 id="针对UDP协议的Socket编程模型"><a href="#针对UDP协议的Socket编程模型" class="headerlink" title="针对UDP协议的Socket编程模型"></a>针对UDP协议的Socket编程模型</h4><img lazyload src="/images/loading.svg" data-src="/2023/02/25/blog6/Udp.jpg" class title="Udp">
<p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p>
<p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p>
<p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p>
<h4 id="针对本地进程间通信的Socket编程模型"><a href="#针对本地进程间通信的Socket编程模型" class="headerlink" title="针对本地进程间通信的Socket编程模型"></a>针对本地进程间通信的Socket编程模型</h4><p>本地 socket  被用于在<strong>同一台主机上进程间通信</strong>的场景：</p>
<ol>
<li>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</li>
<li>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</li>
<li>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</li>
<li>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</li>
</ol>
<p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定<strong>一个本地文件</strong>，这也就是它们之间的最大区别。</p>
<h4 id="Socket相关的API"><a href="#Socket相关的API" class="headerlink" title="Socket相关的API"></a>Socket相关的API</h4><p>太多了，这里就不多说了，不懂得可以去看这篇文章:<a class="link" href="http://t.csdn.cn/EoIzG">http://t.csdn.cn/EoIzG <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>鼠鼠今天看到一个真实故事，大概讲的就就一个人的前女友脑出血成为了植物人，主人公和她已经和平分手1年了，突然有一天主人公接到了前女友的姐姐的电话，得知了前女友发生的事，然后展开的一个故事，里面的一句话让我特别难过”她听完我的录音后，并没有醒过来，那一刻，我多么希望电视剧里的憨憨剧情是真的”，不管是这个，里面还有着女主的哥哥写的一封信，令我特别特别难过，我多希望女主能像电视剧里面醒过来啊，但事与愿违，女主最后还是成为了天边的一朵云彩…</p>
<p>真的还蛮难过的，听主人公的描述，女主是一个善良天真的女孩，她才活了20几年啊，为什么这种事情会发生在她身上呢?世界上确实是有人该死的，但那一定不会是善良和好人啊，我们总之在担心以后的事情，但我们谁也没办法知道，意外和明天哪一个先到来，看完这个故事我又拾起了以前写遗书的想法，我想我大概会写一封遗书，我会一直去修改，如果有一天我的生命定格在了某一刻，那我希望有人能在我的博客上解开我的密码，替我完成我还未完成的心愿，只是现在的我还有太多事没做了，我还不能死</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>信号量以及一些互斥同步模型</title>
    <url>/2023/02/27/blog7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=29567192&auto=1&height=66"></iframe>

<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。</p>
<p>信号量表示资源的数量</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>控制信号量的方式有两种原子操作 </summary>
              <div class="content">
              <ol><li>一个是 P 操作，这个操作会把信号量减去 -1，相减后如果信号量 &lt; 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 &gt;&#x3D; 0，则表明还有资源可使用，进程可正常继续执行。</li><li>另一个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 &lt;&#x3D; 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 &gt; 0，则表明当前没有阻塞中的进程；</li></ol>
              </div>
            </details>
<p>P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。</p>
<p>接下来，举个例子，如果要使得两个进程互斥访问共享内存，我们可以初始化信号量为 1。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/27/blog7/%E4%BF%A1%E5%8F%B7%E9%87%8F.jpg" class title="信号量">
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>具体过程 </summary>
              <div class="content">
              <ol><li>进程 A 在访问共享内存前，先执行了 P 操作，由于信号量的初始值为 1，故在进程 A 执行 P 操作后信号量变为 0，表示共享资源可用，于是进程 A 就可以访问共享内存。</li><li>若此时，进程 B 也想访问共享内存，执行了 P 操作，结果信号量变为了 -1，这就意味着临界资源已被占用，因此进程 B 被阻塞。</li><li>直到进程 A 访问完共享内存，才会执行 V 操作，使得信号量恢复为 0，接着就会唤醒阻塞中的线程 B，使得进程 B 可以访问共享内存，最后完成共享内存的访问后，执行 V 操作，使信号量恢复到初始值 1。</li></ol>
              </div>
            </details>

<p>可以发现，信号初始化为 1，就代表着是<strong>互斥信号量</strong>，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。</p>
<p>另外，在多进程里，每个进程并不一定是顺序执行的，它们基本是以各自独立的、不可预知的速度向前推进，但有时候我们又希望多个进程能密切合作，以实现一个共同的任务。</p>
<p>例如，进程 A 是负责生产数据，而进程 B 是负责读取数据，这两个进程是相互合作、相互依赖的，进程 A 必须先生产了数据，进程 B 才能读取到数据，所以执行是有前后顺序的。</p>
<p>那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 0。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/27/blog7/%E4%BF%A1%E5%8F%B7%E9%87%8F1.jpg" class title="信号量">
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>具体过程 </summary>
              <div class="content">
              <ol><li>如果进程 B 比进程 A 先执行了，那么执行到 P 操作时，由于信号量初始值为 0，故信号量会变为 -1，表示进程 A 还没生产数据，于是进程 B 就阻塞等待；</li><li>接着，当进程 A 生产完数据后，执行了 V 操作，就会使得信号量变为 0，于是就会唤醒阻塞在 P 操作的进程 B；</li><li>最后，进程 B 被唤醒后，意味着进程 A 已经生产了数据，于是进程 B 就可以正常读取数据了。</li></ol>
              </div>
            </details>

<p>可以发现，信号初始化为 0，就代表着是同步信号量，它可以保证进程 A 应在进程 B 之前执行。</p>
<h2 id="一些同步模型"><a href="#一些同步模型" class="headerlink" title="一些同步模型"></a>一些同步模型</h2><h3 id="消费者与生产者模型"><a href="#消费者与生产者模型" class="headerlink" title="消费者与生产者模型"></a>消费者与生产者模型</h3><h4 id="模型解释"><a href="#模型解释" class="headerlink" title="模型解释"></a>模型解释</h4><p>所谓生产者与消费者模型，就是指有一些生产者，每次会生产一些产品(数据)到容器里面(储存数据的数据结构)，一群消费者对容器里的产品进行消费(对数据进行处理)，如图</p>

<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>而为了实现线程的临界区的数据安全，所以可以用mutex(互斥锁)来保证数据的安全</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>消费者与生产者模型简单代码(mutex实现) </summary>
              <div class="content">
              <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现生产者消费者模型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表数据结构，用作容器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">        next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加互斥锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex1;</span><br><span class="line"><span class="comment">//pthread_mutex_t mutex2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以添加的数据</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">Node *head=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者函数,往容器里面添加数据(头插法)</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Produce</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不断地创建新的产品添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex1);</span><br><span class="line">        Node *newnode=<span class="keyword">new</span> <span class="built_in">Node</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head=newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newnode-&gt;next=head;</span><br><span class="line">            head=newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;已添加数据为：&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;的产品!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者函数,往容器里面读取数据(尾删法)</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Consume</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pthread_mutex_lock(&amp;mutex2);</span></span><br><span class="line">    <span class="comment">//不断地从链表中删除节点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex1);</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *p1=head;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">NULL</span>&amp;&amp;p1-&gt;next!=p)</span><br><span class="line">        &#123;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==head)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;已删除数据为：&quot;</span>&lt;&lt;p-&gt;id&lt;&lt;<span class="string">&quot;的产品!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            head=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;已删除数据为：&quot;</span>&lt;&lt;p-&gt;id&lt;&lt;<span class="string">&quot;的产品!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            p1-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pthread_mutex_unlock(&amp;mutex2);</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//pthread_mutex_unlock(&amp;mutex2);</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex1);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex1,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//pthread_mutex_init(&amp;mutex2,NULL);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建5个生产者和5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> produce[<span class="number">5</span>],consume[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;produce[i],<span class="literal">NULL</span>,Produce,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;consume[i],<span class="literal">NULL</span>,Consume,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接子线程，等子线程结束后自动回收资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(produce[i]);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(consume[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁互斥锁资源</span></span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex1);</span><br><span class="line">    <span class="comment">//pthread_mutex_destroy(&amp;mutex2);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<p>还有一种方法就是使用信号量来实现资源的互斥与同步啦，在上面的代码中，我们是利用判断链表是否为空来判断有无产品可以让消费者消费，但是在信号量中，我们就可以省略这一步，直接依靠信号量来实现数据的同步</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>消费者与生产者模型简单代码(sem实现) </summary>
              <div class="content">
              <div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现生产者消费者模型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链表数据结构，用作容器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;id=id;</span><br><span class="line">        next=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加信号量</span></span><br><span class="line"><span class="type">sem_t</span> *sem;</span><br><span class="line"><span class="type">sem_t</span> *produce;</span><br><span class="line"><span class="type">sem_t</span> *consume;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以添加的数据</span></span><br><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">Node *head=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者函数,往容器里面添加数据(头插法)</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Produce</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不断地创建新的产品添加到链表中</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(produce); <span class="comment">//将produce信号量-1，如果减完后的结果小于0代表容器没有空间给生产者生产。</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(sem);  <span class="comment">//将sem信号量-1，表示只能有一个线程进行生产</span></span><br><span class="line">        Node *newnode=<span class="keyword">new</span> <span class="built_in">Node</span>(i);</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head=newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            newnode-&gt;next=head;</span><br><span class="line">            head=newnode;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;已添加数据为：&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;的产品!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sem_post</span>(sem);  <span class="comment">//表示该线程生产结束</span></span><br><span class="line">        <span class="built_in">sem_post</span>(consume)； <span class="comment">//表示消费者可以消费的产品+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者函数,往容器里面读取数据(尾删法)</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">Consume</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pthread_mutex_lock(&amp;mutex2);</span></span><br><span class="line">    <span class="comment">//不断地从链表中删除节点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(consume);  <span class="comment">//如果生产者没有生产数据，那么就不会执行sem_post(consume)函数，那么此时consume信号量的值为0，执行完sem_wait(consume)后就为-1，那么就会阻塞</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(sem);</span><br><span class="line">        Node *p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;p-&gt;next!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        Node *p1=head;</span><br><span class="line">        <span class="keyword">while</span>(p1!=<span class="literal">NULL</span>&amp;&amp;p1-&gt;next!=p)</span><br><span class="line">        &#123;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p==head)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;已删除数据为：&quot;</span>&lt;&lt;p-&gt;id&lt;&lt;<span class="string">&quot;的产品!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            head=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="built_in">pthread_self</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="string">&quot;已删除数据为：&quot;</span>&lt;&lt;p-&gt;id&lt;&lt;<span class="string">&quot;的产品!&quot;</span>&lt;&lt;endl;</span><br><span class="line">            p1-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sem_post</span>(sem);</span><br><span class="line">        <span class="built_in">sem_post</span>(produce);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化信号量</span></span><br><span class="line">    <span class="built_in">sem_init</span>(sem,<span class="number">0</span>,<span class="number">1</span>);  <span class="comment">//表示只有一个线程可以访问容器</span></span><br><span class="line">    <span class="built_in">sem_init</span>(produce,<span class="number">0</span>,<span class="number">5</span>);  <span class="comment">//表示生产者还可以生产多少个产品</span></span><br><span class="line">    <span class="built_in">sem_init</span>(consume,<span class="number">0</span>,<span class="number">5</span>);  <span class="comment">//表示消费者还可以消费多少个产品</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建5个生产者和5个消费者</span></span><br><span class="line">    <span class="type">pthread_t</span> produce[<span class="number">5</span>],consume[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;produce[i],<span class="literal">NULL</span>,Produce,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;consume[i],<span class="literal">NULL</span>,Consume,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接子线程，等子线程结束后自动回收资源</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_detach</span>(produce[i]);</span><br><span class="line">        <span class="built_in">pthread_detach</span>(consume[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//销毁信号量</span></span><br><span class="line">    <span class="built_in">sem_destroy</span>(sem);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(produce);</span><br><span class="line">    <span class="built_in">sem_destroy</span>(consume);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//退出主线程</span></span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<h3 id="哲学家进餐模型"><a href="#哲学家进餐模型" class="headerlink" title="哲学家进餐模型"></a>哲学家进餐模型</h3><h4 id="模型解释-1"><a href="#模型解释-1" class="headerlink" title="模型解释"></a>模型解释</h4><img lazyload src="/images/loading.svg" data-src="/2023/02/27/blog7/%E5%93%B2%E5%AD%A6%E5%AE%B6.jpg" class title="哲学家">
<p>先来看看哲学家就餐的问题描述：</p>
<ol>
<li><code>5</code>个老大哥哲学家，闲着没事做，围绕着一张圆桌吃面；</li>
<li>巧就巧在，这个桌子只有 5 支叉子，每两个哲学家之间放一支叉子；</li>
<li>哲学家围在一起先思考，思考中途饿了就会想进餐；</li>
<li>奇葩的是，这些哲学家要两支叉子才愿意吃面，也就是需要拿到左右两边的叉子才进餐；</li>
<li>吃完后，会把两支叉子放回原处，继续思考；<br>那么问题来了，如何保证哲学家们的动作有序进行，而不会出现有人永远拿不到叉子呢？</li>
</ol>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>可以用锁来实现，但因为有很多勺子，所以在此基础上修改一下，改用信号量来实现</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5     <span class="comment">//哲学家的个数为N</span></span></span><br><span class="line"><span class="type">sem_t</span> fork[<span class="number">5</span>]   <span class="comment">//N把勺子信号量，每个信号量初始化为1，用循环来实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">smart_person</span><span class="params">(<span class="type">int</span> i)</span>    <span class="comment">//i为哲学家的编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">think</span>();                <span class="comment">//哲学家思考ing</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(fork[i]);      <span class="comment">//拿左边的勺子</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(fork[(i+<span class="number">1</span>)%N]) <span class="comment">//拿右边的勺子</span></span><br><span class="line">    <span class="built_in">eat</span>();                  <span class="comment">//进餐</span></span><br><span class="line">    <span class="built_in">sem_post</span>(fork[i]);      <span class="comment">//放下左边的勺子</span></span><br><span class="line">    <span class="built_in">sem_post</span>(fork[(i+<span class="number">1</span>)%N]) <span class="comment">//放下右边的勺子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>但这就会出现一种极端情况，那就是如果每个人都拿了左边的勺子，那么此时就会出现死锁，谁也无法走到第二步(也就是去拿右边的勺子，因为此时已经被他左边的人拿了)</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/27/blog7/%E5%93%B2%E5%AD%A6%E5%AE%B61.jpg" class title="哲学家1">

<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>为了解决方法一出现的问题，我们可以当只要有一个哲学家思考结束准备开始吃饭的时候就对所有勺子上锁(也可以是信号量)，代码如下:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5                 <span class="comment">//哲学家的个数为N</span></span></span><br><span class="line"><span class="type">sem_t</span> *fork[<span class="number">5</span>];              <span class="comment">//N把勺子信号量，每个信号量初始化为1，用循环来实现</span></span><br><span class="line"><span class="type">sem_t</span> *sem;                  <span class="comment">//给临界区的锁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">smart_person</span><span class="params">(<span class="type">int</span> i)</span>    <span class="comment">//i为哲学家的编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">think</span>();                <span class="comment">//哲学家思考ing</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(sem)</span><br><span class="line">    <span class="built_in">sem_wait</span>(fork[i]);      <span class="comment">//拿左边的勺子</span></span><br><span class="line">    <span class="built_in">sem_wait</span>(fork[(i+<span class="number">1</span>)%N]) <span class="comment">//拿右边的勺子</span></span><br><span class="line">    <span class="built_in">eat</span>();                  <span class="comment">//进餐</span></span><br><span class="line">    <span class="built_in">sem_post</span>(fork[i]);      <span class="comment">//放下左边的勺子</span></span><br><span class="line">    <span class="built_in">sem_post</span>(fork[(i+<span class="number">1</span>)%N]) <span class="comment">//放下右边的勺子</span></span><br><span class="line">    <span class="built_in">sem_post</span>(sem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这样是不会出现死锁的情况了，但是这样就会导致一次只能有一个哲学家进餐，但实际上我们知道，同一时间可以有两个哲学家进餐的</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/27/blog7/%E5%93%B2%E5%AD%A6%E5%AE%B62.jpg" class title="哲学家2">

<h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>那既然方案二使用互斥信号量，会导致只能允许一个哲学家就餐，那么我们就不用它。</p>
<p>另外，方案一的问题在于，会出现所有哲学家同时拿左边刀叉的可能性，那我们就避免哲学家可以同时拿左边的刀叉，采用分支结构，根据哲学家的编号的不同，而采取不同的动作。</p>
<p><strong>即让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」</strong></p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5     <span class="comment">//哲学家的个数为N</span></span></span><br><span class="line"><span class="type">sem_t</span> fork[<span class="number">5</span>]   <span class="comment">//N把勺子信号量，每个信号量初始化为1，用循环来实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">smart_person</span><span class="params">(<span class="type">int</span> i)</span>    <span class="comment">//i为哲学家的编号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">think</span>();                <span class="comment">//哲学家思考ing</span></span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)              <span class="comment">//如果哲学家的编号为偶数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(fork[i]);      <span class="comment">//先拿左边的勺子</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(fork[(i+<span class="number">1</span>)%N]) <span class="comment">//后拿右边的勺子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>                    <span class="comment">//如果哲学家的编号为奇数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(fork[(i+<span class="number">1</span>)%N]) <span class="comment">//先拿右边的勺子</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(fork[i]);      <span class="comment">//后拿左边的勺子</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">eat</span>();                  <span class="comment">//进餐</span></span><br><span class="line">    <span class="built_in">sem_post</span>(fork[i]);      <span class="comment">//放下左边的勺子</span></span><br><span class="line">    <span class="built_in">sem_post</span>(fork[(i+<span class="number">1</span>)%N]) <span class="comment">//放下右边的勺子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上面的程序，在 P 操作时，根据哲学家的编号不同，拿起左右两边叉子的顺序不同。另外，V 操作是不需要分支的，因为 V 操作是不会阻塞的</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/27/blog7/%E5%93%B2%E5%AD%A6%E5%AE%B63.jpg" class title="哲学家3">

<h4 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h4><p>在这里再提出另外一种可行的解决方案，我们用一个<strong>数组state来记录每一位哲学家在进程、思考还是饥饿状态(正在试图拿叉子)</strong></p>
<p>那么，<strong>一个哲学家只有在两个邻居都没有进餐时，才可以进入进餐状态</strong></p>
<p>第 i 个哲学家的左邻右舍，则由宏 LEFT 和 RIGHT 定义：</p>
<p>LEFT : ( i + 5  - 1 ) % 5<br>RIGHT : ( i + 1 ) % 5<br>比如 i 为 2，则 LEFT 为 1，RIGHT 为 3。</p>
<p>这里就直接贴一张图片吧</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/27/blog7/%E4%BB%A3%E7%A0%81.jpg" class title="代码">
<p>上面的程序使用了一个信号量数组，每个信号量对应一位哲学家，这样在所需的叉子被占用时，想进餐的哲学家就被阻塞</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/27/blog7/%E5%93%B2%E5%AD%A6%E5%AE%B64.jpg" class title="哲学家">

<h3 id="读者-写者模型"><a href="#读者-写者模型" class="headerlink" title="读者-写者模型"></a>读者-写者模型</h3><h4 id="模型解释-2"><a href="#模型解释-2" class="headerlink" title="模型解释"></a>模型解释</h4><p>前面的「哲学家进餐问题」对于互斥访问有限的竞争问题（如 I&#x2F;O 设备）一类的建模过程十分有用。</p>
<p>另外，还有个著名的问题是「读者-写者」，它为数据库访问建立了一个模型。</p>
<p>读者只会读取数据，不会修改数据，而写者即可以读也可以修改数据。</p>
<p>读者-写者的问题描述：</p>
<p>「读-读」允许：同一时刻，允许多个读者同时读<br>「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写<br>「写-写」互斥：没有其他写者时，写者才能写<br>接下来，提出几个解决方案来分析分析，依旧是用信号量来解决问题。</p>
<h4 id="方法一，读者优先"><a href="#方法一，读者优先" class="headerlink" title="方法一，读者优先"></a>方法一，读者优先</h4><p>所谓读者优先，意思就是说只要有读者，那么写者就阻塞，直到没有读者了才能继续写</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> *write;    <span class="comment">//写者信号量，因为同一时间只能允许一个写者写</span></span><br><span class="line"><span class="type">int</span> rCount;     <span class="comment">//读者数量</span></span><br><span class="line"><span class="type">sem_t</span> *rCountSem;    <span class="comment">//对rCount的信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(write);    <span class="comment">//当有写者在写时，其他写者无法进行写函数    </span></span><br><span class="line">        <span class="built_in">write</span>();            <span class="comment">//写函数</span></span><br><span class="line">        <span class="built_in">sem_post</span>(write);    <span class="comment">//写完</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读者函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//可以有多个读者读取数据，所以不需要对数据进行上锁</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//但是为了防止多个读者进入，rCount出现错误，所以需要对rCount上锁</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(rCountSem);</span><br><span class="line">        <span class="keyword">if</span>(rCount==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sem_wait</span>(write);    <span class="comment">//当第一个读着进入时，如果有写者，就阻塞写者</span></span><br><span class="line">        &#125;</span><br><span class="line">        rCount++;   <span class="comment">//读者数量+1</span></span><br><span class="line">        <span class="built_in">sem_post</span>(rCountSem);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">read</span>();     <span class="comment">//进行读函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//读者读完数据就退出</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(rCountSem);</span><br><span class="line">        rCount--;           <span class="comment">//读者数量-1</span></span><br><span class="line">        <span class="keyword">if</span>(rCount==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sem_post</span>(write);    <span class="comment">//只有当读者数量为0的时候，写者才能继续写，如果一直有读者进来，那么写者就永远阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sem_post</span>(rCountSem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="方法二，写者优先"><a href="#方法二，写者优先" class="headerlink" title="方法二，写者优先"></a>方法二，写者优先</h4><p>既然有读者优先策略，自然也有写者优先策略。<br>只要有写者准备要写入，写者应尽快执行写操作，后来的读者就必须阻塞；<br>如果有写者持续不断写入，则读者就处于饥饿；</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">sem_t</span> *write;    <span class="comment">//控制写者写操作的信号量，初始为1</span></span><br><span class="line"><span class="type">int</span> wCount;     <span class="comment">//记录写者的数量，初始为0</span></span><br><span class="line"><span class="type">sem_t</span> *wCountSem;   <span class="comment">//对wCount的控制，初始为1</span></span><br><span class="line"><span class="type">sem_t</span> *read;     <span class="comment">//控制读者进入的信号量，初始为1</span></span><br><span class="line"><span class="type">int</span> rCount;     <span class="comment">//记录读者的数量</span></span><br><span class="line"><span class="type">sem_t</span> *rCountSem;   <span class="comment">//对rCount的控制，初始为1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(wCountSem);</span><br><span class="line">        <span class="keyword">if</span>(wCount==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sem_wait</span>(read);     <span class="comment">//当第一个写者进入时，如果有读者就阻塞</span></span><br><span class="line">        &#125;</span><br><span class="line">        wCount++;       <span class="comment">//写者数量+1</span></span><br><span class="line">        <span class="built_in">sem_post</span>(wCountSem);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sem_wait</span>(write);    <span class="comment">//对读者写操作进行互斥</span></span><br><span class="line">        <span class="built_in">write</span>();        <span class="comment">//写函数</span></span><br><span class="line">        <span class="built_in">sem_post</span>(write);    </span><br><span class="line"></span><br><span class="line">        <span class="built_in">sem_wwait</span>(wCountSem);</span><br><span class="line">        wCount--;   <span class="comment">//写者数量-1</span></span><br><span class="line">        <span class="keyword">if</span>(wCount==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sem_post</span>(read);     <span class="comment">//当写者数量为0的时候，唤醒读者去读取数据</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sem_post</span>(wCountSem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(read);     <span class="comment">//控制读者进入，只有当写者数量为0的时候执行了P(read)操作才能开始读操作</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(rCountSem);</span><br><span class="line">        <span class="keyword">if</span>(rCount==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//当第一个读者进入的时候,依旧需要对写者进行阻塞</span></span><br><span class="line">            <span class="built_in">sem_wait</span>(write);</span><br><span class="line">        &#125;</span><br><span class="line">        rCount++;   <span class="comment">//读者数量+1</span></span><br><span class="line">        <span class="built_in">sem_post</span>(rCountSem);</span><br><span class="line">        <span class="built_in">sem_post</span>(read);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">read</span>(); <span class="comment">//读操作</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">sem_wait</span>(rCountSem);</span><br><span class="line">        rCount--;</span><br><span class="line">        <span class="keyword">if</span>(rCount==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sem_post</span>(write);    <span class="comment">//当读者全部读完，就唤醒写者进行写操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sem_post</span>(rCountSem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>一开始，当有写者开始写操作的时候，会进行P(read),那么此时后续的读者就无法进行读取操作，但需要注意的是，即使后续的读者无法进行操作，但是如果已经有读者在读取数据了，也会执行P(write)操作，也就意味着写者是无法执行写操作。</p>
<h4 id="方案三，公平策略"><a href="#方案三，公平策略" class="headerlink" title="方案三，公平策略"></a>方案三，公平策略</h4><p>优先级相同；<br>写者、读者互斥访问；<br>只能一个写者访问临界区；<br>可以有多个读者同时访问临街资源；、</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> rCount;         <span class="comment">//记录读者数量</span></span><br><span class="line"><span class="type">sem_t</span> *write;        <span class="comment">//写者写操作的互斥，初始为1</span></span><br><span class="line"><span class="type">sem_t</span> *flag;         <span class="comment">//为了实现公平,初始为1</span></span><br><span class="line"><span class="type">sem_t</span> *rCountSem;    <span class="comment">//对rCount的互斥信号量，初始为1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(flag);</span><br><span class="line">    <span class="built_in">sem_wait</span>(write);</span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    <span class="built_in">sem_post</span>(write);</span><br><span class="line">    <span class="built_in">sem_post</span>(flag);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sem_wait</span>(flag);</span><br><span class="line">    <span class="built_in">sem_wait</span>(rCountSem);</span><br><span class="line">    <span class="keyword">if</span>(rCount==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_wait</span>(write);</span><br><span class="line">    &#125;</span><br><span class="line">    rCount++;</span><br><span class="line">    <span class="built_in">sem_post</span>(rCountSem);</span><br><span class="line">    <span class="built_in">sem_post</span>(flag);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sem_wait</span>(rCountSem);</span><br><span class="line">    rCount--;</span><br><span class="line">    <span class="keyword">if</span>(rCount==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_post</span>(write);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sem_post</span>(rCountSem);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>对比方案一的读者优先策略，可以发现，读者优先中只要后续有读者到达，读者就可以进入读者队列， 而写者必须等待，直到没有读者到达。</p>
<p>没有读者到达会导致读者队列为空，即 rCount&#x3D;&#x3D;0，此时写者才可以进入临界区执行写操作。</p>
<p>而这里 flag 的作用就是阻止读者的这种特殊权限(特殊权限是只要读者到达，就可以进入读者队列)。<br>比如：开始来了一些读者读数据，它们全部进入读者队列，此时来了一个写者，执行 P(falg) 操作，使得后续到来的读者都阻塞在 flag 上，不能进入读者队列，这会使得读者队列逐渐为空，即 rCount 减为 0。</p>
<p>这个写者也不能立马开始写(因为此时读者队列不为空)，会阻塞在信号量 wDataMutex 上，读者队列中的读者全部读取结束后，最后一个读者进程执行 V(wDataMutex)，唤醒刚才的写者，写者则继续开始进行写操作。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++的继承、封装和多态</title>
    <url>/2023/02/28/blog8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=202373&auto=1&height=66"></iframe>

<h2 id="C-面向对象的三种方式"><a href="#C-面向对象的三种方式" class="headerlink" title="C++面向对象的三种方式"></a>C++面向对象的三种方式</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>在C++里面，可以用class来定义一个类，而这个类与C语言中static很像，它们都可以让用户自己定义一个数据类型，不同的是，类中还可以有函数，而类中的数据又有三种类型，分别为public(公共的),protect(保护的),private(私有的)。</p>
<ol>
<li><p>封装可以隐藏实现细节，使得代码模块化，使代码和功能独立</p>
</li>
<li><p>封装是把函数和数据包含在一个类里，数据只能通过函数或可以信任的对象进行访问，对不可信的对象进行隐藏</p>
</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承:一个类可以使用另外一个类的所有功能，并在无需重新编写的情况下对继承过来的类进行补充扩展。</p>
<p>通过继承而来的类又被称为“子类”，被继承的类被称为“父类”或者“基类”。</p>
<h4 id="继承的三种实现方式"><a href="#继承的三种实现方式" class="headerlink" title="继承的三种实现方式"></a>继承的三种实现方式</h4><ol>
<li><p>实现继承：直接使用基类的属性和方法而无需额外编码</p>
</li>
<li><p>接口继承：指仅仅使用属性和方法的名称，但是子类必须提供代码的实现</p>
</li>
<li><p>可视继承：指子窗体(类)使用基窗体(类)的外观和实现代码的能力</p>
</li>
</ol>
<h4 id="单一继承"><a href="#单一继承" class="headerlink" title="单一继承"></a>单一继承</h4><p>子类只继承了一个父类，这种情况称为单一继承，一般情况下都使用单一继承，使用多重继承容易造成混乱</p>
<h4 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h4><p>一个子类继承了多个父类，类与类之间要用逗号隔开，类名之前要有继承权限，假使两个或两个基类都有某变量或函数，在子类中调用时需要加类名限定符如c.a::i &#x3D; 1；</p>
<h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><p>假设有一个基类A，他有两个子类B和C都继承了A中的某个函数并且都进行了重写，此时又有一个子类用多重继承了B和C，那么此时就有出现一种情况，例如:</p>
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  菱形继承 菱形继承是多继承的一种特殊情况。</span></span><br><span class="line"><span class="comment">//菱形继承的问题：从下面的对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_a = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_b = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> :<span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_c = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> :<span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_d = <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    D d;</span><br><span class="line">    d.m_d = <span class="number">40</span>;</span><br><span class="line">    d.m_c = <span class="number">30</span>;</span><br><span class="line">    d.m_b = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//.m_a = 10;//  二义性</span></span><br><span class="line">    <span class="comment">// 不能够访问  因为B 和C分别继承了A的m_a</span></span><br><span class="line">    <span class="comment">//但是D 继承了B和C的m_a 所以D不能够分辨m_a到底是谁的</span></span><br><span class="line">    d.B::m_a = <span class="number">100</span>;</span><br><span class="line">    d.C::m_a = <span class="number">200</span>;</span><br><span class="line">    <span class="comment">// 这样的话 就造成了m_a 有两个空间  一个B的100  一个C的200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="如何解决菱形继承的问题呢？"><a href="#如何解决菱形继承的问题呢？" class="headerlink" title="如何解决菱形继承的问题呢？"></a>如何解决菱形继承的问题呢？</h4><ol>
<li><p>最简单的，就是尽量不要出现菱形继承这种情况。</p>
</li>
<li><p>如果一定会用到菱形继承的话，可以用虚基类来解决，关于什么是虚基类，往下接着看吧</p>
</li>
<li><p>虚基表的引入也可以解决这个问题</p>
</li>
<li><p>详细可见：<a class="link" href="http://t.csdn.cn/goF1f">http://t.csdn.cn/goF1f <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>一个接口多种方法，即用同一个接口，但是效果不同</p>
<h4 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h4><p>是在编译期就把函数链接起来，此时即可确定调用哪个函数或模板，静态多态是由模板和重载实现的，在宏多态中，是通过定义变量，编译时直接把变量替换，实现宏多态。</p>
<h5 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h5><p>template <class t>定义一个模板。</class></p>
<p>详情请见：<a class="link" href="http://t.csdn.cn/QJqBk">http://t.csdn.cn/QJqBk <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><ol>
<li><p>重载又有函数重载和运算符重载。</p>
</li>
<li><p>函数重载详情请见：<a class="link" href="http://t.csdn.cn/iwGFT">http://t.csdn.cn/iwGFT <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
<li><p>运算符重载请见：<a class="link" href="http://t.csdn.cn/vMRYM">http://t.csdn.cn/vMRYM <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ol>
<h4 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h4><p>是指在程序运行时才能确定函数和实现的链接，此时才能确定调用哪个函数，父类指针或者引用能够指向子类对象，调用子类的函数，所以在编译时是无法确定调用哪个函数。</p>
<p>使用时在父类中写一个虚函数，在子类中分别重写，用这个父类指针调用这个虚函数，它实际上会调用各自子类重写的虚函数。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/28/blog8/%E4%BB%A3%E7%A0%81.jpg" class title="代码">
<div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">call child func</span><br><span class="line">call ~base</span><br></pre></td></tr></table></figure></div>

<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>用virtual关键字修饰的函数；</p>
<p>本质上由虚指针和虚表控制，虚指针指向虚表中的某个函数入口地址，就实现了多态</p>
<p>详细可见:<a class="link" href="http://t.csdn.cn/CJs8B">http://t.csdn.cn/CJs8B <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h5 id="构造函数可以是虚函数吗？"><a href="#构造函数可以是虚函数吗？" class="headerlink" title="构造函数可以是虚函数吗？"></a>构造函数可以是虚函数吗？</h5><p>答：不可以，因为我们知道有虚函数的类在创建实例的时候会通过构造函数创建虚函数表，当调用虚函数的时候需要通过虚指针指向虚函数来调用，那么问题来了，当我们创建一个构造函数是虚函数的实例的时候，需要调用构造函数，而构造函数又因为是虚函数需要有虚函数表，那么此时就矛盾了，所以构造函数不可以是虚函数。</p>
<h5 id="析构函数可以是虚函数吗"><a href="#析构函数可以是虚函数吗" class="headerlink" title="析构函数可以是虚函数吗"></a>析构函数可以是虚函数吗</h5><p>析构函数可以是虚函数，且常常如此</p>
<p>这个就好理解了，因为此时 vtable 已经初始化了；况且我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。</p>
<h4 id="多态存在的三个必要条件"><a href="#多态存在的三个必要条件" class="headerlink" title="多态存在的三个必要条件"></a>多态存在的三个必要条件</h4><ol>
<li><p>继承</p>
</li>
<li><p>重写</p>
</li>
<li><p>父类引用指向子类对象</p>
</li>
</ol>
<h4 id="实现多态的方法"><a href="#实现多态的方法" class="headerlink" title="实现多态的方法"></a>实现多态的方法</h4><ol>
<li><p>面向对象有了一个重要的概念就是对象的实例，对象的实例代表一个具体的对象，所以肯定有一个数据结构来保存这一实例的数据，这一数据包括对象变量成员，如果对象有虚函数方法或存在虚函数的话，则还有对应的虚函数或虚表指针，不包括其他函数指针</p>
</li>
<li><p>虚函数在c++中的实现机制就是用虚表和虚指针，是每个类用了一个虚表，每个类的对象用了一个虚指针。要讲虚函数机制，必须讲继承，因为只有继承才有虚函数的动态绑定功能</p>
</li>
<li><p>详细可见上面的虚函数的知识</p>
</li>
</ol>
<p>这篇博客有点水，等有时间了鼠鼠会重新写一次的，因为鼠鼠最近在看操作系统的东西，它太抽象啦!!!!所以可能鼠鼠要花很久的时间,哎，鼠鼠好菜的，鼠鼠好想找个实习呀，鼠鼠想赚钱，鼠鼠想去看周董演唱会，鼠鼠还想去西藏玩，鼠鼠想做的事情好多啊，但是鼠鼠只能躲在小小的小窝里，因为鼠鼠知道鼠鼠的能力还不够让上层社会的人看到鼠鼠，所以鼠鼠也有在努力啊，可是学历就这样，鼠鼠真的有机会卷得过别人嘛，鼠鼠不知道，鼠鼠只知道第二天要到了，鼠鼠要睡觉了，晚安~</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔·广州·开学后的第一个周末</title>
    <url>/2023/02/26/day1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1341328661&auto=1&height=66"></iframe>

<p>周末肯定是要粗去玩的啦，很可惜伙伴们都有点事情，不过这并不妨碍我独自一人出发，总之就是<strong>说走就走</strong></p>
<p><strong>出发！</strong></p>
<p>从广大的正门出发</p>


<p>带上我的老相机</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/26/day1/%E7%9B%B8%E6%9C%BA.jpg" class title="相机">

<p>路上遇到的狗狗</p>



<p>骑车ing~骑了有1h叭，最后还是决定回去中心湖那边</p>
<p>简单拍了几张美女</p>


<p>我爱美女(超大声)</p>
<p>还有幸福的小情侣，迟早有一天我会开泥头车创死你们…开玩笑哒，你们要一直幸福下去哦</p>



<p>哎，走的有点累了，emmm什么香味!原来是淀粉肠!</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/26/day1/%E9%A6%99%E8%82%A0.jpg" class title="香肠">

<p>好了吃完了就继续叭</p>
<p>好可爱的柯基!以后我一定要养一只，狗主人还允许我摸摸他，可惜光线不好，拍的很暗</p>




<p>走累了，躺下来休息一下吧，顺便看看帅哥，什么?帅哥竟是我自己!</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/26/day1/%E5%B8%85%E5%93%A51.jpg" class title="帅哥">
<img lazyload src="/images/loading.svg" data-src="/2023/02/26/day1/%E5%B8%85%E5%93%A52.jpg" class title="帅哥">
<img lazyload src="/images/loading.svg" data-src="/2023/02/26/day1/%E5%B8%85%E5%93%A53.jpg" class title="帅哥">
<img lazyload src="/images/loading.svg" data-src="/2023/02/26/day1/%E5%B8%85%E5%93%A54.jpg" class title="帅哥">

<!-- 哈哈哈哈哈有点小失望，没看到帅哥的脸，看看帅哥是如何自恋的叭 -->
<p>好了，休息结束，也该回去啦，手机要没电啦，事已至此，先吃点东西吧</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/26/day1/%E8%8D%89%E8%8E%93%E7%B3%96%E8%91%AB%E8%8A%A6.jpg" class title="糖葫芦">

<p>骑车回学校了，全都是上坡，累死了</p>
<p>到学校了，太阳也要下山啦</p>
<p>这是波光粼粼的水面</p>


<p>路边的野花</p>


<p>太阳落下啦，月亮就要升起来了</p>


<p>这周就用这种方式来结束吧，不开心的事就这样消散在路上吧，接下来会更好<del>!<br>各位晚安</del></p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常.广州</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔·广州·心心念念的&quot;太古仓&quot;之行</title>
    <url>/2023/03/05/day2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=421244551&auto=1&height=66"></iframe>

<p>每次听这首歌就好像到了夏天一样</p>
<p>又到了每周的休息日了，今天是和朋友们出去玩的一天!<br>这次选择了前年圣诞节就想去的”太古仓”，不过去年因为疫情和人太多的原因就一直耽搁到现在，出发!</p>
<p>因为一直在骑车，所以并没有拍照记录沿途的风景，只记得在路上，春风总能将盛开的桂花发出的香味送入我的鼻腔，天气很好，我和朋友们在路上说说笑笑地骑着车，探讨着以后的打算，谁也不会知道以后还会有这样悠闲的时光吗。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/05/day2/%E9%AA%91%E8%BD%A6.jpg" class title="骑车">
<p>头一次开了卡还需要我花钱的，整整跨了一个区欸，但我并没有很累的说</p>
<p>接下来就到了太古仓咯，emmm可能是我们来的晚了，太阳已经下山了，很可惜，不过太古仓好多美女啊!!!</p>
<p>还有一些小情侣或者一家人，大家都坐在台阶上，享受着江边的风吹拂脸庞，此刻是幸福的，即使在快节奏的生活中，也一定要保持着一颗慢节奏的心，即使生活当前并不如愿，即使不是我们想要的生活，我们还是应该去迎接生活叭</p>









<p>也许未来的某一天，我也会带着我的女朋友，坐在某个地方，和她讲述我过去的故事，她会是什么样的呢？她会靠在我的肩膀上听我讲故事，她会偶尔讶异于以前的我竟然是这个样子的，她会很高兴在没认识她之前有一群好朋友，因为他们，我才觉得生活不是那么无趣，她也会很想知道我以前的感情史叭，不过想知道也没用，她应该就是我的初恋叭。</p>
<p>然后就是我和我朋友们的照片了，我发现鼠鼠我真不上镜啊</p>








<img lazyload src="/images/loading.svg" data-src="/2023/03/05/day2/%E5%B8%85%E5%93%A53.jpg" class title="帅哥3">
<img lazyload src="/images/loading.svg" data-src="/2023/03/05/day2/%E5%B8%85%E5%93%A54.jpg" class title="帅哥4">
<img lazyload src="/images/loading.svg" data-src="/2023/03/05/day2/%E5%B8%85%E5%93%A55.jpg" class title="帅哥5">

<p>真的很喜欢日落，古时候人们总是”日出而作，日落而息”，但是现在呢，各种996，这并不是我喜欢的生活，我喜欢以前的生活，我有在想，以后老了，我就想回农村生活(应该在南方)</p>
<p>春天的时候，我就会活动活动身子骨，每天和邻居一起种地，并不是为了挣钱，只是为了满足体内种地的基因，因为我们都是农民的孩子，我还会再院子里种一棵树，这棵树应该在我刚搬来的时候就会种好叭</p>
<p>到了夏天，院子前的树已经长高了，我会在树下放上茶具，在阴凉的树荫下，慢慢地看书，伴随着气温的升高和蝉地叫声，我或许会睡去，一直到某个小孩子来吵醒我。到了晚上，我会看着孩子们去抓萤火虫，他们不会受到城市喧嚣地影响，他们永远都保持着一颗积极活泼的心，每次到了孩子们玩累了，吃完饭后，我会躺在摇椅上，轻轻摇晃着蒲扇，和他们说我和他们的奶奶认识的故事，说着说着总会有人睡着，我就把他们抱到床上，自己拿出以前的相册回忆年轻</p>
<p>秋天来了，农作物也成熟咯，我抄上家伙开始忙活收谷子，每次秋风一吹，满地金黄犹如浪潮一般，累了我就躺在谷子上，孩子们嬉戏打闹的声音总是令我心情愉悦，此刻我觉得我就是世界上最幸福的人</p>
<p>冬天是会下雪的，我会教孩子们堆雪人，和他们将如何打雪仗，有机会带他们去滑雪，他们一定很激动哈哈，我还会让他们感受到以前的年味，在鞭炮声中，我又老了一岁</p>
<p>这就是我梦想中的老年生活，我只想当个平凡人，可是平凡人又哪里是那么容易当的呢</p>


<p>最后就是和朋友们吃一顿了，由于不知道吃什么，就选择了相对便宜的<strong>麦当劳</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/05/day2/%E5%90%83.jpg" class title="吃">

<p>这周的故事就到这里结束吧，希望下周能收到几个面试通知叭，求求啦!</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常.广州</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU是如何执行程序的呢？CPU又是如何调度任务的呢？一些关于CPU的知识总结</title>
    <url>/2023/03/03/blog9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1974443814&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>欲速则不达，鼠鼠决定一星期写3篇文章就够了，其中一篇是拿来记录一下日常生活的，所以说只有两篇是拿来写一些几天内学习到的知识点，同时也可以更好地将学到的知识点串起来，所以就开始今天的主题叭，关于CPU的一些知识~</p>
<p>在去学习CPU前，我们先需要知道什么是<strong>冯诺依曼模型</strong></p>
<h2 id="冯诺依曼模型"><a href="#冯诺依曼模型" class="headerlink" title="冯诺依曼模型"></a>冯诺依曼模型</h2><p>在 1945 年冯诺依曼和其他计算机科学家们提出了计算机具体实现的报告，其遵循了图灵机的设计，而且还提出用电子元件构造计算机，并约定了用二进制进行计算和存储，还定义计算机基本结构为 5 个部分，分别是<code>中央处理器(CPU)</code>、<code>内存</code>、<code>输入设备</code>、<code>输出设备</code>、<code>总线</code></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC.jpg" class title="冯诺依曼">

<h3 id="中央处理器-CPU"><a href="#中央处理器-CPU" class="headerlink" title="中央处理器(CPU)"></a>中央处理器(CPU)</h3><p>中央处理器，也就是我们常说的CPU，是一台计算机的运算核心和控制核心。其功能主要是解释计算机指令以及处理计算机软件中的数据。CPU由运算器、控制器、寄存器、高速缓存及实现它们之间联系的数据、控制及状态的总线构成</p>
<h4 id="32位CPU和64位CPU的差别"><a href="#32位CPU和64位CPU的差别" class="headerlink" title="32位CPU和64位CPU的差别"></a>32位CPU和64位CPU的差别</h4><p>32位CPU和64位CPU最主要的差别在于CPU一次能计算的字节数是多少</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>CPU一次能计算的字节数是多少 </summary>
              <div class="content">
              <ol><li>32位CPU一次性能计算的字节数为4个字节</li><li>64位CPU一次性能计算的字节数位8个字节<br>(一个字节位8个比特，也就是8位)</li></ol>
              </div>
            </details>

<p>我们说的CPU的32位和64位，一般指的是CPU的<strong>位宽</strong></p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么要这样设计CPU呢 </summary>
              <div class="content">
              <p>之所以要这样设计CPU，是为了一次性能够计算更多的数据。</p><ol><li>假设有一个位宽为8的CPU(也就是8位的CPU)，那么这个CPU一次能处理的最大整数就是<code>(2^7+2^6+...+1)=255</code></li><li>此时我想要计算1000×500;由于CPU最多只能处理255以内的整数，所以此时就会分为好几次去计算1000×500;这样会很浪费CPU的时间，因为我们知道一个程序里不可能就一条指令，所以为了提高CPU的效率，科学家就将CPU分为32位和64位</li><li>32位的CPU可以计算的最大整数为<strong>4294967295</strong></li></ol>
              </div>
            </details>

<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>64位CPU相比于32位CPU的优势在哪里?64位CPU的性能一定比32位CPU的性能好嘛 </summary>
              <div class="content">
              <ol><li>上面我们知道64位的CPU能够比32位CPU多计算4个字节的数据，当我们计算超过32位的数据时，32位CPU就需要分步骤进行，而64位CPU不需要</li><li>64位CPU可以寻址更大的内存空间，32位CPU 大的寻址地址是<strong>4G</strong>，即使你加了<strong>8G</strong>大小的内存，也还是只能寻址到<strong>4G</strong>，而64位CPU最大寻址地址是<strong>2^64</strong>，远超于32位CPU最大寻址地址的<strong>2^32</strong></li><li>由于我们大部分程序不需要计算超过32位的数据，所以其实64位CPU的优势没办法体现出来，所以和32位CPU的性能差不太多</li></ol>
              </div>
            </details>
<h4 id="CPU内部的组件"><a href="#CPU内部的组件" class="headerlink" title="CPU内部的组件"></a>CPU内部的组件</h4><p>我们把CPU想象成一个工厂，那么一个核心(算术逻辑单元)就是一个车间，一个车间同一时间只能进行一个任务(进程)，只有执行完了当前任务(进程),车间才能去执行其他任务，因为CPU处理任务的速度很快，快到我们人类无法感知，所以就会出现一种错觉，<strong>同一时间在执行很多进程</strong>，这也就是所谓的<strong>并发</strong></p>
<p>我们知道，一个工厂里肯定不止一个车间的，所以说在现代的计算机里，大部分都是多核的，也就是说CPU可以在同一时间将不同的任务交给不同的核心进行处理，这就是<strong>并行</strong></p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg" class title="并发与并行">

<p>CPU由<strong>运算器</strong>、<strong>寄存器</strong>和<strong>控制器</strong>组成</p>
<h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><p>在刚刚的比喻中，我们知道一个核心就是一个车间，车间里很定需要工人，<strong>运算器</strong>在这个车间里面就扮演这个角色，当有数据给他并告诉他要执行什么运算的时候，就由<strong>运算器</strong>进行运算并将结果给其他人，<strong>运算器</strong>只负责运算</p>
<h5 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h5><p>那么总得有人把东西交给普通工人吧，并且把处理好的东西拿走，那么<strong>寄存器</strong>就实现了这个功能，<strong>寄存器</strong>就是负责传递信息(数据)或者搬运信息(数据)，主要作用是存储计算时的数据，需要时可以直接从<strong>寄存器</strong>中获取，<strong>寄存器也分很多种，不同的寄存器实现不同的功能</strong></p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>常见的寄存器种类 </summary>
              <div class="content">
              <ol><li>通用寄存器:用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</li><li>程序计数器:用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。</li><li>指令寄存器:用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。</li></ol>
              </div>
            </details>

<h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p>在一个工厂里，总得有人来控制整个工厂的运行，不能群龙无首啊，此时<strong>控制器</strong>就出现了，它的主要功能就是根据调度核心里的其他组件</p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>我们的程序和数据都是存储在内存，存储的区域是线性的。</p>
<p>数据存储的单位是一个二进制位（bit），即 0 或 1。最小的存储单位是字节（byte），1 字节等于 8 位。</p>
<p>内存的地址是从 0 开始编号的，然后自增排列，最后一个地址为内存总字节数 - 1，这种结构好似我们程序里的数组，所以内存的读写任何一个数据的速度都是一样的。</p>
<p>这里提一嘴，内存属于计算机中的<strong>存储设备</strong>，同样属于<strong>存储设备</strong>的还有我们熟知的<strong>硬盘</strong>，而<strong>硬盘</strong>又分为<strong>固态硬盘</strong>和<strong>机械硬盘</strong>，这里先不说这么多，先往后看叭</p>
<h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>总线是用于<strong>CPU</strong>和<strong>内存</strong>以及其他设备之间的通信</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>3种总线 </summary>
              <div class="content">
              <ol><li>地址总线，用于指定 CPU 将要操作的内存地址</li><li>数据总线，用于读写内存的数据</li><li>控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线</li></ol>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>当 CPU 要读写内存数据的时候，一般需要通过两个总线 </summary>
              <div class="content">
              <ol><li>首先要通过<strong>地址总线</strong>来指定内存的地址</li><li>再通过<strong>数据总线</strong>来传输数据；</li></ol>
              </div>
            </details>

<h3 id="输入、输出设备"><a href="#输入、输出设备" class="headerlink" title="输入、输出设备"></a>输入、输出设备</h3><p>输入设备(鼠标、键盘、摄像头等等)向计算机输入数据，计算机经过计算后，把数据输出给输出设备(屏幕)。期间，如果输入设备是键盘，按下按键时是需要和 CPU 进行交互的，这时就需要用到控制总线了。</p>
<h3 id="CPU位宽和线路位宽"><a href="#CPU位宽和线路位宽" class="headerlink" title="CPU位宽和线路位宽"></a>CPU位宽和线路位宽</h3><p>我们知道，64位CPU和32位CPU其实说的是CPU的位宽，但是我们在去了解CPU是如何执行一个程序前，我们得先知道，数据在计算机是如何传输的呢？</p>
<h4 id="线路位宽"><a href="#线路位宽" class="headerlink" title="线路位宽"></a>线路位宽</h4><ol>
<li><p>其实计算机无论怎么样都是由一堆硬件组装起来的，所以想要传递数据肯定只能依靠这些硬件，也就是依靠一些线路来传输的，学过数字信号处理的同学应该都知道利用高电平来表示1，低电平来表示0，通过不同的组合，可以表示成不同的二进制数叭，所以其实我们的数据在线路中也是这样传递的，通过操控电压，高电压代表<strong>1</strong>，低电压代表<strong>0</strong></p>
</li>
<li><p>我们想要传递<strong>数字5</strong>，转化为二进制也就是<strong>101</strong>，由于一条电线(一条线路)同一时间只能传递一个电流，来表示一种状态，所以<strong>101</strong>想要用一条线路来传递的话，我们就需要传递3次，当数字更大的时候，传递的次数也就更多了，这样显然是不高效的，所以我们需要增加线路来传输数据，就用<strong>101</strong>来说，如果又3条或者3条以上的线路的话，那么只需要一次就可以完成数据的传输。</p>
</li>
<li><p>上面那种只能一位一位来传输数据的情况，我们称为<strong>串行</strong>传输，下一个bit必须等待上一个bit传输完成才能进行传输。当然，想一次多传一些数据，增加线路即可，这时数据就可以<strong>并行</strong>传输。</p>
</li>
<li><p><strong>线路的位宽简单来讲就是用来传递数据的线路的数量</strong>，为了避免低效率的串行传输的方式，线路的位宽最好一次就能访问到所有的内存地址。</p>
</li>
<li><p>CPU想要操作一些地址空间就需要通过地址总线，如果只有一条的话，每次访问都只能操作2个地址空间(0或者1);如果CPU想要访问4G的地址空间的话，就需要32条地址总线，因为2^32&#x3D;4G，也就是说线路位宽为32</p>
</li>
</ol>
<h4 id="CPU位宽"><a href="#CPU位宽" class="headerlink" title="CPU位宽"></a>CPU位宽</h4><ol>
<li><p>CPU的位宽最好不要小于线路的位宽，比如<strong>32位CPU</strong>控制<strong>40位宽</strong>的地址总线和数据总线的话，工作起来就很麻烦，因为<strong>40位宽</strong>的总线能传输的最大数为<strong>2^40</strong>，远远大于<strong>32位CPU</strong>所能处理的最大整数<strong>2^32</strong>,这样CPU可能就需要分步骤来处理传输的数据，所以<strong>32位CPU</strong>最好和<strong>32位宽</strong>的线路搭配，因为<strong>32位CPU</strong>一次最多只能操作<strong>32位宽</strong>的地址总线和数据总线。</p>
</li>
<li><p>如果用<strong>32位CPU</strong>去加和两个<strong>64</strong>位大小的数字，就需要把这2个<strong>64位的数字</strong>分成2个<strong>低位32位数字</strong>和2个<strong>高位32位数字</strong>来计算，先加个两个低位的 32 位数字，算出进位，然后加和两个高位的 32 位数字，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。</p>
</li>
<li><p>对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，并且 64 位 CPU 内部的逻辑运算单元也支持 64 位数字的计算。</p>
</li>
<li><p>由于我们大部分程序不需要计算超过32位的数据，所以其实64位CPU的优势没办法体现出来，所以和32位CPU的性能差不太多</p>
</li>
<li><p>32 位 CPU 最大只能操作 4GB 内存，就算你装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 2^64</p>
</li>
</ol>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>你知道软件的 32 位和 64 位之间的区别吗？再来 32 位的操作系统可以运行在 64 位的电脑上吗？64 位的操作系统可以运行在 32 位的电脑上吗？如果不行，原因是什么？ </summary>
              <div class="content">
              <p>64位和32位软件，实际上代表指令是64位还是32位的:</p><ol><li>如果 32 位指令在 64 位机器上(64位CPU)执行，需要一套兼容机制，就可以做到兼容运行了。但是如果 64 位指令在 32 位机器(32位CPU)上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令</li><li>操作系统其实也是一种程序，我们也会看到操作系统会分成 32 位操作系统、64 位操作系统，其代表意义就是操作系统中程序的指令是多少位，比如 64 位操作系统，指令也就是 64 位，因此不能装在 32 位机器上</li></ol><p>总之，硬件的 64 位和 32 位指的是 CPU 的位宽，软件的 64 位和 32 位指的是指令的位宽。</p>
              </div>
            </details>

<p><strong>了解完这些，我们才算简单的了解了计算机的组成，接下来我们要知道CPU是如何执行一个程序的</strong></p>
<h2 id="程序执行的基本过程"><a href="#程序执行的基本过程" class="headerlink" title="程序执行的基本过程"></a>程序执行的基本过程</h2><p><strong>程序其实是一条又一条的指令</strong>，所以程序的执行其实就是把每一条指令一步一步地执行起来，而负责执行指令的就是CPU了</p>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>CPU执行程序的基本过程 </summary>
              <div class="content">
              <ol><li>CPU读取<strong>程序计数器</strong>的值，我们知道<strong>程序计数器</strong>的值为指令的内存地址</li><li>CPU通过<strong>控制单元</strong>操控<strong>地址总线</strong>去访问CPU从<strong>程序计数器</strong>读取到的值，然后通知内存设备准备好数据</li><li>内存设备准备好数据后通过<strong>数据总线</strong>将指令数据传到CPU中，期间CPU会通过<strong>Catch Line</strong>来保存数据(这部分后面会详细讲解)，这样等以后CPU还想访问该数据的时候就无需再去内存中获取了</li><li>CPU将传递来的指令数据保存在<strong>指令寄存器</strong>中</li><li>CPU分析<strong>指令寄存器</strong>的指令，确定其指令的类型和参数，如果是<strong>计算类</strong>的指令，就将指令交给<strong>逻辑运算单元</strong>处理;如果是<strong>存储类型</strong>的指令，就交给<strong>控制单元</strong>处理</li><li>CPU执行完指令后，<strong>程序计数器</strong>的值自动增加，表示指向下一条指令</li></ol><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>自增的大小 </summary>              <div class="content">              <p><strong>程序计数器</strong>自增的大小是由CPU的位宽决定的，例如<strong>32为CPU</strong>，指令是4个字节，需要4个内存地址存放，因此<strong>程序计数器</strong>的值会自增<strong>4</strong></p>              </div>            </details> <details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>简单总结 </summary>              <div class="content">              <p>一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令</p><p>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <strong>CPU 的指令周期</strong></p>              </div>            </details> 
              </div>
            </details>

<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>举个栗子(a=1+2) </summary>
              <div class="content">
              <p>我们知道一个程序想要运行，需要经过4个过程:预处理——&gt;编译——&gt;汇编——&gt;链接</p><p>CPU 是不认识<strong>a &#x3D; 1 + 2</strong>这个字符串，这些字符串只是方便我们程序员认识，要想这段程序能跑起来，还需要把整个程序翻译成<strong>汇编语言</strong>的程序，这个过程称为编译成汇编代码。</p><p>针对汇编代码，我们还需要用汇编器翻译成机器码，这些机器码由 0 和 1 组成的机器语言，这一条条机器码，就是一条条的<strong>计算机指令</strong>，这个才是 CPU 能够真正认识的东西。</p><p>那么看看在32位CPU的环境下，(a&#x3D;1+2)是如何执行的叭</p><ol><li><p>在程序<strong>编译</strong>这个过程中，编译器发现<strong>1</strong>和<strong>2</strong>是数据，那么当程序运行的时候，在内存中专门有一块区域来存放这些数据(根据数据的类型来分配，有数据段(.data)、BSS段(.bss)、代码段、栈区、堆区)，如下图所示</p><ol><li>数据1被存放在了地址为0x104的位置</li><li>数据2被存放在了地址为0x100的位置<br><strong>注意，数据和指令是分开区域存放的，存放指令区域的地方称为「正文段」</strong><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%8C%BA%E5%9F%9F.jpg" class title="区域"></li></ol></li><li><p>编译器会把(a&#x3D;1+2)编译成4条指令，存放到正文段中，如上图所示</p><ol><li>0x200 的内容是 load 指令将 0x100 地址中的数据 1 装入到寄存器 R0；</li><li>0x204 的内容是 load 指令将 0x104 地址中的数据 2 装入到寄存器 R1；</li><li>0x208 的内容是 add 指令将寄存器 R0 和 R1 的数据相加，并把结果存放到寄存器 R2；</li><li>0x20c 的内容是 store 指令将寄存器 R2 中的数据存回数据段中的 0x108 地址中，这个地址也就是变量 a 内存中的地址；</li></ol></li><li><p>编译完成后，具体执行程序的时候，程序计数器会被设置为 0x200 地址，然后依次执行这 4 条指令</p></li><li><p>由于是32位CPU，所以一条指令的大小为4个字节，所以每条指令间间隔4个字节，而数据的大小是根据你在程序中指定的变量类型，比如<strong>int</strong>类型的数据则占<strong>4</strong>个字节，<strong>char</strong>类型的数据则占<strong>1</strong>个字节。</p></li></ol>
              </div>
            </details>

<p><strong>以上就是CPU执行程序的过程，关于CPU的秘密还不止这一点，我们有没有想过，既然有了内存，为什么还需要寄存器来保存数据呢?硬盘和内存什么关系？CPU里面除了寄存器外还有没有可以存储数据的东西呢？如果有的话是如何实现的呢？实现的话又会带来什么问题呢？</strong></p>
<p>别急，让我先急!</p>
<p>接下来慢慢看叭</p>
<h2 id="计算机中的存储设备"><a href="#计算机中的存储设备" class="headerlink" title="计算机中的存储设备"></a>计算机中的存储设备</h2><p>鼠鼠毕业后找到工作了肯定要自己组装一台电脑的，那么鼠鼠除了CPU和显卡需要购买，还有显示屏等等，最重要的是，还需要买一些存储设备，不然怎么下载游戏?因为存储设备比较多，有内存和硬盘，硬盘又分为<strong>固态硬盘</strong>和<strong>机械硬盘</strong><br>当断电后，内存条中的数据是会丢失的，而硬盘中的数据并不会丢失，因为硬盘是持久化存储设备，同时也是一个 I&#x2F;O 设备。后面我会写一篇文章就是关于数据是如何读写到硬盘上的，先写完今天再说</p>
<p>但其实 CPU 内部也有存储数据的组件，这个应该比较少人注意到，比如寄存器、**CPU L1&#x2F;L2&#x2F;L3 Cache **也都是属于存储设备，只不过它们能存储的数据非常小，但是它们因为靠近 CPU 核心，所以访问速度都非常快，快过硬盘好几个数量级别。</p>
<h2 id="为何有了内存还需要寄存器"><a href="#为何有了内存还需要寄存器" class="headerlink" title="为何有了内存还需要寄存器?"></a>为何有了内存还需要寄存器?</h2><p>我们知道，CPU是需要从内存从读取数据才能进行处理的，而寄存器也可以存储数据，只是存储空间比较小，但是由于CPU与内存的距离较远，读取速度相对于就在CPU内部的寄存器而言慢了很多，况且寄存器离<strong>控制单元</strong>和<strong>逻辑运算单元</strong>都很近，所以计算速度会快很多。</p>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p>在所有的存储器中，我们按照CPU读取速度的快慢，将所有存储器分成以下级别:</p>
<ol>
<li>速度最快的就是<strong>寄存器</strong>，但是能处理的数据量是最少的</li>
<li>CPU Cache也是在CPU内部结构里的，所以它们的速度也很快，就比寄存器慢一点，但是存储的数据也更多了</li>
<li>内存，前面两个都属于CPU内部的存储器，在CPU外部，速度最快的就是内存了</li>
<li>固态硬盘和机械硬盘是最慢的，相对而言，固态硬盘又比机械硬盘快了一个档次</li>
</ol>
<p><strong>对于存储器而言，它的处理速度越快，耗能也就越多，而且制造材料就更贵，成本就更高，以至于速度快的存储器的存储空间都比较小</strong><br>CPU 里的寄存器和 Cache，是整个计算机存储器中价格最贵的，虽然存储空间很小，但是读写速度是极快的，而相对比较便宜的内存和硬盘，速度肯定比不上 CPU 内部的存储器，但是能弥补存储空间的不足。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%AD%98%E5%82%A8%E5%99%A8.jpg" class title="存储器">

<h3 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h3><p>最靠近<strong>控制单元</strong>和<strong>逻辑运算单元</strong>的存储器就是<strong>寄存器</strong>了，它使用的制造材料也很贵但也是最快的，又因为它是在CPU里的，所以它的存储量也很小，并且数量也不是很多</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>寄存器的数量 </summary>
              <div class="content">
              <p>寄存器的数量一般在几十到几百之间，每个寄存器存储一定字节的数据<br>例如:<br>    1. 32位CPU的存储器一般存储4字节的数据<br>    2. 64位CPU的存储器一般存储8字节的数据</p><p>寄存器的访问速度非常快，一般要求在半个 CPU 时钟周期内完成读写，CPU 时钟周期跟 CPU 主频息息相关，比如 2 GHz 主频的 CPU，那么它的时钟周期就是 1&#x2F;2G，也就是 0.5ns（纳秒）。</p><p>CPU 处理一条指令的时候，除了读写寄存器，还需要解码指令、控制指令执行和计算。如果寄存器的速度太慢，则会拉长指令的处理周期，从而给用户的感觉，就是电脑「很慢」。</p>
              </div>
            </details>

<h3 id="CPU-Cache"><a href="#CPU-Cache" class="headerlink" title="CPU Cache"></a>CPU Cache</h3><p>CPU Cache 用的是一种叫 SRAM（Static Random-Access Memory，静态随机存储器） 的芯片。</p>
<p>SRAM 之所以叫「静态」存储器，是因为只要有电，数据就可以保持存在，而一旦断电，数据就会丢失了。</p>
<p>在<strong>SRAM</strong>里面，一个比特的数据，通常需要<strong>6</strong>个晶体管，所以 SRAM 的存储密度不高，同样的物理空间下，能存储的数据是有限的，不过也因为 SRAM 的电路简单，所以访问速度非常快。</p>

<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>为什么要有CPU Cache? </summary>
              <div class="content">
              <p>根据摩尔定律，CPU 的访问速度每 18 个月就会翻倍，相当于每年增长 60% 左右，内存的速度当然也会不断增长，但是增长的速度远小于 CPU，平均每年只增长 7% 左右。于是，CPU 与内存的访问性能的差距不断拉大</p><p>到现在，一次内存访问所需时间是200<del>300多个时钟周期，这意味着 CPU 和内存的访问速度已经相差200</del>300 多倍了</p><p>为了弥补 CPU 与内存两者之间的性能差异，就在 CPU 内部引入了CPU Cache，也称高速缓存</p>
              </div>
            </details>

<p>CPU 的高速缓存(CPU Cache)，通常可以分为 L1、L2、L3 这样的三层高速缓存，也称为一级缓存、二次缓存、三次缓存</p>
<h4 id="L1-Cache"><a href="#L1-Cache" class="headerlink" title="L1 Cache"></a>L1 Cache</h4><p>一级缓存的访问速度几乎和寄存器一样快，通常只需要 2~4 个时钟周期，而大小在几十 KB 到几百 KB 不等。<br><strong>每个CPU核心都有一块属于自己的L1 Cache</strong>，并且L1 Cache通常分为<strong>数据缓存</strong>和<strong>指令缓存</strong><br>可以在Linux下通过以下命令查看L1 Cache的数据缓存和指令缓存的容量大小</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index0/size    //查看数据缓存</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index1/size    //查看指令缓存</span></span><br></pre></td></tr></table></figure></div>

<h4 id="L2-Cache"><a href="#L2-Cache" class="headerlink" title="L2 Cache"></a>L2 Cache</h4><p>二级缓存的速度就比一级缓存慢，因为它距离CPU核心更远，但同时，它的大小也比一级缓存大<br><strong>同样的，二级缓存也是每个CPU都有的</strong><br>可以在Linux下通过以下命令查看L2 Cache的容量大小</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index2/size</span></span><br></pre></td></tr></table></figure></div>
<h4 id="L3-Cache"><a href="#L3-Cache" class="headerlink" title="L3 Cache"></a>L3 Cache</h4><p>L3 Cache与CPU核心又比L2 Cache更远，所以访问速度也比二级缓存更慢，但大小也更大<br><strong>L2 Cache是所有CPU核心共享的，但每个CPU里面也只有一块</strong><br>可以在Linux下通过以下命令查看L3 Cache的容量大小</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index3/size</span> </span><br></pre></td></tr></table></figure></div>

<h3 id="内存-1"><a href="#内存-1" class="headerlink" title="内存"></a>内存</h3><p>内存用的芯片和 CPU Cache 有所不同，它使用的是一种叫作 DRAM （Dynamic Random Access Memory，动态随机存取存储器） 的芯片。</p>
<p>相比 SRAM，DRAM 的密度更高，功耗更低，有更大的容量，而且造价比 SRAM 芯片便宜很多。</p>
<p>DRAM 存储一个比特数据，只需要一个晶体管和一个电容就能存储，但是因为数据会被存储在电容里，电容会不断漏电，所以需要「定时刷新」电容，才能保证数据不会被丢失，这就是 DRAM 之所以被称为「动态」存储器的原因，只有不断刷新，数据才能被存储起来。</p>
<p>DRAM的数据访问电路和刷新电路比SRAM更复杂，所以内存的访问速度也更慢，但是大小也会大得多</p>
<h3 id="硬盘"><a href="#硬盘" class="headerlink" title="硬盘"></a>硬盘</h3><p>硬盘又分为固态硬盘(SSD)和机械硬盘(HDD)</p>
<h4 id="固态硬盘-SSD"><a href="#固态硬盘-SSD" class="headerlink" title="固态硬盘(SSD)"></a>固态硬盘(SSD)</h4><p>结构和内存类似，但是硬盘的优点就在于在断电后，数据依旧保存在硬盘上的，意思就是说硬盘上的数据如果不是刻意去破坏，那么就是永久的。内存的读写速度大概是SSD的<strong>10-1000</strong>倍</p>
<h4 id="机械硬盘-HDD"><a href="#机械硬盘-HDD" class="headerlink" title="机械硬盘(HDD)"></a>机械硬盘(HDD)</h4><p>机械硬盘是比较传统的硬盘，它是通过物理读写的方式来访问数据的，因此它的访问速度特别慢，内存的读写速度大概是它的<strong>10w</strong>倍</p>
<p>随着时间的发展，由于固态硬盘的价格越来越便宜，导致机械硬盘几乎没什么人会用了，因此HDD正在被SSD取代</p>
<h2 id="存储器的存储关系"><a href="#存储器的存储关系" class="headerlink" title="存储器的存储关系"></a>存储器的存储关系</h2><p>现代的一台计算机，都用上了 CPU Cahce、内存、到 SSD 或 HDD 硬盘这些存储器设备了。</p>
<p>其中，存储空间越大的存储器设备，其访问速度越慢，所需成本也相对越少。</p>
<p>CPU 并不会直接和每一种存储器设备直接打交道，而是每一种存储器设备只和它相邻的存储器设备打交道。</p>
<p>比如，CPU Cache 的数据是从内存加载过来的，写回数据的时候也只写回到内存，CPU Cache 不会直接把数据写到硬盘，也不会直接从硬盘加载数据，而是先加载到内存，再从内存加载到 CPU Cache 中。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/1.jpg" class width="1">
<p>所以，每个存储器只和相邻的一层存储器设备打交道，并且存储设备为了追求更快的速度，所需的材料成本必然也是更高，也正因为成本太高，所以 CPU 内部的寄存器、L1\L2\L3 Cache 只好用较小的容量，相反内存、硬盘则可用更大的容量，这就我们今天所说的存储器层次结构。</p>
<p>另外，当 CPU 需要访问内存中某个数据的时候，如果寄存器有这个数据，CPU 就直接从寄存器取数据即可，如果寄存器没有这个数据，CPU 就会查询 L1 高速缓存，如果 L1 没有，则查询 L2 高速缓存，L2 还是没有的话就查询 L3 高速缓存，L3 依然没有的话，才去内存中取数据。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/2.jpg" class width="2">

<p>我们从上面的知识中可以知道，CPU执行程序的时候是需要去从内存中获取数据的，假设CPU里面没有存储器，那么既不是每次获取数据都需要从内存中获取吗，准确的来说，即使是之前已经获取过的数据，想要再次获取就要重新去内存里面查找，这杨效率也太低了吧，所以就有了<strong>寄存器</strong>这个存储器，但是<strong>寄存器</strong>能存储的数据量实在是太小了，所以就有了CPU Cache的出现。</p>
<p>那么，CPU Cache是如何将内存中的数据保存下来的呢?</p>
<h2 id="CPU-Cache-1"><a href="#CPU-Cache-1" class="headerlink" title="CPU Cache"></a>CPU Cache</h2><h3 id="CPU-Cache的读取过程"><a href="#CPU-Cache的读取过程" class="headerlink" title="CPU Cache的读取过程"></a>CPU Cache的读取过程</h3><p>CPU Cache的数据是从<strong>内存</strong>中读取过来的，它是以<strong>一小块一小块</strong>读取数据的，而不是按单个数据读取的，所以在CPU Cache中，这样一小块一小块的数据被称为<strong>Cache Line(缓存块)</strong><br>在Linux下查看Cache Line的大小</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size     //查看L1 Cache一次性能载入的数据的大小，index1就是一次性能载入的指令的大小，index2就是L2 Cache，index3就是L3 Cache</span></span><br></pre></td></tr></table></figure></div>
<p>我们假设在Linux下输入上面的命令得出的结果为<strong>64</strong>，意思就是说L1 Cache一次性能从内存中读取64字节的数据到L1 Cache中的数据缓存，什么意思呢？</p>
<p>假设我们内存中有一个数组<strong>int array[100]</strong>,当我们CPU根据程序指数器的内容去访问array[0]的时候，由于是<strong>int</strong>类型的数组，一个元素占<strong>4个字节</strong>，而我们的CPU Cache一次性能载入的最大数据量为64字节，那么此时就会继续往后遍历到array[15]，那么此时就刚好是64字节，那么**array[0]<del>array[15]<strong>都会被缓存到CPU Cache中，这样等以后CPU还想要获取</strong>array[0]</del>array[15]**中的数据时，就无需再去访问内存，直接访问CPU Cache就可以了，这也是CPU Cache的好处</p>
<p>事实上，CPU 读取数据的时候，无论数据是否存放到 Cache 中，CPU 都是先访问 Cache，只有当 Cache 中找不到数据时，才会去访问内存，并把内存中的数据读入到 Cache 中，CPU 再从 CPU Cache 读取数据</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/3.jpg" class width="3">
<p>这样的访问机制，跟我们使用「内存作为硬盘的缓存」的逻辑是一样的，如果内存有缓存的数据，则直接返回，否则要访问龟速一般的硬盘。</p>
<p><strong>那 CPU 怎么知道要访问的内存数据，是否在 Cache 里？如果在的话，如何找到 Cache 对应的数据呢？</strong>我们从最简单、基础的**直接映射 Cache(Direct Mapped Cache)**说起，来看看整个 CPU Cache 的数据结构和访问逻辑。</p>
<h3 id="CPU-Cache的数据结构和访问逻辑"><a href="#CPU-Cache的数据结构和访问逻辑" class="headerlink" title="CPU Cache的数据结构和访问逻辑"></a>CPU Cache的数据结构和访问逻辑</h3><p>我们前面提到了，CPU Cache去内存读取数据时，是<strong>一块一块</strong>地读取的，而读取的大小我们可以通过一些命令获取。<br>那么在内存中，这样一块的数据我们成为<strong>内存块</strong>，读取的时候，我们需要知道的是数据所在的内存块的地址。</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>直接映射 Cache </summary>
              <div class="content">
              <p>所谓<strong>直接映射Cache策略</strong>，就是将内存块始终映射到CPU Cache的某一块Cache Line，映射的方法则采用<strong>取模运算</strong><br>当然了，这样做很容易出现类似<strong>哈希冲突</strong>一样的问题，就是多个<strong>内存块</strong>映射到同一块<strong>Cache Line</strong></p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>解决“哈希冲突” </summary>
              <div class="content">
              <p>为了区别不同的<strong>内存块</strong>，我们在对应的<strong>Cache Line</strong>中加入<strong>组标记(Tag)</strong>,这个组标记会记录当前 CPU Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块<br>除此之外，Cache Line还有两个信息</p><ol><li>从内存加载过来的实际存放数量</li><li><strong>有效位</strong>，这个组标记会记录当前 CPU Line 中存储的数据对应的内存块，我们可以用这个组标记来区分不同的内存块</li></ol>
              </div>
            </details>

<p>我们知道，我们CPU有时候需要读取的并不是一整个<strong>内存块</strong>，就那上面的数组例子来说，CPU想要获取array[2]的值，<strong>CPU Cache</strong>为了尽可能地将多的数据保存，所以就将<strong>array[0]~array[15]<strong>的数据全部保存在</strong>Cache Line</strong>中，但是CPU只需要<strong>array[2]<strong>的数据，所以我们就需要一个</strong>偏移量</strong>来帮助CPU定位到需要的数据</p>
<p>我们通常称<strong>CPU Cache上的一个数据片段</strong>为<strong>字</strong>，而在CPU Cache上找到CPU所需要的<strong>字</strong>，就需要<strong>偏移量(offset)</strong></p>
<p>因此，一个内存的访问地址，包括<strong>组标记、CPU Line 索引、偏移量</strong>这三种信息，于是 CPU 就能通过这些信息，在 CPU Cache 中找到缓存的数据。而对于 CPU Cache 里的数据结构，则是由<strong>索引 + 有效位 + 组标记 + 数据块</strong>组成。</p>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>如果内存中的数据已经在 CPU Cahe 中了，那 CPU 访问一个内存地址的时候，会经历这 4 个步骤： </summary>
              <div class="content">
              <ol><li>根据内存地址中索引信息，计算在 CPU Cahe 中的索引，也就是找出对应的 CPU Line 的地址</li><li>找到对应 CPU Line 后，判断 CPU Line 中的有效位，确认 CPU Line 中数据是否是有效的，如果是无效的，CPU 就会直接访问内存，并重新加载数据，如果数据有效，则往下执行</li><li>对比内存地址中组标记和 CPU Line 中的组标记，确认 CPU Line 中的数据是我们要访问的内存数据，如果不是的话，CPU 就会直接访问内存，并重新加载数据，如果是的话，则往下执行</li><li>根据内存地址中偏移量信息，从 CPU Line 的数据块中，读取对应的字。</li></ol>
              </div>
            </details>

<p><code>以上我们说的都是CPU访问内存的数据，但我们一直没说CPU是如何将数据写回到内存中的，现在我们就来说一下</code></p>
<h3 id="CPU写数据操作"><a href="#CPU写数据操作" class="headerlink" title="CPU写数据操作"></a>CPU写数据操作</h3><p>我们知道CPU内部有着CPU Cache，因为离 CPU 核心相当近，它的访问速度是很快的，于是它充当了 CPU 与内存之间的缓存角色。</p>
<p>如果CPU再修改完数据的时候收到指令需要把修改完的数据返回，那么此时CPU就需要把数据先写回<strong>CPU Cache</strong>中，那次是<strong>CPU Cache</strong>中的数据就和<strong>内存</strong>中的数据不一致了，那么我们要如何保持<strong>缓存的一致性</strong>呢？</p>
<p>有两种方法:<strong>写直达</strong>和<strong>写回</strong></p>
<h4 id="写直达"><a href="#写直达" class="headerlink" title="写直达"></a>写直达</h4><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%86%99%E7%9B%B4%E8%BE%BE.jpg" class title="写直达">
<ol>
<li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；</li>
<li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</li>
</ol>
<p>顾名思义，<strong>写直达</strong>就是每次都将数据写回<strong>CPU Cache</strong>中和<strong>内存</strong>中，但这样的效率太低了，因为不是每次修改完数据用户都需要读取的，那此时写回内存将没有任何意义。</p>
<h4 id="写回"><a href="#写回" class="headerlink" title="写回"></a>写回</h4><p>为了提高效率，有发明了另外一种方法。<br>在写回机制中，<strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong>，减少了数据写回内存的频率，这样便可以提高系统的性能。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E5%86%99%E5%9B%9E.jpg" class title="写回">

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>写回的流程 </summary>
              <div class="content">
              <ol><li>当CPU发生<strong>写操作</strong>的时候，先检查<strong>CPU Cache</strong>中对应的<strong>Cache Line</strong>中是否有数据，有的话就将数据更改为<strong>修改后的数据</strong>，并且标记为<strong>脏</strong>，因为此时<strong>Cache Line</strong>中的数据和对应的内存中的数据是不一样的</li><li>当CPU发生<strong>写操作</strong>的时候，发现<strong>修改完的数据</strong>的对应的<strong>Cache Line</strong>中的保存的是<strong>别的内存地址的数据</strong>时<ol><li>如果该数据不是脏的，直接将修改后的数据进行覆盖，并且标记为<strong>脏</strong></li><li>如果该数据是脏的，那么就先将该<strong>Cache Line</strong>上的数据<strong>写回到对应地址的内存上</strong>，然后将<strong>修改后的数据放入Cache Line中</strong>，并且标记为<strong>脏</strong></li></ol></li></ol>
              </div>
            </details>
<p>可以发现<strong>写回</strong>这个方法，在把数据写入到 Cache 的时候，只有在<strong>缓存不命中</strong>，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。</p>
<p>这样的好处是，如果我们大量的操作都能够命中缓存，那么大部分时间里 CPU 都不需要读写内存，自然性能相比写直达会高很多。</p>
<h3 id="缓存一致性问题"><a href="#缓存一致性问题" class="headerlink" title="缓存一致性问题"></a>缓存一致性问题</h3><p>从上面的知识中，我们学到了很多关于CPU Cache的知识，但我们都是在单个CPU核心的情况下考虑问题的，这显然是不够的，因为现在的计算机都是多核的了，那么此时我们就要考虑，如何保证缓存的一致性</p>
<h4 id="什么是缓存一致性"><a href="#什么是缓存一致性" class="headerlink" title="什么是缓存一致性?"></a>什么是缓存一致性?</h4><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>举个栗子 </summary>
              <div class="content">
              <p>我们知道，每个CPU核心都有自己的L1 Cache和L2 Cache，但是L3 Cache是共享的。<br>假设此时有两个CPU核心，分别为CPU1和CPU2，此时它们俩分别运行两个线程，但是都是拿来操作共享资源i的。<br>此时(假设i&#x3D;0):</p><ol><li>CPU1读取i的值，并对i进行+1操作，我们知道CPU是采用<strong>写回</strong>机制的，所以此时CPU1的CPU Cache上i的值变为1，并且被标记为<strong>脏</strong></li><li>CPU2开始读取i的值，按道理来说，CPU2读取到的i值应该是1，但是由于<strong>写回</strong>的机制，CPU1并没有将修改完的i值写入内存中，这也就导致CPU2读取的i值还是0，这也就发生了错误</li></ol>
              </div>
            </details>
<p>这个就是所谓的缓存一致性问题，<strong>1号核心</strong>和<strong>2号核心</strong>的缓存，在这个时候是不一致，从而会导致执行结果的错误。</p>
<h3 id="如何避免缓存一致性问题"><a href="#如何避免缓存一致性问题" class="headerlink" title="如何避免缓存一致性问题"></a>如何避免缓存一致性问题</h3><p>要解决这一问题，就需要一种机制，来同步两个不同核心里面的缓存数据。要实现的这个机制的话，要保证做到下面这2点:</p>
<ol>
<li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为<strong>写传播(Wreite Propagation)</strong></li>
<li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为<strong>事务的串形化(Transaction Serialization)</strong><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>写传播 </summary>
              <div class="content">
              <p><strong>写传播</strong>就是当某个CPU核心更新了CPU Cache中的数据，就要把该事件<strong>广播</strong>给所有CPU核心，其中最常见的方法就是<strong>总线嗅探(Bus Snooping)</strong></p><p>以前面i的例子来说:<br>当CPU1对i进行了+1操作后，修改了L1 Cache的数据，会通过总线把这个时间广播给其他CPU,然后每个CPU都会<strong>监听</strong>总线上的广播事件，然后检查自己L1 Cache上是否有该数据，如果有的话也将数据更新到自己的L1 Cache</p>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>事务的串行化 </summary>
              <div class="content">
              <p>还是举个栗子叭:</p><ol><li>假设我们有4个CPU核心，然后有一个数据为i</li><li>CPU1将数据i修改成100</li><li>CPU2将数据i修改成200</li><li>这两个操作都会通过<strong>写传播</strong>，用总线将数据更新的事件传递给其他CPU，在这里就是CPU3和CPU4</li><li>假设CPU3先收到了i修改成100的事件，然后再收到将i修改成200的事件，最后再CPU3的L1 Cache中，i的值为200</li><li>假设CPU4先收到了i修改成200的事件，然后再收到将i修改成100的事件，最后再CPU4的L1 Cache中，i的值为100</li></ol><p>显然，这里就又出现错误了，虽然我们通过<strong>写传播</strong>，将数据更新这个事件传输了，但由于其他CPU执行的顺序不同，也会出现数据不一致的情况，所以我们必须保证CPU3和CPU4都能看到<strong>相同顺序的数据变化</strong>，这就是<strong>数据的串行化</strong></p><p>要实现<strong>数据的串行化</strong>，必须满足以下两点:</p><ol><li>CPU 核心对于 Cache 中数据的操作，需要同步给其他 CPU 核心；</li><li>要引入「锁」的概念，如果两个 CPU 核心里有相同数据的 Cache，那么对于这个 Cache 数据的更新，只有拿到了「锁」，才能进行对应的数据更新。</li></ol>
              </div>
            </details></li>
</ol>
<p>上面我们知道可以用<strong>总线嗅探</strong>来实现<strong>写传播</strong>，但是没有办法实现<strong>数据串行化</strong>，再加上虽然<strong>总线嗅探</strong>方法很简单，但是CPU 需要每时每刻监听总线上的一切活动，但是不管别的核心的 Cache 是否缓存相同的数据，都需要发出一个广播事件，这无疑会加重总线的负载。</p>
<p>那么我们有没有什么方法，既可以减轻总线的负载来满足<strong>写传播</strong>，又能实现<strong>数据的串行化</strong>呢?</p>
<p>当然是有的啦，这是一个协议，基于总线嗅探机制实现了事务串形化，也用状态机机制降低了总线带宽压力，这个协议就是 MESI 协议，这个协议就做到了 CPU 缓存一致性</p>
<h4 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h4><p>MESI协议其实是4个状态的英文首字母组合起来的:</p>
<ol>
<li>Modified 已修改</li>
<li>Exclusive 独占</li>
<li>Shared 共享</li>
<li>Invalidated 已失效<br>我们可以用这四个状态来标记 Cache Line 四个不同的状态</li>
</ol>
<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>已修改 </summary>
              <div class="content">
              <p><strong>已修改</strong>状态就是我们前面提到的脏标记，代表该 Cache Line 上的数据已经被更新过，但是还没有写到内存里。而<strong>已失效</strong>状态，表示的是这个 Cache Line 里的数据已经失效了，不可以读取该状态的数据。</p>
              </div>
            </details>

<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>独占 </summary>
              <div class="content">
              <p><strong>独占</strong>状态代表 Cache Line 里的数据是干净的，也就是说，这个时候 Cache Line 里的数据和内存里面的数据是一致性的,同时也代表着只有一个CPU核心拥有该数据，这个时候无论如何修改这个数据，都不需要向其他CPU核心广播，这样就解决了<strong>总线嗅探</strong>导致的总线负载过大的问题</p><p>同样的，如果一个CPU核心处于<strong>独占</strong>状态的时候，有另外一个CPU核心读取了相同的数据，那么此时这两个CPU核心都会从<strong>独占</strong>变成<strong>共享</strong></p>
              </div>
            </details>

<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>共享 </summary>
              <div class="content">
              <p><strong>共享</strong>状态代表 Cache Line 里的数据是干净的，也就是说，这个时候 Cache Line 里的数据和内存里面的数据是一致性的，也代表着不止一个CPU核心拥有这个数据。</p><p>当其中一个CPU核心想要修改<strong>共享</strong>的数据的时候，需要先向其他CPU核心广播消息，让其他CPU核心将<strong>共享</strong>的数据修改成<strong>已失效</strong>状态，然后该CPU核心才能对这个数据进行修改，修改完也要把状态变成<strong>已修改</strong></p>
              </div>
            </details>

<details class="yellow" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>已失效 </summary>
              <div class="content">
              <p>代表该Cache Line中的数据已经失效了，不可以读取该状态的数据</p>
              </div>
            </details>

<p>还是举个栗子:</p>
<ol>
<li>CPU1读取内存中的A数据，那么此时A数据就被读取到CPU1的Cache Line中，由于CPU1的Cache Line并没有缓存该数据，所以此时将CPU1的Cache Line标记为<strong>独占</strong></li>
<li>CPU2也读取内存中的A数据，由于CPU1的Cache Line缓存了该数据，但是CPU2的Cache Line并没有缓存A数据，于是CPU2就将A数据缓存到自己的Cache Line中，并且CPU1和CPU2的Cache Line的状态都修改成<strong>共享</strong></li>
<li>此时CPU1想要修改A数据，那么就需要先将<strong>想要修改A数据</strong>的信息传递给其他CPU核心，CPU2接收到该信息，检查自己的Cache Line，发现自己的Cache Line有A数据，于是将自身的Cache Line中的A数据标志为<strong>已失效</strong>状态，然后CPU1就开始修改A数据，修改结束后，将Cache Line的状态修改成<strong>已修改</strong></li>
<li>如果CPU1<strong>继续</strong>修改Cache Line中A数据的值，由于此时的 Cache Line 是<strong>已修改</strong>状态，因此不需要给其他 CPU 核心发送消息，直接更新数据即可。</li>
<li>如果此时CPU3想要读取A数据，那么此时CPU1会先将<strong>已修改</strong>的A数据，写回到内存中，然后CPU3将更新完的A数据缓存到自己的Cache Line中，并且CPU1和CPU3的Cache Line状态都修改成<strong>共享</strong></li>
</ol>
<p>所以，可以发现当 Cache Line 状态是<strong>已修改</strong>或者<strong>独占</strong>状态时，修改更新其数据不需要发送广播给其他 CPU 核心，这在一定程度上减少了总线带宽压力</p>
<p>事实上，整个 MESI 的状态可以用一个有限状态机来表示它的状态流转。还有一点，对于不同状态触发的事件操作，可能是来自本地 CPU 核心发出的广播事件，也可以是来自其他 CPU 核心通过总线发出的广播事件。下图即是 MESI 协议的状态图：</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/MESI.jpg" class title="MESI">

<p>MESI 协议的四种状态之间的流转过程，如下表格，可以更详细的看到每个状态转换的原因：</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/MESI1.jpg" class title="MESI">

<p><code>同样的，当多个CPU核心读取同一块内存块的时候，还是会出现一个问题</code><br>那就是<strong>伪共享</strong>问题</p>
<h3 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h3><p>什么是<strong>伪共享</strong>问题?<br>让我们看看下面这个场景:</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>伪共享场景 </summary>
              <div class="content">
              <p>现在假设有一个双核心的 CPU，这两个 CPU 核心并行运行着两个不同的线程，它们同时从内存中读取两个不同的数据，分别是类型为 long 的变量 A 和 B，这个两个数据的地址在物理内存上是连续的，如果 Cahce Line 的大小是 64 字节，并且变量 A 在 Cahce Line 的开头位置，那么这两个数据是位于同一个 Cache Line 中，又因为 CPU Line 是 CPU 从内存读取数据到 Cache 的单位，所以这两个数据会被同时读入到了两个 CPU 核心中各自 Cache 中。<br><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E4%BC%AA%E5%85%B1%E4%BA%AB.jpg" class title="伪共享"></p><p>然后我们根据上面说的MESI协议来分析一下什么是伪共享:</p><p>假设 CPU1绑定了线程 A，CPU2绑定了线程 B，线程 A 只会读写变量 A，线程 B 只会读写变量 B。</p><ol><li>当我们的CPU核心1想要读取数据A，那么此时因为Cache Line最大能读取64个字节的数据，而一个A数据为long类型，也就是8个字节，所以Cache Line会继续往后读取，也就是说会把数据B也读取到CPU1的Cache Line中，并且检查是否有其他核心拥有该数据，检查完发现没有，于是CPU1在自己的Cache Line中将数据标记为<strong>独占</strong></li><li>当CPU2想要读取数据B时，会发现CPU1的Cache Line已经有了该数据，那么CPU2的Cache Line就会把这一块数据标记为<strong>共享</strong>，同样的，CPU1的Cache Line也会把这一块数据标记为<strong>共享</strong></li><li>CPU1想要修改数据A，此时因为是<strong>共享</strong>状态，所以会先广播，CPU2接收到广播后就把<strong>共享</strong>的数据标记成<strong>已失效</strong>，然后CPU1就对数据A进行修改，然后将这一块数据标记为<strong>已修改</strong></li><li>CPU2想要修改数据B，于是会先读取数据B，因为此时数据B在CPU1的Cache Line中被标记为<strong>已修改</strong>(其实数据B并没有修改，只是因为数据B和已经修改的数据A是同一块内存块的)，所以此时CPU1会先利用<strong>写回</strong>机制，把这一块数据写回内存，然后CPU2读取该内存块，并且进行修改，然后再CPU2的Cache Line中标记为<strong>已修改</strong>，而CPU1中的这一块数据就被标记为<strong>已失效</strong></li><li>当CPU1又想要修改数据A时，会和上面的一样</li></ol><p>那么，当我们一直重复<strong>步骤4</strong>和<strong>步骤5</strong>的时候，一点也没体现出CPU Cache的优势，因为需要一直写回到内存中，就相当于直接从内存中进去读取和写入，虽然变量 A 和 B 之间其实并没有任何的关系，但是因为同时归属于一个 Cache Line ，这个 Cache Line 中的任意数据被修改后，都会相互影响</p><p>因此，这种因为多个线程同时读写同一个 Cache Line 的不同变量时，而导致 CPU Cache 失效的现象称为<strong>伪共享(False Sharing)</strong></p>
              </div>
            </details>

<h4 id="如何解决-避免-伪共享问题"><a href="#如何解决-避免-伪共享问题" class="headerlink" title="如何解决(避免)伪共享问题"></a>如何解决(避免)伪共享问题</h4><p>在 Linux 内核中存在 __cacheline_aligned_in_smp 宏定义，是用于解决伪共享的问题。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">ifdef CONFIG_SMP</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __cacheline_aligned_in_smp _-cacheline_aligned</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="keyword">else</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">define __cacheline_aligned_in_smp</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">endif</span></span><br></pre></td></tr></table></figure></div>
<p>从上面的宏定义，我们可以看到:</p>
<ol>
<li>如果在多核（MP）系统里，该宏定义是 __cacheline_aligned，也就是 Cache Line 的大小</li>
<li>而如果在单核系统里，该宏定义是空的</li>
</ol>
<p>因此，针对在同一个 Cache Line 中的共享的数据，如果在多核之间竞争比较严重，为了防止伪共享现象的发生，可以采用上面的宏定义使得变量在 Cache Line 里是对齐的</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>举个栗子 </summary>
              <div class="content">
              <p>有这样一个结构体:</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>结构体里的两个成员变量 a 和 b 在物理内存地址上是连续的，于是它们可能会位于同一个 Cache Line 中，如下图<br><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E7%BB%93%E6%9E%84%E4%BD%93.jpg" class title="结构体"></p><p>所以，为了防止前面提到的 Cache 伪共享问题，我们可以使用上面介绍的宏定义，将 b 的地址设置为 Cache Line 对齐地址，如下:</p><div class="highlight-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b __cacheline_aligned_in_smp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div><p>这样 a 和 b 变量就不会在同一个 Cache Line 中了，如下图:<br><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E7%BB%93%E6%9E%84%E4%BD%931.jpg" class title="结构体"></p><p>所以，避免  Cache 伪共享实际上是用空间换时间的思想，浪费一部分 Cache 空间，从而换来性能的提升</p>
              </div>
            </details>

<p><code>我们知道，进程是系统分配资源的基本单位，线程是CPU执行调度的基本单位，我们也知道了进程的调度算法，但是线程呢?CPU还如何选择线程执行调度呢?接着往下看吧</code></p>
<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><p>在 Linux 内核中，进程和线程都是用<strong>tark_struct</strong>结构体表示的，区别在于线程的 tark_struct 结构体里部分资源是共享了进程已创建的资源，比如内存地址空间、代码段、文件描述符等，所以 Linux 中的线程也被称为轻量级进程，因为线程的<strong>tark_struct</strong>相比进程的<strong>tark_struct</strong>承载的 资源比较少，因此以<strong>轻</strong>得名。</p>
<p>一般来说，没有创建线程的进程，是只有单个执行流，它被称为是主线程。如果想让进程处理更多的事情，可以创建多个线程分别去处理，但不管怎么样，它们对应到内核里都是<strong>tark_struct</strong>,所以，Linux 内核里的调度器，调度的对象就是 tark_struct，接下来我们就把这个数据结构统称为<strong>任务</strong></p>
<h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>在Linux系统中，我们根据任务的<strong>优先级</strong>以及<strong>响应要求</strong>，将任务分为两种，其中优先级数值越小，优先级越高</p>
<ol>
<li>实时任务，对系统的响应时间要求很高，也就是要尽可能快的执行实时任务，优先级在 0~99 范围内的就算实时任务</li>
<li>普通任务，响应时间没有很高的要求，优先级在 100~139 范围内都是普通任务级别</li>
</ol>
<h3 id="调度类"><a href="#调度类" class="headerlink" title="调度类"></a>调度类</h3><p>由于优先级的不同，Linux为了保障优先级高的任务尽可能地被执行，于是分为了以下几种<strong>调度类</strong></p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>几种调度类 </summary>
              <div class="content">
              <ol><li><p>Deadline调度类，它的调度器为<strong>Deadline调度器</strong>，调度策略为<strong>SCHED_DEADLINE(按照deadline调度，意思就是说距离当前时间点最近的deadline的任务会先被调度)<strong>，这种调度器一般是用来调度</strong>实时任务</strong>的</p></li><li><p>Realtime调度类，它的调度器为<strong>RT调度器</strong>，调度策略有两种</p><ol><li>SCHED_FIFO，对于相同优先级的任务，会将所有任务放入一个队列，然后根据队列的<strong>先进先出</strong>规则来调度任务，如果在一个任务被执行的过程中出现了优先级更高的任务，那么CPU就会停下当前手头上的任务，转而去执行优先级更高的那个任务</li><li>SCHED_RR，对于相同优先级的任务，轮流着运行，每个任务都有一定的时间片，当用完时间片的任务会被放到队列尾部，以保证相同优先级任务的公平性，但是高优先级的任务依然可以抢占低优先级的任务</li></ol><p> 这个调度类一般也用于<strong>实时任务</strong></p></li><li><p>Fair调度类，它的调度器为<strong>CFS调度器</strong>，调度策略也有两种</p><ol><li>SCHED_NORMAL，<strong>普通任务</strong>的调度策略</li><li>SCHED_BATCH，后台任务的调度策略，不和终端进行交互，因此在不影响其他需要交互的任务，可以适当降低它的优先级</li></ol><p> 这个调度类是用于<strong>普通任务</strong>的</p></li></ol><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E8%B0%83%E5%BA%A6%E7%B1%BB.jpg" class title="调度类">
              </div>
            </details>

<h3 id="完全公平调度"><a href="#完全公平调度" class="headerlink" title="完全公平调度"></a>完全公平调度</h3><p>在我们平时写代码时，一般的线程都属于<strong>普通任务</strong>，<strong>普通任务</strong>的比例也是最大的，而对于<strong>普通任务</strong>而言，<strong>公平</strong>才是最重要的，Linux为了满足<strong>普通任务</strong>的公平性，基于<strong>CFS</strong>的调度算法应运而生，那就是<strong>完全公平调度</strong>算法</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>算法理念 </summary>
              <div class="content">
              <p>这个算法的理念是想让分配给每个任务的 CPU 时间是一样，于是它为每个任务安排一个虚拟运行时间<strong>vruntime</strong>，如果一个任务在运行，其运行的越久，该任务的<strong>vruntime</strong>自然就会越大，而没有被运行的任务，<strong>vruntime</strong>是不会变化的</p><p>在<strong>CFS调度算法中</strong>，<strong>vruntime</strong>越小，就越会被选择，也就是说，<strong>CFS调度算法</strong>会优先选择<strong>vruntime</strong>小的任务</p><p>因为普通任务也会有优先级的区别，所以对于<strong>vruntime</strong>的计算，是需要考虑上普通任务的优先级的</p>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>vruntime的计算 </summary>
              <div class="content">
              <p><code>虚拟运行时间 vruntime += 实际运行时间 delta_exec * NICE_0_LOAD/权重</code></p><p>NICE_0_LOAD:我们可以不用知道是什么，只需要知道它是一个<strong>常量</strong><br>权重: 注意权重值并不是优先级的值，内核中会有一个 nice 级别与权重值的转换表，nice 级别越低的权重值就越大，至于 nice 值是什么，我们后面会提到</p>
              </div>
            </details>

<h3 id="CPU运行队列"><a href="#CPU运行队列" class="headerlink" title="CPU运行队列"></a>CPU运行队列</h3><p>一个系统通常都会运行着很多任务，多任务的数量基本都是远超 CPU 核心数量，因此这时候就需要<strong>排队</strong></p>
<p>事实上，每个 CPU 都有自己的**运行队列(Run Queue, rq)**，用于描述在此 CPU 上所运行的所有进程，其队列包含三个运行队列，Deadline 运行队列 dl_rq、实时任务运行队列 rt_rq 和 CFS 运行队列 csf_rq，其中 csf_rq 是用红黑树来描述的，按 vruntime 大小来排序的，最左侧的叶子节点，就是下次会被调度的任务。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E8%BF%90%E8%A1%8C%E9%98%9F%E5%88%97.jpg" class title="运行队列">

<p>这几种调度类是有优先级的，优先级如下：Deadline &gt; Realtime &gt; Fair，这意味着 Linux 选择下一个任务执行的时候，会按照此优先级顺序进行选择，也就是说先从 dl_rq 里选择任务，然后从 rt_rq 里选择任务，最后从 csf_rq 里选择任务<br><strong>因此，实时任务总是会比普通任务优先被执行</strong></p>
<h3 id="如何调整优先级"><a href="#如何调整优先级" class="headerlink" title="如何调整优先级"></a>如何调整优先级</h3><ol>
<li>因为我们知道，<strong>实时任务</strong>肯定会比<strong>普通任务</strong>先进行调度，所以如果我们想要提高某个<strong>普通任务</strong>的优先级，那么方法之一就是将<strong>普通任务</strong>变成<strong>实时任务</strong></li>
<li>如果你想让某个普通任务有更多的执行时间，可以调整任务的<strong>nice</strong>值，从而让优先级高一些的任务执行更多时间。nice的值能设置的范围是<strong>负20~19</strong>，值越低，表明优先级越高，因此<strong>负20</strong>是最高优先级，<strong>19</strong>则是最低优先级，默认优先级是 0</li>
<li>它与优先级(priority)的关系是这样的：priority(new) &#x3D; priority(old) + nice，因为<strong>普通任务</strong>的优先值为<strong>100~139</strong>，又因为<strong>nice</strong>是调整<strong>普通任务</strong>的优先级，所以<strong>nice</strong>的值只能是<strong>负20~19</strong><img lazyload src="/images/loading.svg" data-src="/2023/03/03/blog9/%E4%BC%98%E5%85%88%E7%BA%A7.jpg" class title="优先级"></li>
<li>在前面我们提到了，权重值与 nice 值的关系的，nice 值越低，权重值就越大，计算出来的 vruntime 就会越少，由于 CFS 算法调度的时候，就会优先选择 vruntime 少的任务进行执行，所以 nice 值越低，任务的优先级就越高</li>
</ol>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>关于CPU的知识点总结就到这里了，鼠鼠写了好多字啊，虽然有的文字是直接复制<strong>小林coding公众号</strong>的内容，图片也都是出自这里的，但鼠鼠也有在认真思考总结的嘛，鼠鼠也没那么不堪对吧，虽然鼠鼠到现在还没收到一家公司的面试，有的公司可能都不看我一眼<br>(悲)我同学都收到腾讯的面试邀请了，我们读的不是一个大学吗，为什么我简历他们都不愿意看一眼(悲)</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔·广州·出个屁哦，哥们考六级</title>
    <url>/2023/03/12/day3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1826307499&auto=1&height=66"></iframe>

<p>记录一下这周发生过的事情</p>
<ol>
<li>很好，突破了3月0面试的记录，成功接到1个面试，但是面试那天，我辛辛苦苦看了一天的八股文和各种面经，但是在服务大厅的那个晚上，我在电脑前傻傻地等着面试官，从8点10的预约面试，等到了快10点(晚上!),这也就算了，人在屋檐下不得不低头，你好歹问我一些专业问题叭？比如一些常规八股文啊，你不问我怎么知道我会不会啊，你就让我介绍个项目然后和我讲了一下你公司怎么怎么样，啊然后讲的时候网络还很差，我tm怎么知道你在说什么啊？要不是我就你一个面试，不然我早就润了，你要不想要我就直说，别吊着我ok？烦死个人</li>
<li>面试的第二天，学校举办的ACM竞赛选拔赛，我也去参加了，不为别的，就想看看有多难!好嘛，3个小时写了两题，第一题还不完全对，我人都傻了，怎么这么难，别人12题全做出来，我不及人家1&#x2F;6啊，人和人的差距这么大嘛！今天的第一次打击来源于此</li>
<li>当天晚上，开始写美团的笔试，很好，第二次打击，不过无所吊谓，听说就算AK了，也还是看简历的，啊那没事了</li>
<li>然后就是六级了，这倒是还好，本来也不打算过，考前都没复习，不过！在考前排队进考场的时候，我看见了一个超级超级超级可爱！的一个妹子，她真的好可爱，她的眼睛，鼻子，嘴巴，无一不是造物主的巧手捏造而成，它们是如此的可爱，白稚的皮肤，吹弹可破也不为过，“麻烦垫一下脚”，哈哈原来是她没办法把这张脸映入人脸检测系统奥，她努力踮着脚的样子更是让我心动，看着她就好像回到了高中一样，那时我偷偷从暗恋的人班级门口走过，都忍不住想要扭头去看看她在干嘛，但我又害怕和她的眼神触碰，即使和她面对面擦肩而过，我都不敢抬头的那段岁月一般，如此可爱的女孩啊，如果人类有尾巴的话，那么当时的我肯定会很高兴地摇尾巴以表达我的爱意，我原本就是相信一见钟情的人，我也不得不承认，从那一刻起，我就沉沦于她的容貌了(我好肤浅啊)，以至于一整个下午的六级脑子里都是她微笑的面庞</li>
<li>经过一整个六级的思想斗争，我决定主动出击!在考完六级后，我特意跟在女孩的后面，好几次想要喊她却又不敢，这是我头一次因为自己喜欢某个女孩去要微信，最后在强烈的冲动下，我冲了!<br> “不好意思，不太方便”，“奥奥，没事，打扰了”，<code>第三次打击</code><br> “被打击的对象，是你哦~”     –萨科(恶魔小丑)<br> 我好像….失恋了?从此水泥封心不再爱，以后也不会再去要了，我的尾巴好像一下子焉了</li>
<li>晚上和朋友打五排lol，emmm又被爆杀了</li>
<li>刚进大学认识的第一个师兄，下周就要去很远的地方去当兵啦，这一别就不知道什么时候能再见了，希望他一切安好，很开心他圆了自己的当兵梦，我也要慢慢过好我的生活了，期望我们以后还能再见面，无论在何处</li>
</ol>
<p>总而言之，这星期就没好事发生!下周一还要上台发言以及晚上还要写百度的笔试，而且我觉得…我大概率又过不了，啊真烦人啊，垃圾世界赶紧毁灭算了，你不死我死好了，去你妈的!</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常.广州</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔·广州·拍毕业证件照和体检而导致没有出去的休息日</title>
    <url>/2023/03/19/day4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=36150266&auto=1&height=66"></iframe>

<p>感觉这周没有什么特别的事情发送，硬要说的话，就是这周的自己特别消极，一直因为找不到实习的事情一直焦虑，看到别人都拿到了实习，我是羡慕的不得了啊，之前面试的那个公司也没给我后续通知了，哪怕是一封感谢信也没有。</p>
<p>现在的精神状态有点差，每天醒来的第一件事就是去查看邮箱，是否会有公司给我发面试通知，不过我点进去永远都不会有消息，然后一整天就很down了，我甚至会后悔为什么自己要选择这条路，在考虑要不要往嵌入式那一块卷，不过听说那一块特别卷，哎，我好想做游戏服务端开发啊，如果能去网易就好咯。</p>
<p>周六体检和拍毕业照，本来学校男女比例就1:1的，这次拍照加上体检可算见到庆的实力了，每个女孩都穿上jk或者制服，好漂亮啊，她们正是在花一样的年纪，只要稍微打扮一下，就是花丛中漂亮的花朵之一了，虽然我知道这些花朵都不会属于我，但我还是会很想去触碰这些花朵，什么时候才能拥有属于自己的那一朵花呢。</p>
<p>我发现，当我不把古诗词当作考试的内容后，我就好喜欢诗词啊，浪漫主义至上的李白，青莲居士的诗词永远是那么的积极乐观<br><code>“长风破浪会有时，直挂云帆济沧海”，“天生我材必有用，千金散尽还复来”，“安能摧眉折腰事权贵，使我不得开心颜”</code><br>还有孟郊的《登科后》<br><code>春风得意马蹄疾，一日看尽长安花</code><br>如果我能去大厂工作的话，没有哪句诗能比这个更能体现我的心情了，真希望以后能用上<br>诗歌就是好啊，能够寄托诗人的感情，当我去研读诗词的时候，我总能想象出诗人眼中的世界，美好且虚幻，悲哀但真实</p>
<p>中国的教育是畸形的，我没法去改变这种现状，在历史的河流中，我或许一丝浪花都没法掀起，我能做的，只有保持自我清醒，孤独地等待着死亡，人是一个人来到这个世界上的，最终也会一个人死去，喜欢看番的原因就是喜欢将自己带入番内，逃避现实而已</p>
<p>总而言之，这一个星期过的很无聊，虽然再看计算机网络了，但一想到看了这么久连简历关都过不去，就莫名地感到悲哀，都说要自己努力去找机会，但是好像也不是这样，当运气不好的时候，无论我如何努力都没法触碰到机会啊，转瞬即逝未免太小看机会了吧，它本就没出现过.</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常.广州</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔·广州·因为下雨没有出去只能窝在宿舍重刷《你的名字》</title>
    <url>/2023/04/02/day6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2019972021&auto=1&height=66"></iframe>

<p>好烦啊，买了这首歌却还是没办法生成外链，虽然这个版本也不错，但我更喜欢原版</p>
<p>又一次重刷了一遍《你的名字》，这是在我心中可以和《肖申克的救赎》、《霸王别姬》一个档次的电影了，虽然是动漫的，但在我看来，也属于电影了</p>
<p>无论是场景的描写，还是三叶和泷的故事，都是那么的美妙，利用时间的交错来让观众沉迷其中，还有美妙无比的音乐，都将这部作品抬到特别高的位置，当我躺在床上，外面下着雨，我将床帘拉起来，手机里放着《你的名字》的时候，耳朵里面是《约会》这首曲子，我会觉得世间是多么的美好啊，爱情是切切实实存在的，只是我还没遇到。</p>
<p>这部作品的感情线很不错</p>
<p>“你打的工太多啦”，“还不是因为你乱花钱!”<br>“稍微注意一下男孩子的眼光啊，怎么会有女孩子向我表白”，“你不觉得把人生交给我来过会让你更受欢迎哦”<br>“你别自恋了，明明没有女朋友”，“你还不是没有男朋友”<br>“我啊，才不是没有，我只是不想谈”….<br><code>此处BGM为《前前前世》</code><br>这一段是整部影片中比较欢快的一部分，用短短的几个场景，几句话，就让观众感受到了两位主角的互动，这种跨时空互动更是让双方在不知不觉中拉近了关系</p>
<p>在这部影片中我们需要梳理一下时间线，首先就是三年前的三叶和三年后的泷交换了身体，而在泷的时空里，三叶他们因为陨石而死亡了，在三叶的时空里，泷并不认识三叶，以至于后来三叶去东京找泷的时候，泷才不知道三叶的名字</p>
<p>三叶和泷的感情也在各种细节方面体现，比如三叶用泷的身体成功和奥司前辈约会的时候，三叶换回身体后就明显看出来有点失落了，所以第二天她就和妹妹四叶说“要去东京约会”(有没有可能三叶其实是想自己去和泷约会，但这都是猜测)，然后就不辞幸苦地去东京找泷，此时在三叶的时空里，泷并不认识三叶，但是三叶很坚定的认为如果双方见面，泷一定会认得她的，三叶辛辛苦苦找了好久，在想要放弃的时候看到泷在一辆电车上，最后三叶和三年前的泷成功碰面了，但此时泷并不认识三叶，自然也就不存在“喜欢”这种可能，但三叶微红的脸颊就能说明一切了，“泷，记得我吗?”,“嗯?我认识你吗?”，在这里，三叶的脸变得通红，是为什么呢?但此时三叶肯定是很难过的，随着电车的到站，三叶被人群往外挤，此时泷问了一句“你的名字是?”,三叶听到后，明显有点激动，于是将自己绑头发的绳结解开扔给了泷，“三叶，我的名字叫三叶”，那天之后，三叶就剪了短发<br><code>这里科普一下，在日本古时候，女子会在丈夫出门时给他的手上绑上绳结，类似于平安符的寓意吧，等丈夫回到家后才会还给妻子</code><br>如果仔细看的话，就会发现泷的手腕以前是没有绳结的，从某一刻开始就出现了</p>
<p>当然了，泷对三叶的感情可以从奥司的话中看出来，“你以前有点喜欢我的，但现在有更喜欢的人了对吧”，虽然泷极力否认，但明眼人都看得出来，这是当一个人被看穿的时候的窘迫，以及后面泷不辞辛苦去找三叶，这和三叶来找他互相对应，这才是<strong>双向奔赴</strong>啊</p>
<p>整部剧的高潮我认为在于<strong>黄昏之时</strong>的时候，在这里，三年前的三叶和三年后的泷成功见面，在这一刻，我明显感觉到我的眼泪落了出来，我本就是个感性的人，我也不想这样，但我想，无论多少次看到这个画面，我都会被感动到</p>
<p>当泷和三叶见面的时候，双方都脸红沉默了一会，最后又三叶打破了沉默，经过一番煽情的对话，最后泷在三叶手上写了“我喜欢你”，等到后面三叶为了拯救大家再去找父亲的路上摔倒的时候，看到手心的字的时候，这是另外一个情感的高潮，此时双方都已经忘记了对方的存在，写到这里的时候，我的鼻子还是酸了一下</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/02/day6/%E5%90%9B%E5%90%8D1.jpg" class title="君名1">
<img lazyload src="/images/loading.svg" data-src="/2023/04/02/day6/%E5%90%9B%E5%90%8D2.jpg" class title="君名2">
<img lazyload src="/images/loading.svg" data-src="/2023/04/02/day6/%E5%90%9B%E5%90%8D5.jpg" class title="君名5">

<p>还好，诚哥还有心，最后女主存活下来，并且和男主遇见了，虽然双方都不认识对方，但喜欢过一次的人，即使忘记了对方，当再一次遇见，还是会为之心动<br><strong>不管你在哪个地方，我都一定会再次去见你!</strong> —-泷<br>“<strong>我喜欢你</strong>”“<strong>笨蛋你这样我怎么知道你叫什么啊</strong>“ —三叶</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/02/day6/%E5%90%9B%E5%90%8D3.jpg" class title="君名3">

<p>《没什么大不了》部分歌词大意:</p>
<p>君のいない 世界にも 何かの意味はきっとあって<br><strong>你所不存在的那个世界 一定也存在着什么意义</strong></p>
<p>でも君のいない 世界など 夏休みのない 八月のよう<br><strong>但是你所不存在的那个世界 就像没有暑假的八月</strong></p>
<p>君のいない 世界など 笑うことない サンタのよう<br><strong>你所不存在的那个世界 就像没有笑容的圣诞老爷爷</strong></p>
<p>君のいない 世界など<br><strong>你所不存在的那个世界啊</strong></p>
<p>僕らタイムフライヤー 時を駆け上がるクライマー<br><strong>我们是时间旅行者 追逐时光的攀岩者</strong></p>
<p>時のかくれんぼ はぐれっこはもういやなんだ<br><strong>厌倦了与时间的躲猫猫</strong></p>
<p>なんでもないや やっぱりなんでもないや<br><strong>没什么 当我什么都没说</strong></p>
<p>今から行くよ<br><strong>现在就去找你哦</strong></p>
<p>今后无论多久，我都会喜欢这部动漫，我永远会因为泷和三叶的故事而热泪盈眶，因为他们的爱情真实我所期盼的，所以以后一定要和我爱的人，将这部动漫重新仔细地观看一边，我也会和她说:“今后无论你在哪里，即使我忘记了你的存在，我也一定会在人群中一眼就找到你，也会因为这一眼重新心动”</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/02/day6/%E5%90%9B%E5%90%8D4.jpg" class title="君名4">]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常.广州</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔·广州·一个人看电影咯</title>
    <url>/2023/03/25/day5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2032910023&auto=1&height=66"></iframe>

<p>今天是一个人去看电影的一天~<br>简单评价一下《铃芽之旅》这部动漫吧</p>
<p>新海诚诚哥继《天气之子》后的又一新作，上次看《天气之子》还是三年前，那时候我还在上高中，一转眼我都在开始忙着找工作了，一如三年前，也可以追溯至六年前，我这六年来变了很多，唯一不变的，就是我还是一个人，不过这都不所谓，我也许大概会等到一个如“新海诚式”的爱情，晚来一点也没关系</p>
<p>这部作品呢，不愧是诚哥的作品，“每一帧都可以拿来当壁纸”这句话评价诚哥的作品是最合适不过的了，这部作品也一样，环境描写的非常好，剧情也很不错，不过这一次与以往不同的是，在《你的名字》和《天气之子》里面，都是男主与女主初识，然后发生一些奇妙的事情，最后需要男主去挽救女主生命这样的，但这一部男主都没怎么露面，虽然主角们还是从不认识到认识的，但比较奇怪的就是这一步男女主之间的感情线太奇怪了点，女主对男主的喜欢好像是没来由的一样，仅仅因为女主觉得男主帅?但也不对啊，男主在这部动漫里面大部分是以凳子的形态出现的…</p>
<p>还有就是女主已经将男主爱到可以牺牲自己去挽救男主性命了嘛?他们才认识几天啊，如果按照剧情来说，他俩从认识早相爱，好像也才…3个晚上?嘎?这比前两部都快多了，《你的名字》泷和三叶怎么说也交换了几个星期的身体了吧，《天气之子》里面，阳菜和帆高也一起从一无所有一起努力赚钱了很久了吧，总而言之我就是觉得铃芽和草太的感情线过于快了点，不过也没办法，这是动漫而不是番剧，没办法铺垫太久</p>
<p>还有就是在看这部电影前，得知道一些背景，那就是311日本大地震，一场很严重的地震，我想诚哥可能也在用自己的方式让人们记住这些灾害，就像我们永远不能忘记08年汶川大地震一样</p>
<p>总而言之，这部动漫10分的话给8分吧，剧情有新意，而且情节不错，还有就是诚哥不愧是老足控了啊，对脚部的描写依然是会有的，这一点从以前诚哥的作品就可以看出了，当然了，我也很喜欢嘿嘿~，如果男女主的之间的感情写得更细致一点的话，应该是可以和《天气之子》差不多水平的作品，当然了，在风景和日常这一方面，依旧可以给到10分，如果这次的风景也是在现实世界中取景地话，那就说明铃芽骑自行车下坡地那段路也存在，好漂亮啊，好想去亲眼看一下</p>
<p>最后就是，一个人看电影也没什么，当我把身心投入到电影中，我就不会感觉到孤单了，其实我本来就觉得没什么，期待下一个三年吧，以后一定一定要和女朋友看诚哥的作品!</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常.广州</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔·重庆·来到重庆的第一个周末</title>
    <url>/2023/04/09/day7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1984045303&auto=1&height=66"></iframe>

<p>这是我在重庆过的第一个周末，比较开心的是找到了住处，虽然是住在我的堂哥家中</p>
<p>虽然一开始还是不太乐意的，毕竟是别人的家庭，如果我住进去就意味着寄人篱下，但一想到两个月我能省下将近2k块钱，我觉得脸也不是那么重要了，再加上以后如果我每天在公司加班到晚上8:30，那么就可以有35的餐补，相当于一天的饭钱，那也就意味着，我在重庆的开销只有偶尔嘴馋了想吃点什么，或者想去洗个脚泡个澡啊什么的之外，就没了!</p>
<p>堂哥对我蛮好的，而且他坚持去长江游泳，坚持了快1年了，无论季节，这是很令我敬佩的</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/09/day7/%E9%95%BF%E6%B1%9F.jpg" class title="长江">

<p>还带我去吃了火锅</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/09/day7/%E7%81%AB%E9%94%85.jpg" class title="火锅">
<p>也就是说!我能将实习得到的这些钱拿去做自己想做的事情了!比如…去西藏旅游!</p>
<p>不过刚到这边就吃那么辣的东西，也不知道我的肠胃能不能受得了，反正我今天为了开个大找了半天的厕所，也不是说没找到，只是这些厕所都没有纸，那只好继续找，还好在肯德基里面找到了，而我现在也正坐在肯德基里面，啥也没点，就坐着，原本是打算去重庆图书馆继续学习的，但是那里面好像没有那种带着插座的座位，那我不用电脑我不知道要学什么了，还好肯德基有，这篇随笔也就是在这里写的</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/09/day7/%E5%9B%BE%E4%B9%A6%E9%A6%86.jpg" class title="图书馆">

<p>随便比较吵吧，但总比在外面晒太阳背着个书包乱跑来的好，再说了，我其实更想去重大的图书馆，可惜不让我进，说到天气，重庆的早上好冷，一到中午或者下午，气温瞬间升高，这让我很难受的说，后面慢慢习惯吧~</p>
<p>要学的东西确实很多，leader说我是个人才，可我觉得自己其实并不是，我只是一个普通的不能再普通的普通人，我也不知道自己能否学会IOS开发，自己脑子其实不灵光，也只有通过努力来麻痹自己，每次都会装作很轻松的样子来满足自己的虚荣心，这种坏毛病好像高中就有了，我知道这样不好，可是当别人问起我的时候，我可能还是会下意识地故作轻松，我不太喜欢别人对我有太大的期待，因为我觉得这会给我很大的压力，这种强加的压力对我并没有什么好处，我希望的压力是来自于我自己，是因为我自己想变优秀而感到的压力，而不是别人希望我优秀而强加在我身上的压力，这种压力迟早会将我压垮，哎，困了，趴着睡会吧,话说怎么没有其他游戏厂的面试呀，我果然还是更想去搞游戏</p>
<p>午安</p>
<p>更新</p>
<p>晚上到洪崖洞对面的长江边上玩去了，下午的时候气温升高了，再加上得知自己网易雷火的简历筛选都没过，整个人十分的down，只要每次收到不好的消息我都会失落一整子，这次也不例外，所以选择去散散心，背包里装着电脑，一路上都背着她，说实话还蛮累的，最后走到了目的地，原本想将洪崖洞的灯亮的过程拍下来的，结果刚好低头玩手机去了…</p>
<p>“不要害怕出丑，世界上不会有那么多人关注你”</p>
<p>所以我就拍了点”大学生pose”，给他们来点小小的大学生震撼!</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/09/day7/%E6%B4%AA%E5%B4%96%E6%B4%9E1.jpg" class title="洪崖洞1">
<img lazyload src="/images/loading.svg" data-src="/2023/04/09/day7/%E6%B4%AA%E5%B4%96%E6%B4%9E2.jpg" class title="洪崖洞2">
<img lazyload src="/images/loading.svg" data-src="/2023/04/09/day7/%E6%B4%AA%E5%B4%96%E6%B4%9E3.jpg" class title="洪崖洞3">]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常.重庆</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔·重庆·从一个大学城来到另外一个大学城</title>
    <url>/2023/04/17/day8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1475724102&auto=1&height=66"></iframe>

<p>经过一个星期辛苦的工作后(其实我大部分时间都在学习，并没有上手公司的什么项目…)，终于迎来了来重庆的第二个周末，并且也迎来了公司的第一次团建，在周五下午5点后，公司就举行了一个徒步团建！(像是爬山？虽然山不是很高就是了)</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E5%BE%92%E6%AD%A5.jpg" class title="徒步">

<p>最终的目的地是一家日本和牛火锅，在里面，我们4个实习生坐一块一起烤肉，煮火锅吃</p>
<p>这是吃之前</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E5%9B%A2%E5%BB%BA1.jpg" class title="团建1">

<p>这是吃完后(公司的前辈有些吃不完全拿给我们了哈哈，其实我们也吃不下那么多)</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E5%9B%A2%E5%BB%BA2.jpg" class title="团建2">

<p>其实吃完后是要去网吧开黑的，但是原本说好一起去的人结果都跑了，大概是去洗脚按摩了吧，我都还没去过呢</p>
<p>然后第二天就去重庆的大学城了!</p>
<p>也是从这一天开始，重庆突然变得好热</p>
<p>先是去川美旁边的美术馆参观，提高一下我的艺术审美</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E7%BE%8E%E6%9C%AF%E5%B1%951.jpg" class title="美术展1">
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E7%BE%8E%E6%9C%AF%E5%B1%952.jpg" class title="美术展2">
<p>虽然我其实不是很懂里面的寓意就是了，也感觉自己的审美好像也没有提高，看来以后要多去几次了，哎，要是当初能和小玲一起去一次多好</p>
<p>然后就偷偷跟着别人进了川美</p>
<p>果然，川美的艺术氛围很浓厚，无论何处都能看到涂鸦雕塑什么的，就连走过的地面的瓷砖都是富有艺术感的</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E5%B7%9D%E7%BE%8E1.jpg" class title="川美1">
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E5%B7%9D%E7%BE%8E2.jpg" class title="川美2">
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E5%B7%9D%E7%BE%8E3.jpg" class title="川美3">

<p>逛完一大圈，肚子也饿了，然后我就看到必胜客了，里面还有申鹤小姨!超级好看的!好想和她合照啊~</p>
<p>吃到一半还遇到小草神和温迪了~<br>(这里就不妨人家的照片了，因为我没敢找她们合照，以后一定要去当coser进入漫展!)</p>
<p>原神套餐!我是OP!</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E5%BF%85%E8%83%9C%E5%AE%A2.jpg" class title="必胜客">

<p>随后就是回家啦，天气很好，我捕捉到了一个我觉得很赞的画面</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E8%BD%BB%E8%BD%A8.jpg" class title="轻轨">
<p>为了拍这一幕，我等了好久的，有没有很像日本动漫中，某个不是很发达，但是也会有电车的小镇中，远处的蓝天下，电车缓慢驶过的感觉呢？</p>
<img lazyload src="/images/loading.svg" data-src="/2023/04/17/day8/%E9%92%9F%E5%A1%94.jpg" class title="钟塔">
<p>还有远处的一个钟塔~</p>
<p>这一趟下来，收获了很多，虽然因为大学城太远了，过去太累了，但还是很好，自由的感觉，一个人也不会孤单，我很喜欢~</p>
<p>晚安</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常.重庆</tag>
      </tags>
  </entry>
  <entry>
    <title>随笔·重庆·发烧生病无聊的五一假期</title>
    <url>/2023/05/03/day9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1960534306&auto=1&height=66"></iframe>

<p>很久没写随笔了，同样的因为在公司学的IOS的知识不知从何下笔，虽然我知道有很多知识需要去掌握，但是因为我基本上回到家后就不想再去看了，所以一般来说我只会在公司才会去学习，害，这样说来，自己越来越摆烂了…</p>
<p>好不容易熬到了五一假期，结果就在放假的前一天突然发烧了，我也不知道是甲流还是阳了，但为了更好地享受这个假期所以一回家直接开始睡觉，好在第二天烧退了，但是嗓子那叫一个痛啊，还一直咳嗽，拖着这种身子去面见了一位网友，真是抱歉</p>
<p>后面几天也几乎呆在家里，虽然没发烧了但也一直在咳嗽，况且我也不知道要去哪里玩，五一重庆应该很多人，我就懒得去凑热闹了，现在最烦恼的还是回学校答辩的事情，再就是那些奇奇怪怪的报告，啧，好多事情啊，6月份还得回学校备考也是真的很烦</p>
<p>身边也没有能教出来一块玩的朋友，难免假期会觉得无聊，游戏也懒得去打，总觉得无聊至极，好像生活突然失去了什么，可能是失去了目标，可能是发个烧把脑子烧坏了，每天就是躺在床上刷抖音，连外卖我都有点懒得去点，只有实在是饿了的时候才会点开美团，这样想想现在的日子好像不如在学校的那段日子，在学校的时候虽然会一直想找个实习，但是至少是有个目标的，当真是可悲啊</p>
<p>唯一有的说的可能就是五一去看了一部蛮搞笑的电影，当然我就把这电影当作喜剧片来看待，也确实挺好笑的，哎，不知道五一过后的日子会是什么样的，也不知道是否能过够很好的解决实习答辩的问题，现在的生活就是有一大堆事情没做，但具体要做一件事的时候又不知道从何下手，当真是可悲啊</p>
<p>接下来打算重新配置一下主题，为了让自己的博客更好看吧，这也是我之前一直想做但一直耽搁的事情</p>
]]></content>
      <categories>
        <category>日常</category>
      </categories>
      <tags>
        <tag>日常.重庆</tag>
      </tags>
  </entry>
  <entry>
    <title>欢迎来到我的主页，准备好迎接天才的头脑大战叭！</title>
    <url>/2023/02/22/me/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1874972712&auto=1&height=66"></iframe>

<p>恋爱即战争，在恋爱中，谁先告白谁就是输家！无论如何也要让对方进行告白，这就是天才们的恋爱头脑大战~<br>咳咳，跑题了，欢迎来到我的主页，本破站建于2023-2-23<br>博主还只是一个在读大学生捏，会持续更新一些学习的知识点，当然也会更新一些我的发疯日常~大学生哪有不发疯的呢</p>
<img lazyload src="/images/loading.svg" data-src="/2023/02/22/me/%E6%B4%BE.jpg" class title="派">

]]></content>
      <categories>
        <category>自我介绍</category>
      </categories>
      <tags>
        <tag>自我介绍</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/2023/06/28/blog18/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=2117005&auto=1&height=66"></iframe>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久没写博客了,之前因为实习就没那个心思去写了,后面因为要准备期末考又拖了很长一段时间,等到考完发现自己主题版本太落后,于是重新更新了一次主题,再加上自己好久没怎么看八股文了,加上考完想休息一下,接下来全力准备秋招,所以自己摆烂了一段时间,现在重新“提笔”落座,重新开始写一些文章来巩固知识点,早早开始为秋招做准备。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>在Linux下面,有一句话叫做<code>一切皆为文件</code>,就连<code>块设备,管道和Socket</code>也都是文件,那么自然就会有一个文件系统来管理这些文件,其实不光是在Linux下会有这么一个系统,只要是操作系统都需要这么一个系统来帮助用户管理文件,因为大家都知道,我们所有的文件,想要永久存在,就会储存在<strong>磁盘上</strong>,那么,如何将用户创建的文件或者想要存储的数据存在磁盘上呢?我们用户肯定没办法去在磁盘上动手脚,所以只能依靠<code>操作系统</code>来实现,那么这就需要<code>文件系统</code>了,我们还是用Linux下的文件系统来讲解</p>
<h2 id="Linux下的文件系统"><a href="#Linux下的文件系统" class="headerlink" title="Linux下的文件系统"></a>Linux下的文件系统</h2><p>文件系统下的基本单位是<code>文件</code>,它的目的是对磁盘上的文件进行组织管理,那组织的方式不同,就会形成不同的文件系统。</p>
<p>Linux文件系统会为其每个文件分配两个数据结构:<code>索引节点</code>和<code>目录项</code>,主要是用来记录文件的基本信息和目录层次结构</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>索引节点 </summary>
              <div class="content">
              <p>1.索引节点(inode),用来记录文件的基本信息,例如<code>inode编号,文件的大小,访问权限,创建时间,修改时间等等</code>,最重要的是<strong>数据在磁盘的位置</strong>。<br>2.索引节点同样会被存放在磁盘中,所以也会占用磁盘空间。<br><code>每个文件的索引节点都是唯一对应的,也就是说索引是文件的唯一标识符</code></p>
              </div>
            </details>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>目录项 </summary>
              <div class="content">
              <p>1.目录项(dentry),用来记录<strong>文件的名字</strong>,<strong>索引结点指针(指向索引节点在磁盘中的地址)</strong>,<strong>其他目录项的层级关联关系</strong><br>2.多个目录项关联起来,就会形成<strong>目录结构</strong><br>3.目录项不存放在磁盘中,而是由<strong>内核维护的一个数据结构,缓存放内存中</strong></p>
              </div>
            </details>

<p>因为目录项记录的文件的名字,而索引节点唯一标识一个文件,所以目录项和索引节点的关系就是<strong>多对一</strong>,就是说可以有多个目录项中的<strong>指向索引节点的指针</strong>指向同一个索引节点,也就是说一个文件可以有多个别名</p>
<p>Linux中的硬链接就是通过该关系来实现的,通过硬链接创建的文件,其目录项中<strong>指向索引节点的指针</strong>与源文件的目录项中是一样的,所以可以指向同一个索引节点,从而指向同一块磁盘上的数据</p>
<a class="button  regular" href="https://qx-gg.github.io/2023/02/24/blog2/" title="硬链接和软链接">硬链接和软链接</a>

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>目录项和索引节点的关系 </summary>
              <div class="content">
              <img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E7%9B%AE%E5%BD%95%E9%A1%B9%E5%92%8C%E7%B4%A2%E5%BC%95%E5%85%B3%E7%B3%BB%E5%9B%BE.jpg" class title="目录项和索引关系图"><p><code>索引节点存储在磁盘上,而为了提高磁盘读写效率,加速文件的访问,通常会将索引节点加载到内存中</code></p><p>如图所示,磁盘上分为3块区域,分别为:<br>1.超级块:用于存储文件系统的详细信息,例如<strong>块的个数</strong>,<strong>块的大小</strong>和<strong>空闲的块</strong>等等<br>2.索引节点区:用来存储索引节点<br>3.数据区:用来存储文件或者目录数据</p><p>我们不可能把超级块和索引节点区全部加载到内存,这样内存肯定撑不住,所以只有当需要使用的时候,才将其加载进内存,它们加载进内存的时机是不同的:<br>1.超级块:当文件系统挂载时进入内存<br>2.索引节点区:当文件被访问时进入内存</p>
              </div>
            </details>
<h3 id="目录项和目录的关系"><a href="#目录项和目录的关系" class="headerlink" title="目录项和目录的关系"></a>目录项和目录的关系</h3><p>目录项和目录虽然只有一字之差,但是它们并不是一个东西,<strong>目录是个文件</strong>,持久化存储在磁盘中,而目录项是一个数据结构,由内核进行维护,缓存在内存中</p>
<p>如果查询目录频繁从磁盘读,效率会很低,所以内核会把已经读过的目录用目录项这个数据结构缓存在内存,下次再次读到相同的目录时,只需从内存读就可以,大大提高了文件系统的效率</p>
<p><code>目录项这个数据结构不只是表示目录,也是可以表示文件</code></p>
<h3 id="文件是如何存储在磁盘中的"><a href="#文件是如何存储在磁盘中的" class="headerlink" title="文件是如何存储在磁盘中的?"></a>文件是如何存储在磁盘中的?</h3><p>磁盘读写的最小单位为<strong>扇区</strong>,大小只有<strong>512B</strong>,如果一次只能读取一个扇区的数据的话,效率太低了,所以文件系统就把多个扇区组合成一个<strong>逻辑块</strong>,所以每次读写的最小单位就为<strong>一个逻辑块</strong>,大小大概为<strong>4KB</strong>,也就是<strong>8个扇区</strong>,这样就提高了磁盘的读写效率</p>
<h2 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h2><p><strong>文件系统的种类众多,而操作系统希望对<code>用户提供一个统一的接口</code>,于是在用户层与文件系统层引入了中间层,这个中间层就称为虚拟文件系统(Virtual File System,VFS)</strong></p>
<p>VFS 定义了一组所有文件系统都支持的数据结构和标准接口,这样程序员不需要了解文件系统的工作原理,只需要了解 VFS 提供的统一接口即可</p>
<p>在 Linux 文件系统中,用户空间、系统调用、虚拟文件系统、缓存、文件系统以及存储之间的关系如下图:</p>
<img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F.jpg" class title="虚拟文件系统">

<h2 id="文件的使用"><a href="#文件的使用" class="headerlink" title="文件的使用"></a>文件的使用</h2><p>当我们用电脑打开一个文件的时候,我们有没有考虑过,如果文件中的数据是存储在磁盘中的话,当我们打开一个文件的时候,操作系统是如何对这个文件进行跟踪的呢？</p>
<p>在C++中,在程序方面,我们都是先用open()函数,打开一个文件,然后利用read()函数读取文件数据或者write()函数对文件进行写操作,进行玩这一切后,调用close()函数关闭文件。</p>
<p>如果知道open()函数的返回值是一个叫做<strong>文件描述符</strong>的东西,就很容易理解了。</p>
<p>当我们打开一个文件的时候,操作系统会跟踪所有打开的文件,而所谓的<strong>跟踪</strong>,其实就是给每个打开的文件分配一个<strong>文件描述符</strong>,而每个进程都会被分配一个<strong>打开文件表</strong>,文件表里的每一项就是一个文件描述符。</p>
<p>操作系统在<strong>打开文件表</strong>中维护着打开文件的<strong>状态</strong>和<strong>信息</strong>:</p>
<ol>
<li>文件指针:系统跟踪上次读写位置作为当前文件位置指针,这种指针对打开文件的某个进程来说是唯一的</li>
<li>文件打开计数器:文件关闭时,操作系统必须重用其打开文件表条目,否则表内空间不够用。因为多个进程可能打开同一个文件,所以系统在删除打开文件条目之前,必须等待最后一个进程关闭文件,该计数器跟踪打开和关闭的数量,当该计数为 0 时,系统关闭文件,删除该条目</li>
<li>文件磁盘位置:绝大多数文件操作都要求系统修改文件数据,该信息保存在内存中,以免每个操作都从磁盘中读取<br>访问权限:每个进程打开文件都需要有一个访问模式(创建、只读、读写、添加等),该信息保存在进程的打开文件表中,以便操作系统能允许或拒绝之后的 I&#x2F;O 请求</li>
</ol>
<p>我们用户和操作系统所关心的东西是截然不同的,操作系统只会关系如何将文件数据和磁盘块对应起来,也就是如何将用户修改后的文件数据写入磁盘？在什么时候写入？<br>所以,用户和操作系统对文件的读写操作是有差异的,用户习惯以字节的方式读写文件,而操作系统则是以数据块来读写文件,那屏蔽掉这种差异的工作就是文件系统了。</p>
<details class="red" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>读文件和写文件的过程 </summary>
              <div class="content">
              <p>当用户进程从文件读取 1 个字节大小的数据时,文件系统则需要获取字节所在的数据块,再返回数据块对应的用户进程所需的<strong>数据部分</strong>。<br>当用户进程把 1 个字节大小的数据写进文件时,文件系统则找到需要写入数据的数据块的位置,然后修改数据块中对应的<strong>部分</strong>,最后再把数据块写回磁盘。<br>所以说,文件系统的基本操作单位是<strong>数据块</strong>。</p>
              </div>
            </details>

<h2 id="文件数据如何存放在磁盘上的？"><a href="#文件数据如何存放在磁盘上的？" class="headerlink" title="文件数据如何存放在磁盘上的？"></a>文件数据如何存放在磁盘上的？</h2><p>文件在磁盘上的存储方式,其实和程序在内存中的存放方式一样,分为两种:</p>
<ol>
<li>连续空间存放</li>
<li>非连续空间存放<ol>
<li>链式存放</li>
<li>索引存放</li>
</ol>
</li>
</ol>
<h3 id="连续空间存放"><a href="#连续空间存放" class="headerlink" title="连续空间存放"></a>连续空间存放</h3><p>顾名思义,就是存放的数据块在磁盘上的位置是连续的。</p>
<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优势 </summary>
              <div class="content">
              <p><strong>磁盘的读取效率很高</strong>,因为磁盘的一次寻道就可以读取出整个文件。<br><code>前提是必须先知道一个文件的大小,这样文件系统才能根据文件大小在磁盘中找到合适的一块连续空间分配</code><br>所以,在文件头里指定<strong>起始块的地址</strong>以及<strong>文件大小</strong>,有这两个信息才能很好的表示文件存放在一块连续空间</p>
              </div>
            </details>

<details class="green" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>劣势 </summary>
              <div class="content">
              <div class="tabs" id="tab-first-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#first-tabs-1">磁盘空间碎片</a></li><li class="tab"><a class="#first-tabs-2">文件长度不易拓展</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-tabs-1"><p>如图所示,如果文件 B 被删除,磁盘上就留下一块空缺,这时,如果新来的文件小于其中的一个空缺,我们就可以将其放在相应空缺里。但如果该文件的大小大于所有的空缺,但却小于空缺大小之和,则虽然磁盘上有足够的空缺,但该文件还是不能存放。当然了,我们可以通过将现有文件进行挪动来腾出空间以容纳新的文件,但是这个在磁盘挪动文件是非常耗时,所以这种方式不太现实<br><img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%A3%81%E7%9B%98%E7%A2%8E%E7%89%87.jpg" class title="连续空间存放方式-磁盘碎片"><br><code>其实和虚拟内存中,分段方式所出现的问题是一样的,关于虚拟内存的文章可以看我之前写的</code><br><a class="button  regular" href="https://qx-gg.github.io/2023/03/07/blog10/" title="内存管理">内存管理</a></p></div><div class="tab-pane" id="first-tabs-2"><p>如果你知道在C++中,数组如果想要拓展的话是多麻烦,那么在文件系统的连续空间存放方式中,也是一样的麻烦,这里就不多说了</p></div></div></div><p>为了解决这些问题,就可以利用非连续空间存储</p>
              </div>
            </details>

<h3 id="非连续空间存放"><a href="#非连续空间存放" class="headerlink" title="非连续空间存放"></a>非连续空间存放</h3><h4 id="链式存放"><a href="#链式存放" class="headerlink" title="链式存放"></a>链式存放</h4><p>如果知道链表在内存中是如何存放数据的话,那么链式存放其实也差不太多,所以链表就可以消除连续空间存放中<strong>磁盘空间碎片</strong>和<strong>不易拓展</strong>的劣势,因为在这种方式下,<strong>文件的长度是可以动态拓展的</strong>,而链表其实又分为两种:<strong>隐式链表</strong>和<strong>显式链表</strong></p>
<div class="tabs" id="tab-second-tabs"><ul class="nav-tabs"><li class="tab active"><a class="#second-tabs-1">隐式链表</a></li><li class="tab"><a class="#second-tabs-2">显式链表</a></li></ul><div class="tab-content"><div class="tab-pane active" id="second-tabs-1"><p>实现的方式是文件头要包含<strong>第一块</strong>和<strong>最后一块</strong>的位置,并且每个数据块里面留出一个指针空间,用来存放下一个数据块的位置,这样一个数据块连着一个数据块,从链头开始就可以顺着指针找到所有的数据块,所以存放的方式可以是不连续的<br><img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E9%93%BE%E8%A1%A8%E6%96%B9%E5%BC%8F.jpg" class title="非连续空间存放方式-链表方式"></p>
<p>其缺陷就是:</p>
<ol>
<li>无法<strong>直接</strong>访问数据块,只能通过<strong>指针顺序</strong>访问文件,以及数据块指针消耗了一定的<strong>存储空间</strong></li>
<li>隐式链接分配的<strong>稳定性较差</strong>,系统在运行过程中由于软件或者硬件错误导致链表中的指针丢失或损坏,会导致文件数据的丢失*</li>
</ol></div><div class="tab-pane" id="second-tabs-2"><p>显示链表就是<strong>取出每个磁盘块的指针,把它放在内存的一个表中</strong>,这样就可以解决隐式链表的两个不足,方法就是把用于链接文件各数据块的指针,显式地存放在内存的一张链接表中,该表在整个磁盘仅设置一张,每个表项中存放链接指针,指向下一个数据块号</p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>举个栗子 </summary>
              <div class="content">
              <p>对于显式链接的工作方式,我们举个例子,文件 A 依次使用了磁盘块 4、7、2、10 和 12 ,文件 B 依次使用了磁盘块 6、3、11 和 14 。利用下图中的表,可以从第 4 块开始,顺着链走到最后,找到文件 A 的全部磁盘块。同样,从第 6 块开始,顺着链走到最后,也能够找出文件 B 的全部磁盘块。最后,这两个链都以一个不属于有效磁盘编号的特殊标记(如 -1 )结束。内存中的这样一个表格称为文件分配表(File Allocation Table,FAT)。<br><img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E6%96%87%E4%BB%B6%E5%88%86%E9%85%8D%E8%A1%A8.jpg" class title="文件分配表"></p>
              </div>
            </details>

<p>当然了,这样做也有不足的:<br>当一个文件很大的时候,就需要创建一个很大的<strong>文件分配表</strong>,而<strong>文件分配表</strong>是存放在内存中的,所以这样做不适合应用于大文件</p></div></div></div>

<h4 id="索引存放"><a href="#索引存放" class="headerlink" title="索引存放"></a>索引存放</h4><p>链表的方式解决了连续分配的磁盘碎片和文件动态扩展的问题,但是不能有效支持直接访问(FAT除外),索引的方式可以解决这个问题。</p>
<p>索引的实现是为每个文件创建一个<strong>索引数据块</strong>,里面存放的是指向文件数据块的指针列表,说白了就像书的目录一样,要找哪个章节的内容,看目录查就可以。</p>
<p>另外,文件头需要包含指向<strong>索引数据块</strong>的指针,这样就可以通过文件头知道索引数据块的位置,再通过索引数据块里的索引信息找到对应的数据块。</p>
<p>创建文件时,索引块的所有指针都设为空。当首次写入第 i 块时,先从空闲空间中取得一个块,再将其地址写到索引块的第 i 个条目。</p>
<img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E9%9D%9E%E8%BF%9E%E7%BB%AD%E7%A9%BA%E9%97%B4%E5%AD%98%E6%94%BE%E6%96%B9%E5%BC%8F-%E7%B4%A2%E5%BC%95%E6%96%B9%E5%BC%8F.jpg" class title="非连续空间存放方式-索引方式">

<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>优点 </summary>
              <div class="content">
              <ol><li>文件的创建、拓展、缩减很方便</li><li>不会有碎片的问题</li><li>支持顺序读写和随机读写</li></ol>
              </div>
            </details>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>缺点 </summary>
              <div class="content">
              <ol><li>由于<strong>索引数据块</strong>也是存放在磁盘块的,如果文件很小,明明只需一块就可以存放的下,但还是需要额外分配一块来存放索引数据,所以缺陷之一就是存储索引带来的开销。</li><li>当文件很大的时候,一块<strong>索引数据块</strong>没办法一次性放下时,就需要通过别的方法来实现<ol><li><strong>链表+索引</strong>,这种组合称为<strong>链式索引块</strong>,它的实现方式是在<strong>索引数据块</strong>留出一个<strong>存放下一个索引数据块的指针</strong>,于是当一个索引数据块的索引信息用完了,就可以通过指针的方式,找到下一个索引数据块的信息。那这种方式也会出现前面提到的链表方式的问题,万一某个指针损坏了,后面的数据也就会无法读取了。<img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E9%93%BE%E5%BC%8F%E7%B4%A2%E5%BC%95%E5%9D%97.jpg" class title="链式索引块"></li><li><strong>索引+索引</strong>,这种组合称为<strong>多级索引块</strong>,实现方式是通过一个索引块来存放多个索引数据块,一层套一层索引<img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95%E5%9D%97.jpg" class title="多级索引块"></li></ol></li></ol>
              </div>
            </details>

<h2 id="空闲磁盘空间管理"><a href="#空闲磁盘空间管理" class="headerlink" title="空闲磁盘空间管理"></a>空闲磁盘空间管理</h2><p>前面说完了文件是如何在磁盘空间存放的,那么文件系统又是如何找出<strong>空闲磁盘空间</strong>用于存放文件数据呢？<br>其中又有3种方法:</p>
<ol>
<li>空闲表法</li>
<li>空闲链表法</li>
<li>位图法</li>
</ol>
<h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>空闲表法就是为所有空闲空间建立一张表,表内容包括空闲区的第一个块号和该空闲区的块个数,注意,这个方式是连续分配的。如下图:</p>
<img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E7%A9%BA%E9%97%B2%E8%A1%A8%E6%B3%95.jpg" class title="空闲表法">
<p>当请求分配磁盘空间时,系统依次扫描空闲表里的内容,直到找到一个合适的空闲区域为止。当用户撤销一个文件时,系统回收文件空间。这时,也需顺序扫描空闲表,寻找一个空闲表条目并将释放空间的第一个物理块号及它占用的块数填到这个条目中。</p>
<p><code>这种方法仅当有少量的空闲区时才有较好的效果。因为,如果存储空间中有着大量的小的空闲区,则空闲表变得很大,这样查询效率会很低。另外,这种分配技术适用于建立连续文件。</code></p>
<h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>我们也可以使用<strong>链表</strong>的方式来管理空闲空间,每一个空闲块里有一个指针指向下一个空闲块,这样也能很方便的找到空闲块并管理起来。如下图:</p>
<img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E7%A9%BA%E9%97%B2%E5%9D%97%E9%93%BE%E8%A1%A8.jpg" class title="空闲块链表">
<p>当创建文件需要一块或几块时,就从链头上依次取下一块或几块。反之,当回收空间时,把这些空闲块依次接到链头上。<br>这种技术只要在主存中保存一个指针,令它指向第一个空闲块。其特点是简单,但不能随机访问,工作效率低,因为每当在链上增加或移动空闲块时需要做很多 I&#x2F;O 操作,同时数据块的指针消耗了一定的存储空间。</p>
<p><code>空闲表法和空闲链表法都不适合用于大型文件系统,因为这会使空闲表或空闲链表太大。</code></p>
<h3 id="位图法"><a href="#位图法" class="headerlink" title="位图法"></a>位图法</h3><p>位图是利用二进制的一位来表示磁盘中一个盘块的使用情况,磁盘上所有的盘块都有一个二进制位与之对应。</p>
<p>当值为<strong>0</strong>时,表示对应的盘块空闲,值为<strong>1</strong>时,表示对应的盘块已分配。</p>
<p><code>在 Linux 文件系统就采用了位图的方式来管理空闲空间,不仅用于数据空闲块的管理,还用于 inode 空闲块的管理,因为 inode 也是存储在磁盘的,自然也要有对其管理</code></p>
<h2 id="文件系统的结构"><a href="#文件系统的结构" class="headerlink" title="文件系统的结构"></a>文件系统的结构</h2><p>用户在创建一个新文件时,Linux 内核会通过 inode 的位图找到空闲可用的 inode,并进行分配。要存储数据时,会通过块的位图找到空闲的块,并分配</p>
<p>但是!因为数据块的<strong>位图</strong>其实还是存放在磁盘块中的,我们算一下:<br>一个磁盘块是<strong>4KB</strong>,每一位代表一个数据块,所以可以表示<code>4*024*8=2^15</code>个空闲块,由于每个数据块也是在磁盘上,也为<strong>4KB</strong>,那么一个位图最多可以表示<code>2^15*4*1024=2^27</code>byte,也就是128M,也就是说,如果采用<strong>一个块的位图 + 一系列的块</strong>,外加<strong>一个块的 inode 的位图 + 一系列的 inode 的结构</strong>能表示的最大空间也就 128M,这太少了,现在很多文件都比这个大。</p>
<p>在 Linux 文件系统,把这个结构称为一个<strong>块组</strong>,那么有<strong>N</strong>多的<strong>块组</strong>,就能够表示<strong>N</strong>大的文件。</p>
<p>下图给出了 Linux Ext2 整个文件系统的结构和块组的内容,文件系统都由大量<strong>块组</strong>组成,在硬盘上相继排布:</p>
<img lazyload src="/images/loading.svg" data-src="/2023/06/28/blog18/%E5%9D%97%E7%BB%84.jpg" class title="块组">
<p>最前面的第一个块是引导块,在系统启动时用于启用引导,接着后面就是一个一个连续的块组了,块组的内容如下:</p>
<ol>
<li><p><strong>超级块</strong>,包含的是文件系统的重要信息,比如 inode 总个数、块总个数、每个块组的 inode 个数、每个块组的块个数等等。</p>
</li>
<li><p><strong>块组描述符</strong>,包含文件系统中各个块组的状态,比如块组中空闲块和 inode 的数目等,每个块组都包含了文件系统中<strong>所有块组的组描述符信息</strong>。</p>
</li>
<li><p><strong>数据位图和 inode 位图</strong>, 用于表示对应的数据块或 inode 是空闲的,还是被使用中。</p>
</li>
<li><p><strong>inode 列表</strong>,包含了块组中所有的 inode,inode 用于保存文件系统中与各个文件和目录相关的所有元数据。</p>
</li>
<li><p><strong>数据块</strong>,包含文件的有用数据。<br>你可以会发现每个块组里有很多重复的信息,比如<strong>超级块和块组描述符表</strong>,这两个都是<strong>全局信息</strong>,而且非常的重要,这么做是有两个原因:</p>
</li>
<li><p>如果系统崩溃破坏了超级块或块组描述符,有关文件系统结构和内容的所有信息都会丢失。如果有冗余的副本,该信息是可能恢复的。</p>
</li>
<li><p>通过使文件和管理数据尽可能接近,减少了磁头寻道和旋转,这可以提高文件系统的性能。</p>
</li>
</ol>
<p>不过,Ext2 的后续版本采用了稀疏技术。该做法是,超级块和块组描述符表不再存储到文件系统的每个块组中,而是只写入到块组 0、块组 1 和其他 ID 可以表示为 3、 5、7 的幂的块组中。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文图片均来自小林Coding(<a class="link" href="https://xiaolincoding.com/os/6_file_system/file_system.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84">https://xiaolincoding.com/os/6_file_system/file_system.html#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>)<br>虽然本人是有样学样地将小林地这篇文章写了下来,好记忆不如烂笔头,每次写完都能学到很多</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
